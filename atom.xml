<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老JI</title>
  
  <subtitle>The transformation from ordinary to extraordinary will not occur overnight !</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wuchao.net.cn/"/>
  <updated>2018-09-29T08:45:42.000Z</updated>
  <id>http://www.wuchao.net.cn/</id>
  
  <author>
    <name>老JI</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程同步方法和问题以及解决方案</title>
    <link href="http://www.wuchao.net.cn/2018/09/29/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%92%8C%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://www.wuchao.net.cn/2018/09/29/线程同步方法和问题以及解决方案/</id>
    <published>2018-09-29T08:07:37.000Z</published>
    <updated>2018-09-29T08:45:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在日常开发中，需要当几个任务执行完之后再执行最后一个任务。一下就列举几个线程同步的常用方法，并指出其中的问题，以及提出解决方按。</p></blockquote><h3 id="Dispatch-Group-调度组"><a href="#Dispatch-Group-调度组" class="headerlink" title="Dispatch Group 调度组"></a>Dispatch Group 调度组</h3><h4 id="dispatch-group-notify-正常情况"><a href="#dispatch-group-notify-正常情况" class="headerlink" title="dispatch_group_notify 正常情况"></a>dispatch_group_notify 正常情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">- (void)dispathcGroupNotify &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    NSLog(@&quot;group---begin&quot;);</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.jiwuchao.www&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.jiwuchao.www1&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.jiwuchao.www2&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue1, ^&#123;</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue2, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        // 等前面的异步任务1、任务2都执行完毕后，回到主线程执行下边任务</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;4---%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;group---end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line"></span><br><span class="line">currentThread---&lt;NSThread: 0x600002cc7c40&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">group---begin</span><br><span class="line">1---&lt;NSThread: 0x600002ca3a00&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">1---&lt;NSThread: 0x600002c84300&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3---&lt;NSThread: 0x600002c66840&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">1---&lt;NSThread: 0x600002c84300&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3---&lt;NSThread: 0x600002c66840&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">1---&lt;NSThread: 0x600002ca3a00&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">4---&lt;NSThread: 0x600002cc7c40&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">4---&lt;NSThread: 0x600002cc7c40&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">group---end</span><br></pre></td></tr></table></figure><p>&emsp; 以上执行结果是当任务1，2，3 执行完成之后才执行任务4 符合预期</p><h4 id="dispatch-group-notify-异常情况"><a href="#dispatch-group-notify-异常情况" class="headerlink" title="dispatch_group_notify 异常情况"></a>dispatch_group_notify 异常情况</h4><h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h4><blockquote><p>理想是 任务1 任务2 任务3 执行完成之后再执行任务4 为什有时会出现某个任务还没有执行完就开始执行任务4？比如有多个接口进行网络请求，当所有接口返回之后才刷新界面</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">- (void)dispathcGroupQuestion &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    NSLog(@&quot;group---begin&quot;);</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.jiwuchao.www&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.jiwuchao.www1&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.jiwuchao.www2&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    //任务1</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;任务1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 任务2</span><br><span class="line">    dispatch_group_async(group, queue1, ^&#123;</span><br><span class="line">        </span><br><span class="line">//        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">//            [NSThread sleepForTimeInterval:2];</span><br><span class="line">//            NSLog(@&quot;任务2---%@&quot;,[NSThread currentThread]);</span><br><span class="line">//        &#125;</span><br><span class="line">        </span><br><span class="line">        dispatch_queue_t queue4 =  dispatch_queue_create(&quot;wuchao.w&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">        /*</span><br><span class="line">           如果dispatch_async 换成 dispatch_sync 则不会出现 上面的乱序问题y，因为并发队列 + 同步执行 并不能创建多个线程 所有任务2</span><br><span class="line">         的线程结束就是任务2及其子线程执行完的时机</span><br><span class="line">         */</span><br><span class="line">        dispatch_async(queue4, ^&#123;</span><br><span class="line">            // 子任务1</span><br><span class="line">            for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                [NSThread sleepForTimeInterval:2];</span><br><span class="line">                NSLog(@&quot;任务2的-子任务1 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">            &#125;</span><br><span class="line">            // 子任务2</span><br><span class="line">            for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                [NSThread sleepForTimeInterval:2];</span><br><span class="line">                NSLog(@&quot;任务2的-子任务2 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">            &#125;</span><br><span class="line">            // 子任务3</span><br><span class="line">            for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                [NSThread sleepForTimeInterval:2];</span><br><span class="line">                NSLog(@&quot;任务2的-子任务3 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">    //任务3</span><br><span class="line">    dispatch_group_async(group, queue2, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;任务3---%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        // 等前面的异步任务1、任务2都执行完毕后，回到主线程执行下边任务</span><br><span class="line">        NSLog(@&quot;前面的异步操作都执行完毕&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;开始执行dispatch_group_notify ---%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;group---end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">currentThread---&lt;NSThread: 0x600003787ec0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">group---begin</span><br><span class="line">任务3---&lt;NSThread: 0x60000372ed00&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">任务1---&lt;NSThread: 0x6000037eaa80&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">任务2的-子任务1 - &lt;NSThread: 0x6000037ca500&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">任务3---&lt;NSThread: 0x60000372ed00&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">任务1---&lt;NSThread: 0x6000037eaa80&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">任务2的-子任务1 - &lt;NSThread: 0x6000037ca500&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">前面的异步操作都执行完毕</span><br><span class="line">开始执行dispatch_group_notify ---&lt;NSThread: 0x600003787ec0&gt;&#123;number = 1, name =</span><br><span class="line">任务2的-子任务2 - &lt;NSThread: 0x6000037ca500&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">开始执行dispatch_group_notify ---&lt;NSThread: 0x600003787ec0&gt;&#123;number = 1, name =</span><br><span class="line">group---end</span><br><span class="line">任务2的-子任务2 - &lt;NSThread: 0x6000037ca500&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">任务2的-子任务3 - &lt;NSThread: 0x6000037ca500&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">任务2的-子任务3 - &lt;NSThread: 0x6000037ca500&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>结论： 从上面的输出可以看出 ，当任务2 的子任务还没有执行完毕，就开始执行dispatch_group_notify中的任务，和预期任务2 执行完之后再执行 dispatch_group_notify中任务有出入</p><h4 id="问题分析-为什么会出现这种情况？"><a href="#问题分析-为什么会出现这种情况？" class="headerlink" title="问题分析:为什么会出现这种情况？"></a>问题分析:为什么会出现这种情况？</h4><blockquote><p>原因是：因为对于dispatch_group_notify 来说判断其之前的任务执行完毕的==根据是任务2 的线程执行完毕，不考虑任务2中其他子任务的线程是否执行完毕==。此时任务2的子任务是异步并发执行，开启多个线程。并没有阻塞任务2的线程，所以在其他线程中执行任务2的子任务的时候任务2的线程已经执行完了。当任务1 任务2 任务3 执行完毕之后就开始执行dispatch_group_notify 中的任务。但是任务2 中的子任务还在执行，这时就看到了输出的那样的结果。</p></blockquote><h4 id="问题解决-方法-1，2"><a href="#问题解决-方法-1，2" class="headerlink" title="问题解决:方法 1，2"></a>问题解决:方法 1，2</h4><h5 id="解决方法1-dispatch-group-enter-和-dispatch-group-leave"><a href="#解决方法1-dispatch-group-enter-和-dispatch-group-leave" class="headerlink" title="解决方法1  dispatch_group_enter 和 dispatch_group_leave"></a>解决方法1  dispatch_group_enter 和 dispatch_group_leave</h5><p>&emsp; dispatch_group_enter与dispatch_group_leave 组合比dispatch_group_async 更灵活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">- (void)dispathcGroupAnswer &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    NSLog(@&quot;group---begin&quot;);</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.jiwuchao.www&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.jiwuchao.www1&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.jiwuchao.www2&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    //任务1</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;任务1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    //任务2</span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(queue1, ^&#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_queue_t queue4 =  dispatch_queue_create(&quot;wuchao.w&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">        /*</span><br><span class="line">         如果dispatch_async 换成 dispatch_sync 则不会出现 上面的乱序问题y，因为并发队列 + 同步执行 并不能创建多个线程 所有任务2</span><br><span class="line">         的线程结束就是任务2及其子线程执行完的时机</span><br><span class="line">         */</span><br><span class="line">        dispatch_async(queue4, ^&#123;</span><br><span class="line">            // 子任务1</span><br><span class="line">            for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                [NSThread sleepForTimeInterval:2];</span><br><span class="line">                NSLog(@&quot;任务2的-子任务1 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">            &#125;</span><br><span class="line">            // 子任务2</span><br><span class="line">            for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                [NSThread sleepForTimeInterval:2];</span><br><span class="line">                NSLog(@&quot;任务2的-子任务2 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">            &#125;</span><br><span class="line">            // 子任务3</span><br><span class="line">            for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                [NSThread sleepForTimeInterval:2];</span><br><span class="line">                NSLog(@&quot;任务2的-子任务3 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">            &#125;</span><br><span class="line">            // 子任务1，2，3 是在同一个线程执行 当子任务1，2，3 执行完之后再leave 上层group 告诉nofify 这个任务2 已经完成了 才能正确完成同步 假如子任务中还有嵌套 那么还需要此种解决方法依次类推</span><br><span class="line">            dispatch_group_leave(group);</span><br><span class="line">        &#125;);</span><br><span class="line">        // 这一句放在这里是不行的</span><br><span class="line">//        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    //任务3</span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(queue2, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;任务3---%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        // 等前面的异步任务1、任务2都执行完毕后，回到主线程执行下边任务</span><br><span class="line">        NSLog(@&quot;前面的异步操作都执行完毕&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;开始执行dispatch_group_notify ---%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;group---end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;不会阻塞主线程-----&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">currentThread---&lt;NSThread: 0x60000094d380&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">group---begin</span><br><span class="line">不会阻塞主线程-----</span><br><span class="line">任务1---&lt;NSThread: 0x60000091aec0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">任务2的-子任务1 - &lt;NSThread: 0x6000009e7a80&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">任务3---&lt;NSThread: 0x600000928300&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">任务1---&lt;NSThread: 0x60000091aec0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">任务2的-子任务1 - &lt;NSThread: 0x6000009e7a80&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">任务3---&lt;NSThread: 0x600000928300&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">任务2的-子任务2 - &lt;NSThread: 0x6000009e7a80&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">任务2的-子任务2 - &lt;NSThread: 0x6000009e7a80&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">任务2的-子任务3 - &lt;NSThread: 0x6000009e7a80&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">任务2的-子任务3 - &lt;NSThread: 0x6000009e7a80&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">前面的异步操作都执行完毕</span><br><span class="line">开始执行dispatch_group_notify ---&lt;NSThread: 0x60000094d380&gt;&#123;number = 1, name =</span><br><span class="line">开始执行dispatch_group_notify ---&lt;NSThread: 0x60000094d380&gt;&#123;number = 1, name =</span><br><span class="line">group---end</span><br></pre></td></tr></table></figure><p>结论：从输出接果可以看到输出结果符合预期。综合上述原因，用 <strong>dispatch_group_leave(group)</strong>  当任务2 的子任务的线程执行完之后才标识任务2执行完，才会触发 dispatch_group_notify 而不是当任务2线程执行完就触发dispatch_group_notify。</p><h5 id="解决方法2-dispatch-semaphore-t-信号量"><a href="#解决方法2-dispatch-semaphore-t-信号量" class="headerlink" title="解决方法2 dispatch_semaphore_t 信号量"></a>解决方法2 dispatch_semaphore_t 信号量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">- (void)dispathcGroupAnswer2 &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    NSLog(@&quot;group---begin&quot;);</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.jiwuchao.www&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.jiwuchao.www1&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.jiwuchao.www2&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    //任务1</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;任务1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 任务2</span><br><span class="line">    dispatch_group_async(group, queue1, ^&#123;</span><br><span class="line">        dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">        dispatch_queue_t queue4 =  dispatch_queue_create(&quot;wuchao.w&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">        /*</span><br><span class="line">         如果dispatch_async 换成 dispatch_sync 则不会出现 上面的乱序问题y，因为并发队列 + 同步执行 并不能创建多个线程 所有任务2</span><br><span class="line">         的线程结束就是任务2及其子线程执行完的时机</span><br><span class="line">         */</span><br><span class="line">        </span><br><span class="line">        dispatch_async(queue4, ^&#123;</span><br><span class="line">            // 子任务1</span><br><span class="line">            for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                [NSThread sleepForTimeInterval:2];</span><br><span class="line">                NSLog(@&quot;任务2的-子任务1 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">            &#125;</span><br><span class="line">            // 子任务2</span><br><span class="line">            for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                [NSThread sleepForTimeInterval:2];</span><br><span class="line">                NSLog(@&quot;任务2的-子任务2 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">            &#125;</span><br><span class="line">            // 子任务3</span><br><span class="line">            for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                [NSThread sleepForTimeInterval:2];</span><br><span class="line">                NSLog(@&quot;任务2的-子任务3 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            // 信号量加  1</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">            </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        //  信号量 -1 </span><br><span class="line">        dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, (int64_t)(15 * NSEC_PER_SEC)));</span><br><span class="line">    &#125;);</span><br><span class="line">    //任务3</span><br><span class="line">    dispatch_group_async(group, queue2, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;任务3---%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        // 等前面的异步任务1、任务2都执行完毕后，回到主线程执行下边任务</span><br><span class="line">        NSLog(@&quot;前面的异步操作都执行完毕&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;开始执行dispatch_group_notify ---%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;group---end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">currentThread---&lt;NSThread: 0x600002332a00&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">group---begin</span><br><span class="line">任务3---&lt;NSThread: 0x600002343580&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">任务1---&lt;NSThread: 0x6000023435c0&gt;&#123;number = 9, name = (null)&#125;</span><br><span class="line">任务2的-子任务1 - &lt;NSThread: 0x6000023591c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">任务3---&lt;NSThread: 0x600002343580&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">任务2的-子任务1 - &lt;NSThread: 0x6000023591c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">任务1---&lt;NSThread: 0x6000023435c0&gt;&#123;number = 9, name = (null)&#125;</span><br><span class="line">任务2的-子任务2 - &lt;NSThread: 0x6000023591c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">任务2的-子任务2 - &lt;NSThread: 0x6000023591c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">任务2的-子任务3 - &lt;NSThread: 0x6000023591c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">任务2的-子任务3 - &lt;NSThread: 0x6000023591c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">前面的异步操作都执行完毕</span><br><span class="line">开始执行dispatch_group_notify ---&lt;NSThread: 0x600002332a00&gt;&#123;number = 1, name = m</span><br><span class="line">开始执行dispatch_group_notify ---&lt;NSThread: 0x600002332a00&gt;&#123;number = 1, name = m</span><br><span class="line">group---end</span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><p>&emsp;输出结果符合预期。和dispatch_group_enter 和 dispatch_group_leave 作用一样。因为信号量初始化为0 ，当任务2 的子线程执行完成之后会执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//信号量加  1</span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br></pre></td></tr></table></figure><p>使信号量加一操作，那么当走到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">信号量加1 此方法的作用是，可以使总信号量减1，当信号总量为0时，再减一就小于0了，就会一直等待（阻塞所在线程），否则就可以正常执行。</span><br><span class="line"></span><br><span class="line"> dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, (int64_t)(15 * NSEC_PER_SEC)));</span><br></pre></td></tr></table></figure><p>这一句时，因为此时信号量等于1 ，那么不会阻塞当前(任务2)线程，那么任务2算是完成。假如任务2的子任务没有完成就不会走到 <strong> dispatch_semaphore_signal(semaphore) </strong> 这个方法，信号量仍然为0，会一直阻塞注任务2的线程。</p><h3 id="dispatch-barrier-async-和-dispatch-barrier-sync-栅栏函数"><a href="#dispatch-barrier-async-和-dispatch-barrier-sync-栅栏函数" class="headerlink" title="dispatch_barrier_async 和 dispatch_barrier_sync 栅栏函数"></a>dispatch_barrier_async 和 dispatch_barrier_sync 栅栏函数</h3><h4 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h4><blockquote><p>dispatch_barrier_async的作用是等待队列的前面的任务执行完毕后，才执行dispatch_barrier_async的block里面的任务,不会阻塞当前线程；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">- (void)barrierAsync &#123;</span><br><span class="line">    // 创建一个并发队列</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.jiwuchao.barrierAsync&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:1];</span><br><span class="line">            NSLog(@&quot;1 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:1];</span><br><span class="line">            NSLog(@&quot;2 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:1];</span><br><span class="line">            NSLog(@&quot;i %ld dispatch_barrier_async 任务&quot;,i);</span><br><span class="line">        &#125;</span><br><span class="line">        [NSThread sleepForTimeInterval:5];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:1];</span><br><span class="line">            NSLog(@&quot;3 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:1];</span><br><span class="line">            NSLog(@&quot;4 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;当前线程阻塞住了吗？没有&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印:</span><br><span class="line"></span><br><span class="line">2 - &lt;NSThread: 0x600002ac0ec0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">1 - &lt;NSThread: 0x600002a242c0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">1 - &lt;NSThread: 0x600002a242c0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2 - &lt;NSThread: 0x600002ac0ec0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">i 0 dispatch_barrier_async 任务</span><br><span class="line">i 1 dispatch_barrier_async 任务</span><br><span class="line">3 - &lt;NSThread: 0x600002ac0ec0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">4 - &lt;NSThread: 0x600002ae3ec0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">4 - &lt;NSThread: 0x600002ae3ec0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3 - &lt;NSThread: 0x600002ac0ec0&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>结论 ：</p><ol><li>dispatch_barrier_async 不会阻塞当前线程</li><li>dispatch_barrier_async 会等到前面的任务执行完之后再执行后面的任务</li></ol><h4 id="dispatch-barrier-sync"><a href="#dispatch-barrier-sync" class="headerlink" title="dispatch_barrier_sync"></a>dispatch_barrier_sync</h4><blockquote><p>dispatch_barrier_sync的作用是等待队列的前面的任务执行完毕后，才执行dispatch_barrier_async的block里面的任务,阻塞当前线程</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- (void)barrierSync &#123;</span><br><span class="line">    // 创建一个并发队列</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.jiwuchao.barrierAsync&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:1];</span><br><span class="line">            NSLog(@&quot;1 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:1];</span><br><span class="line">            NSLog(@&quot;2 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    dispatch_barrier_sync(queue, ^&#123;</span><br><span class="line">        </span><br><span class="line">        for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:1];</span><br><span class="line">            NSLog(@&quot;i %ld dispatch_barrier_sync 任务&quot;,i);</span><br><span class="line">        &#125;</span><br><span class="line">        [NSThread sleepForTimeInterval:5];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:1];</span><br><span class="line">            NSLog(@&quot;3 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:1];</span><br><span class="line">            NSLog(@&quot;4 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;当前线程阻塞住了吗？阻塞住了&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">打印:</span><br><span class="line"></span><br><span class="line">2 - &lt;NSThread: 0x60000346c4c0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">1 - &lt;NSThread: 0x60000349f880&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">1 - &lt;NSThread: 0x60000349f880&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2 - &lt;NSThread: 0x60000346c4c0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">i 0 dispatch_barrier_sync 任务</span><br><span class="line">i 1 dispatch_barrier_sync 任务</span><br><span class="line">当前线程阻塞住了吗？阻塞住了</span><br><span class="line">4 - &lt;NSThread: 0x60000345db80&gt;&#123;number = 10, name = (null)&#125;</span><br><span class="line">3 - &lt;NSThread: 0x60000345dc00&gt;&#123;number = 9, name = (null)&#125;</span><br><span class="line">3 - &lt;NSThread: 0x60000345dc00&gt;&#123;number = 9, name = (null)&#125;</span><br><span class="line">4 - &lt;NSThread: 0x60000345db80&gt;&#123;number = 10, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>“ <strong>当前线程阻塞住了吗？阻塞住了</strong> “ 在当前线程中的输出 等到dispatch_barrier_sync 执行之后才执行</p><p>结论：</p><ol><li>dispatch_barrier_sync 会阻塞当前线程（主线程/非主线程）</li><li>dispatch_barrier_sync会等到前面的任务执行完之后再执行后面的任务</li></ol><h4 id="问题描述-为什么没有等待-dispatch-barrier-async-之前的任务执行完就开始执行-dispatch-barrier-async-的block任务？？"><a href="#问题描述-为什么没有等待-dispatch-barrier-async-之前的任务执行完就开始执行-dispatch-barrier-async-的block任务？？" class="headerlink" title="问题描述:为什么没有等待  dispatch_barrier_async 之前的任务执行完就开始执行 dispatch_barrier_async 的block任务？？"></a>问题描述:为什么没有等待  dispatch_barrier_async 之前的任务执行完就开始执行 dispatch_barrier_async 的block任务？？</h4><p>&emsp; 上述情况会在dispatch_barrier_async 出现，在dispatch_barrier_sync不会出现。</p><p>代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">- (void)barrierAsynQuestion &#123;</span><br><span class="line">        NSLog(@&quot;1 current thread -%@&quot;,[NSThread currentThread]);</span><br><span class="line">        // 创建一个并发队列</span><br><span class="line">        dispatch_queue_t queue = dispatch_queue_create(&quot;com.jiwuchao.barrierAsync&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">        //任务1</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                [NSThread sleepForTimeInterval:1];</span><br><span class="line">                NSLog(@&quot;任务1 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //任务2</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;任务2 current thread -%@&quot;,[NSThread currentThread]);</span><br><span class="line">            /*</span><br><span class="line">             第一种情况 会开启新线程</span><br><span class="line">             */</span><br><span class="line">//            // 1 和 dispatch_async(queue, ^&#123;&#125; 是不是同一个线程 重新开启一个线程 异步 执行完之后回调</span><br><span class="line">//            [Download downloadData:^(BOOL success) &#123;</span><br><span class="line">//                NSLog(@&quot;正在执行下载完成之后的任务&quot;);</span><br><span class="line">//                [NSThread sleepForTimeInterval:3];</span><br><span class="line">//                NSLog(@&quot;下载完成之后的任务完成&quot;);</span><br><span class="line">//            &#125;];</span><br><span class="line">            </span><br><span class="line">            /*</span><br><span class="line">                第二种情况 如果是单个任务 不会开启新线程 如果是多个子任务则会开启线程</span><br><span class="line">             */</span><br><span class="line">            </span><br><span class="line">            dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.wuchaoji.http&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">            </span><br><span class="line">            dispatch_async(queue2, ^&#123;</span><br><span class="line">                NSLog(@&quot;3 current thread -%@&quot;,[NSThread currentThread]);</span><br><span class="line">                // 子任务1</span><br><span class="line">                for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                    [NSThread sleepForTimeInterval:1];</span><br><span class="line">                    NSLog(@&quot;子任务1 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">                &#125;</span><br><span class="line">                // 子任务2</span><br><span class="line">                for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                    [NSThread sleepForTimeInterval:1];</span><br><span class="line">                    NSLog(@&quot;子任务2 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">                &#125;</span><br><span class="line">                // 子任务3</span><br><span class="line">                for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                    [NSThread sleepForTimeInterval:1];</span><br><span class="line">                    NSLog(@&quot;子任务3 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">     </span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">        dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">            for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                [NSThread sleepForTimeInterval:1];</span><br><span class="line">                NSLog(@&quot;i %ld dispatch_barrier_async 任务&quot;,i);</span><br><span class="line">            &#125;</span><br><span class="line">            [NSThread sleepForTimeInterval:5];</span><br><span class="line">        &#125;);</span><br><span class="line">        // 任务3</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                [NSThread sleepForTimeInterval:1];</span><br><span class="line">                NSLog(@&quot;任务3 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 任务4</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                [NSThread sleepForTimeInterval:1];</span><br><span class="line">                NSLog(@&quot;任务4 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印:</span><br><span class="line"></span><br><span class="line">1 current thread -&lt;NSThread: 0x6000036be740&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">任务2 current thread -&lt;NSThread: 0x6000036d1000&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">3 current thread -&lt;NSThread: 0x600003633880&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">任务1 - &lt;NSThread: 0x600003631280&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">子任务1 - &lt;NSThread: 0x600003633880&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">子任务1 - &lt;NSThread: 0x600003633880&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">任务1 - &lt;NSThread: 0x600003631280&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">子任务2 - &lt;NSThread: 0x600003633880&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">i 0 dispatch_barrier_async 任务</span><br><span class="line">i 1 dispatch_barrier_async 任务</span><br><span class="line">子任务2 - &lt;NSThread: 0x600003633880&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">子任务3 - &lt;NSThread: 0x600003633880&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">子任务3 - &lt;NSThread: 0x600003633880&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">任务3 - &lt;NSThread: 0x6000036e9380&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">任务4 - &lt;NSThread: 0x600003633880&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">任务3 - &lt;NSThread: 0x6000036e9380&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">任务4 - &lt;NSThread: 0x600003633880&gt;&#123;number = 6, name = (null)&#125;</span><br></pre></td></tr></table></figure><h4 id="问题分析-和group-notify-类似"><a href="#问题分析-和group-notify-类似" class="headerlink" title="问题分析:和group_notify 类似"></a>问题分析:和group_notify 类似</h4><h5 id="情况1-在嵌套任务中有一个任务："><a href="#情况1-在嵌套任务中有一个任务：" class="headerlink" title="情况1 在嵌套任务中有一个任务："></a>情况1 在嵌套任务中有一个任务：</h5><blockquote><p>在并发队列中有单个任务时不会开启新的线程，那么和当前线程(任务2)的线程是同一个线程，当前任务2执行完也就是其中子线程的任务执行完毕。</p></blockquote><h5 id="情况2-在嵌套任务中有多个任务："><a href="#情况2-在嵌套任务中有多个任务：" class="headerlink" title="情况2 在嵌套任务中有多个任务："></a>情况2 在嵌套任务中有多个任务：</h5><blockquote><p>在并发队列中有多个任务就会开启多个线程异步执行，多个任务异步执行并不会阻塞任务2 的线程，那么任务2 线程执行完毕的标准是把其子任务全部提交到执行队列，那么此时dispatch_barrier_async 检测到 任务1 任务2 都已经完成就会执行dispatch_barrier_async 的任务，但是任务2 系统对完成的判断标准是把其子任务提交到执行队列，此线程的任务已经完成，但是此线程其他的线程它不负责<br>            所以会出现在看似 线程2还没有执行完就开始执行dispatch_barrier_async 的任务，<strong>貌似dispatch_barrier_async 没有起作用和一样</strong>。</p></blockquote><h4 id="问题解决：信号量"><a href="#问题解决：信号量" class="headerlink" title="问题解决：信号量"></a>问题解决：信号量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)barrierAsynAnswer &#123;</span><br><span class="line">    NSLog(@&quot;1 current thread -%@&quot;,[NSThread currentThread]);</span><br><span class="line">    // 创建一个并发队列</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.jiwuchao.barrierAsync&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    //任务1</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:1];</span><br><span class="line">            NSLog(@&quot;任务1 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    //任务2</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;任务2 current thread -%@&quot;,[NSThread currentThread]);</span><br><span class="line">        /*</span><br><span class="line">         第一种情况 会开启新线程</span><br><span class="line">         */</span><br><span class="line">        //            // 1 和 dispatch_async(queue, ^&#123;&#125; 是不是同一个线程 重新开启一个线程 异步 执行完之后回调</span><br><span class="line">        //            [Download downloadData:^(BOOL success) &#123;</span><br><span class="line">        //                NSLog(@&quot;正在执行下载完成之后的任务&quot;);</span><br><span class="line">        //                [NSThread sleepForTimeInterval:3];</span><br><span class="line">        //                NSLog(@&quot;下载完成之后的任务完成&quot;);</span><br><span class="line">        //            &#125;];</span><br><span class="line">        </span><br><span class="line">        /*</span><br><span class="line">         第二种情况 如果是单个任务 不会开启新线程 如果是多个子任务则会开启线程</span><br><span class="line">         */</span><br><span class="line">        </span><br><span class="line">        dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.wuchaoji.http&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">        </span><br><span class="line">        dispatch_async(queue2, ^&#123;</span><br><span class="line">            NSLog(@&quot;3 current thread -%@&quot;,[NSThread currentThread]);</span><br><span class="line">            // 子任务1</span><br><span class="line">            for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                [NSThread sleepForTimeInterval:1];</span><br><span class="line">                NSLog(@&quot;子任务1 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">            &#125;</span><br><span class="line">            // 子任务2</span><br><span class="line">            for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                [NSThread sleepForTimeInterval:1];</span><br><span class="line">                NSLog(@&quot;子任务2 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">            &#125;</span><br><span class="line">            // 子任务3</span><br><span class="line">            for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                [NSThread sleepForTimeInterval:1];</span><br><span class="line">                NSLog(@&quot;子任务3 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;);</span><br><span class="line">        // 信号量 等待 最多等待15秒</span><br><span class="line">        dispatch_semaphore_wait(semaphore,dispatch_time(DISPATCH_TIME_NOW, (int64_t)(15 * NSEC_PER_SEC)));</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:1];</span><br><span class="line">            NSLog(@&quot;i %ld dispatch_barrier_async 任务&quot;,i);</span><br><span class="line">        &#125;</span><br><span class="line">        [NSThread sleepForTimeInterval:5];</span><br><span class="line">    &#125;);</span><br><span class="line">    // 任务3</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:1];</span><br><span class="line">            NSLog(@&quot;任务3 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 任务4</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (NSInteger i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:1];</span><br><span class="line">            NSLog(@&quot;任务4 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印:</span><br><span class="line"></span><br><span class="line">1 current thread -&lt;NSThread: 0x600001327680&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">任务2 current thread -&lt;NSThread: 0x60000136ec80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3 current thread -&lt;NSThread: 0x6000013b1b80&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">子任务1 - &lt;NSThread: 0x6000013b1b80&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">任务1 - &lt;NSThread: 0x60000134f500&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">子任务1 - &lt;NSThread: 0x6000013b1b80&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">任务1 - &lt;NSThread: 0x60000134f500&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">子任务2 - &lt;NSThread: 0x6000013b1b80&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">子任务2 - &lt;NSThread: 0x6000013b1b80&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">子任务3 - &lt;NSThread: 0x6000013b1b80&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">子任务3 - &lt;NSThread: 0x6000013b1b80&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">i 0 dispatch_barrier_async 任务</span><br><span class="line">i 1 dispatch_barrier_async 任务</span><br><span class="line">任务3 - &lt;NSThread: 0x60000136ec80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">任务4 - &lt;NSThread: 0x6000013819c0&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">任务4 - &lt;NSThread: 0x6000013819c0&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">任务3 - &lt;NSThread: 0x60000136ec80&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>结论：<br>&emsp;输出结果符合预期。因为:在任务2 开始执行的时候生成一个信号量，信号量为0 dispatch_semaphore_wait 会一直阻塞任务2线程，直到超出等待时间。直到任务2 的子任务执行完之后才dispatch_semaphore_signal 使信号量加一 这样dispatch_semaphore_wait 取消阻塞任务2线程</p><h3 id="Dispatch-Semaphore-信号量"><a href="#Dispatch-Semaphore-信号量" class="headerlink" title="Dispatch Semaphore 信号量"></a>Dispatch Semaphore 信号量</h3><p>&emsp;GCD 中的信号量是指 Dispatch Semaphore，是持有计数的信号。类似于过高速路收费站的栏杆。可以通过时，打开栏杆，不可以通过时，关闭栏杆。在 Dispatch Semaphore 中，使用计数来完成这个功能，计数为0时等待，不可通过。计数为1或大于1时，计数减1且不等待，可通过。<br>Dispatch Semaphore 提供了三个函数。</p><ol><li>dispatch_semaphore_create：创建一个Semaphore并初始化信号的总量</li><li>dispatch_semaphore_signal：发送一个信号，让信号总量加1</li><li>dispatch_semaphore_wait：可以使总信号量减1，当信号总量为0时就会一直等待（阻塞所在线程），否则就可以正常执行。</li></ol><blockquote><p>注意：信号量的使用前提是：想清楚你需要处理哪个线程等待（阻塞），又要哪个线程继续执行，然后使用信号量</p></blockquote><blockquote><p>Dispatch Semaphore 在实际开发中主要用于：</p></blockquote><ol><li>保持线程同步，将异步执行任务转换为同步执行任务</li><li>保证线程安全，为线程加锁</li></ol><p>在此主要说下线程同步。</p><p>&emsp; 有一个全局的变量 number 要求在其他线程异步执行完赋值操作之后再输出，输出的值是在其他线程所赋的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)synchronization &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;semaphore---begin&quot;);</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">    </span><br><span class="line">    __block int number = 0;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">        number = 100;</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    NSLog(@&quot;semaphore---end,number = %d&quot;,number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印:</span><br><span class="line"></span><br><span class="line">currentThread---&lt;NSThread: 0x600000d9a800&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">semaphore---begin</span><br><span class="line">1---&lt;NSThread: 0x600000d17f40&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">semaphore---end,number = 100</span><br></pre></td></tr></table></figure><p>结论: 在其他线程异步赋值的number 输出的值正确，如果没有用dispatch_semaphore 那么输出的值是 number的初始化的值 0. 这里dispatch_semaphore 的目的是让执行synchronization 方法的main 线程和执行为number赋值的子线程 保持同步。</p><h3 id="线程同步总结"><a href="#线程同步总结" class="headerlink" title="线程同步总结"></a>线程同步总结</h3><h4 id="线程同步-Dispatch-Group-中dispatch-group-enter-和-dispatch-group-leave-以及dispatch-group-async-比较"><a href="#线程同步-Dispatch-Group-中dispatch-group-enter-和-dispatch-group-leave-以及dispatch-group-async-比较" class="headerlink" title="线程同步 Dispatch Group  中dispatch_group_enter 和 dispatch_group_leave 以及dispatch_group_async  比较"></a>线程同步 Dispatch Group  中dispatch_group_enter 和 dispatch_group_leave 以及dispatch_group_async  比较</h4><blockquote><p>Dispatch Group 中有 dispatch_group_enter 和 dispatch_group_leave 以及dispatch_group_async<br>。dispatch_group_async<br>使用比较方便，但是不够灵活，稍微复杂一点的需求处理不是太容易。<br>dispatch_group_enter 和 dispatch_group_leave<br>使用没有dispatch_group_async<br>简单，但是比较灵活，如上面解决复杂的同步问题。</p></blockquote><h4 id="dispatch-semaphore-和-dispatch-group"><a href="#dispatch-semaphore-和-dispatch-group" class="headerlink" title="dispatch_semaphore 和 dispatch group"></a>dispatch_semaphore 和 dispatch group</h4><blockquote><p>dispatch_semaphore 使用灵活，但是处理比较复杂的常见不太方便。最适合的是dispatch_semaphore 和 dispatch group  配合使用，才能灵活处理复杂场景。</p></blockquote><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>&emsp; 线程同步，需要根据不同的场景选择不同的技术，同时也要注意使用过程中的问题。</p><h3 id="附Demo"><a href="#附Demo" class="headerlink" title="附Demo"></a>附Demo</h3><p><a href="https://github.com/JiWuChao/OCKeyPoint/tree/master/Multithreading/GCD" target="_blank" rel="noopener">相关Demo这里点击</a> <a href="https://github.com/JiWuChao/OCKeyPoint/tree/master/Multithreading/GCD" target="_blank" rel="noopener">https://github.com/JiWuChao/OCKeyPoint/tree/master/Multithreading/GCD</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在日常开发中，需要当几个任务执行完之后再执行最后一个任务。一下就列举几个线程同步的常用方法，并指出其中的问题，以及提出解决方按。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Dispatch-Group-调度组&quot;&gt;&lt;a href=&quot;#Dis
      
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.wuchao.net.cn/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构笔记—两个有序链表合并成一个有序链表</title>
    <link href="http://www.wuchao.net.cn/2018/08/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%E2%80%94%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6%E6%88%90%E4%B8%80%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.wuchao.net.cn/2018/08/15/数据结构笔记—两个有序链表合并成一个有序链表/</id>
    <published>2018-08-15T06:43:06.000Z</published>
    <updated>2018-09-29T07:50:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现要求"><a href="#实现要求" class="headerlink" title="实现要求"></a>实现要求</h3><blockquote><p>两个升序的单链表，合并成一个升序的单链表</p></blockquote><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>&emsp; 在网上看了很多其他语言实现的这个题目，不是太懂(<del>主要是不太懂其他语言的语法</del>)，<strong>总体而言就是把一个链表按照一定的规则插入到另一个链表中</strong>。现在用Swift实现一遍。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;主要目的是找到一个插入位置</p><ol><li>从链表的第一个结点开始，把插入的值和当前的结点做比较</li><li>如果插入的值大于当前的结点值 则继续寻找一个比它大的值，如此循环直到找到一个比它的值大的结点</li><li>找到之后把插入的值放到上一步找到的结点前面</li></ol><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h5 id="定义一个结点"><a href="#定义一个结点" class="headerlink" title="定义一个结点"></a>定义一个结点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SLNode&lt;Int&gt; &#123;</span><br><span class="line">    var value: Int</span><br><span class="line">    var next :SLNode?// 下一个结点</span><br><span class="line">    public init(value:Int) &#123;</span><br><span class="line">        self.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定义一个链表"><a href="#定义一个链表" class="headerlink" title="定义一个链表"></a>定义一个链表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public final class SingleLinkList &#123;</span><br><span class="line">    </span><br><span class="line">    public typealias Node = SLNode&lt;Int&gt;</span><br><span class="line">    </span><br><span class="line">    fileprivate var head:Node? // 头指针 指向首元结点</span><br><span class="line">    </span><br><span class="line">    public init() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    //1 是否为空</span><br><span class="line">    func isEmpty() -&gt; Bool &#123;</span><br><span class="line">        return head == nil</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //2 获取首元结点</span><br><span class="line">    public var first:Node?&#123;</span><br><span class="line">        return head</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //3 获取尾结点</span><br><span class="line">    public var last:Node? &#123;</span><br><span class="line">        if var node = head &#123;</span><br><span class="line">            while case let next? = node.next &#123;</span><br><span class="line">                node = next</span><br><span class="line">            &#125;</span><br><span class="line">            return node</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //4 链表的长度</span><br><span class="line">    public var count:Int &#123;</span><br><span class="line">        if var node = head &#123;</span><br><span class="line">            var c = 1</span><br><span class="line">            while case let next? = node.next &#123;</span><br><span class="line">                node = next</span><br><span class="line">                c += 1</span><br><span class="line">            &#125;</span><br><span class="line">            return c</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 5 结点的获取</span><br><span class="line">    </span><br><span class="line">    func getNode(atIndex index:Int) -&gt; Node? &#123;</span><br><span class="line">        if index &gt;= 0 &#123;</span><br><span class="line">            var node = head</span><br><span class="line">            var i = index</span><br><span class="line">            while node != nil &#123;</span><br><span class="line">                if i == 0 &#123;</span><br><span class="line">                    return node</span><br><span class="line">                &#125;</span><br><span class="line">                i -= 1</span><br><span class="line">                node = node?.next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 链表的添加 按照顺序添加</span><br><span class="line">    </span><br><span class="line">    public func append(_ value: Int) &#123;</span><br><span class="line">        let newNode = SLNode(value: value)</span><br><span class="line">        if let lastNode = last &#123;</span><br><span class="line">            lastNode.next = newNode</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            head = newNode</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/// 链表合并</span><br><span class="line">    ///</span><br><span class="line">    /// - Parameter list: &lt;#list description#&gt;</span><br><span class="line">    func merge(list: SingleLinkList) &#123;</span><br><span class="line">        var listNode = list.head //从一个结点开始</span><br><span class="line">        while listNode != nil &#123;</span><br><span class="line">            self.insert(value: listNode!.value)</span><br><span class="line">            listNode = listNode!.next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     // 插入一个值 不指定位置 按 升序插入</span><br><span class="line">    func insert(value: Int) &#123;</span><br><span class="line">        if self.head == nil &#123; // 如果链表为空</span><br><span class="line">            self.head = Node.init(value: value)</span><br><span class="line">        &#125; else &#123;// 如果链表不为空 则从首元结点开始查找插入位置</span><br><span class="line">            self.insert(node: &amp;self.head!, value: value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">        思路：找到第一个比插入的值大的结点</span><br><span class="line">        1 插入的值和当前结点的值做比较</span><br><span class="line">        2 如果value 大于当前的结点值 则继续寻找一个比它大的值</span><br><span class="line">        3 找到之后把插入的值放到比它大的值前面</span><br><span class="line">        时间复杂度：O(n)</span><br><span class="line">     */</span><br><span class="line">    // inout 内部可以改变外面传的参数值</span><br><span class="line">    func insert(node: inout Node, value: Int) &#123;</span><br><span class="line">        if value &gt; node.value &#123;</span><br><span class="line">            if node.next == nil &#123;</span><br><span class="line">                node.next = Node.init(value: value)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                self.insert(node: &amp;node.next!, value: value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            let newNode = Node.init(value: value)</span><br><span class="line">            newNode.next = node // 头插法建立链表</span><br><span class="line">            node = newNode</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var link = SingleLinkList.init()</span><br><span class="line">    link.append([1,3,5,6,8,10])</span><br><span class="line">    print(link)</span><br><span class="line">    </span><br><span class="line">    //结果：[1, 3, 5, 6, 8, 10]</span><br><span class="line">    </span><br><span class="line">    var linkTow = SingleLinkList.init()</span><br><span class="line">    linkTow.append([0,2,4,7,9,11])</span><br><span class="line">    link.merge(list: linkTow)</span><br><span class="line">    print(link)</span><br><span class="line">    //结果：[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</span><br></pre></td></tr></table></figure><p><a href="https://github.com/JiWuChao/DataStructure/tree/master" target="_blank" rel="noopener">更多详细代码</a></p><p>转载请注明出处，<a href="https://juejin.im/post/5b4d90b56fb9a04fdb16b014" target="_blank" rel="noopener">https://juejin.im/post/5b4d90b56fb9a04fdb16b014</a> 谢谢。如果解决了您的问题请点赞支持下，如果有什么错误之处还请批评指出。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;实现要求&quot;&gt;&lt;a href=&quot;#实现要求&quot; class=&quot;headerlink&quot; title=&quot;实现要求&quot;&gt;&lt;/a&gt;实现要求&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;两个升序的单链表，合并成一个升序的单链表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;思路
      
    
    </summary>
    
      <category term="算法" scheme="http://www.wuchao.net.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.wuchao.net.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构笔记--线性表</title>
    <link href="http://www.wuchao.net.cn/2018/08/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://www.wuchao.net.cn/2018/08/14/数据结构笔记-线性表/</id>
    <published>2018-08-14T06:41:05.000Z</published>
    <updated>2018-09-29T07:50:37.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a><em>写在前面的话</em></h4><blockquote><p><em>做了几年的开发,越来越感觉到计算机基础知识的重要性,虽然在开发中可能直接使用计算机基础知识的地方不是太明显。当深入了解某个框架或者某个知识的原理时,需要一些基础知识,然而随着时间的推移基础知识长时间没看而逐渐遗忘或者不清晰，那时感觉力不从心，因此决定,复习一下基础知识做个总结</em></p></blockquote><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>&emsp; 线性表是最常用且最简单的一种数据结构,简言之,一个线性表是 n 个数据元素的有序序列.</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>只有一个首结点和尾结点；</li><li>除首尾结点外，其他结点只有一个直接前驱和一个直接后继。</li></ol><p>&emsp; 简言之，线性结构反映结点间的逻辑关系是 一对一的,<br>线性结构包括线性表、堆栈、队列、字符串、数组等等，其中，最典型、最常用的</p><h2 id="线性表的划分"><a href="#线性表的划分" class="headerlink" title="线性表的划分"></a>线性表的划分</h2><p>&emsp;从存储结构上来划分,可分为顺序存储结构称<strong>顺序表</strong>和链式存储结构称<strong>链表</strong></p><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><h4 id="顺序表的存储定义"><a href="#顺序表的存储定义" class="headerlink" title="顺序表的存储定义"></a>顺序表的存储定义</h4><p>&emsp;把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。简单来说，逻辑上相邻，物理上也相邻</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/14/16497400e74ae98d?w=1660&amp;h=1284&amp;f=png&amp;s=156951" alt="顺序存储结构"></p><h4 id="顺序表的特点"><a href="#顺序表的特点" class="headerlink" title="顺序表的特点:"></a>顺序表的特点:</h4><blockquote><ol><li>利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即线性表的逻辑结构与存储结构一致</li><li>在访问线性表时，可以快速地计算出任何一个数据元素的存储地址。因此可以粗略地认为，访问每个元素所花时间相等　</li></ol></blockquote><h4 id="顺序表的复杂度"><a href="#顺序表的复杂度" class="headerlink" title="顺序表的复杂度:"></a>顺序表的复杂度:</h4><p><strong>时间复杂度:</strong> 顺序表的查找、插入、删除算法的平均时间复杂度为O(n)</p><p><strong>空间复杂度:</strong> 顺序表的时间复杂度为O(1)</p><h4 id="顺序表的优缺点"><a href="#顺序表的优缺点" class="headerlink" title="顺序表的优缺点:"></a>顺序表的优缺点:</h4><p><strong>优点：</strong><br>存储密度大（结点本身所占存储量/结点结构所占存储量）<br>可以随机存取表中任一元素</p><p><strong>缺点：</strong><br>在插入、删除某一元素时，需要移动大量元素<br>浪费存储空间<br>属于静态存储形式，数据元素的个数不能自由扩充</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="链表的特点"><a href="#链表的特点" class="headerlink" title="链表的特点"></a>链表的特点</h4><blockquote><p>结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻线性表的链式表示又称为非顺序映像或链式映像。</p></blockquote><h4 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h4><p>&emsp; 数据元素的存储映像。由数据域和指针域两部分组成.<br><strong>数据域</strong>:存储元素数值数据.<strong>指针域</strong>：存储直接后继结点的存储位置<br>数据域 | 指针域<br>—|—</p><blockquote><p>注意: ==头指针,头结点,首元结点==这几个概念:</p><ul><li>头指针: 是指向链表中第一个结点的指针</li><li>首元结点:是指链表中存储第一个数据元素a1的结点</li><li>头结点:是在链表的首元结点之前附设的一个结点；数据域内只放空表标志和表长等信息。其作用主要是为了链表的操作方便</li></ul></blockquote><blockquote><p>头结点可以有也可以没有，但是头指针必须要有。</p></blockquote><h3 id="链表的形式："><a href="#链表的形式：" class="headerlink" title="链表的形式："></a>链表的形式：</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><blockquote><p>结点只有一个指针域的链表。每个结点中除了包含数据域以外还包含一个指针域，用于指向其后继结点。</p></blockquote><table><thead><tr><th>数据域</th><th>指针域</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>单链表的存储映像</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/15/1649bedd617bb890?w=1992&amp;h=994&amp;f=png&amp;s=162201" alt=""></p><ul><li>带头结点的单链表：头指针指向其头结点，头结点的值域可以不含任何信息，从头结点的后继结点开始存储信息</li><li>不带头结点的单链表:头指针指向其首元结点</li></ul><h4 id="单链表的实现"><a href="#单链表的实现" class="headerlink" title="单链表的实现"></a>单链表的实现</h4><h5 id="单链表是否为空"><a href="#单链表是否为空" class="headerlink" title="单链表是否为空"></a>单链表是否为空</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func isEmpty() -&gt; Bool &#123;</span><br><span class="line">        return head == nil</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="获取首元结点"><a href="#获取首元结点" class="headerlink" title="获取首元结点"></a>获取首元结点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public var first:Node?&#123;</span><br><span class="line">        return head</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="获取尾结点"><a href="#获取尾结点" class="headerlink" title="获取尾结点"></a>获取尾结点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public var last:Node? &#123;</span><br><span class="line">        if var node = head &#123;</span><br><span class="line">            while case let next? = node.next &#123;</span><br><span class="line">                node = next</span><br><span class="line">            &#125;</span><br><span class="line">            return node</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="链表的长度"><a href="#链表的长度" class="headerlink" title="链表的长度"></a>链表的长度</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public var count:Int &#123;</span><br><span class="line">        if var node = head &#123;</span><br><span class="line">            var c = 1</span><br><span class="line">            while case let next? = node.next &#123;</span><br><span class="line">                node = next</span><br><span class="line">                c += 1</span><br><span class="line">            &#125;</span><br><span class="line">            return c</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="结点的获取"><a href="#结点的获取" class="headerlink" title="结点的获取"></a>结点的获取</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func getNode(atIndex index:Int) -&gt; Node? &#123;</span><br><span class="line">        if index &gt;= 0 &#123;</span><br><span class="line">         var node = head</span><br><span class="line">            var i = index</span><br><span class="line">            while node != nil &#123;</span><br><span class="line">                if i == 0 &#123;</span><br><span class="line">                    return node</span><br><span class="line">                &#125;</span><br><span class="line">                i -= 1</span><br><span class="line">                node = node?.next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="链表的添加"><a href="#链表的添加" class="headerlink" title="链表的添加"></a>链表的添加</h5><p><img src="https://user-gold-cdn.xitu.io/2018/7/15/1649c680d3e7bb8a?w=1882&amp;h=796&amp;f=png&amp;s=178831" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public func append(_ value: T) &#123;</span><br><span class="line">        let newNode = SLNode(value: value)</span><br><span class="line">        if let lastNode = last &#123;</span><br><span class="line">            lastNode.next = newNode</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            head = newNode</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 批量添加</span><br><span class="line">    public func append(_ values:Array&lt;T&gt;) &#123;</span><br><span class="line">        for value in values &#123;</span><br><span class="line">            append(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="链表的插入-插入在第-index-结点"><a href="#链表的插入-插入在第-index-结点" class="headerlink" title="链表的插入 插入在第 index 结点"></a>链表的插入 插入在第 index 结点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public func insertNode(atIndex index:Int,value:T) &#123;</span><br><span class="line">        let oldNode = getBeforeNode(atIndex: index)</span><br><span class="line">        var newNode = SLNode(value: value)</span><br><span class="line">        if index &gt; 0 &#123;</span><br><span class="line">            if let old = oldNode &#123;</span><br><span class="line">                newNode.next = old.next</span><br><span class="line">                old.next = newNode</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                append(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            append(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="单链表删除"><a href="#单链表删除" class="headerlink" title="单链表删除"></a>单链表删除</h5><p> <img src="https://user-gold-cdn.xitu.io/2018/7/15/1649c683e2f35bdd?w=1782&amp;h=900&amp;f=png&amp;s=121587" alt="删除示意图"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    删除在某一个 位置的结点</span><br><span class="line">public func removeNode(atIndex index:Int) &#123;</span><br><span class="line">        let beforeNode = getBeforeNode(atIndex: index)</span><br><span class="line">        if let before = beforeNode &#123;</span><br><span class="line">            before.next = before.next?.next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 删除所有结点</span><br><span class="line">    public func removeAll() &#123;</span><br><span class="line">        head = nil</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>&emsp;有两个指针域的链表。双链表就是在单链表上增加一个指针域,指向当前结点的前驱.用于方便地找到其前驱结点.和单链表类似也分为带头结点的双链表和不带头结点的双链表.</p><table><thead><tr><th>指针域</th><th>数据域</th><th>指针域</th></tr></thead><tbody><tr><td></td></tr></tbody></table><h4 id="双向链表的实现"><a href="#双向链表的实现" class="headerlink" title="双向链表的实现"></a>双向链表的实现</h4><h4 id="定义一个双向链表的结点"><a href="#定义一个双向链表的结点" class="headerlink" title="定义一个双向链表的结点"></a>定义一个双向链表的结点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//定义一个 结点 双向链表的结点定义格式</span><br><span class="line">public class DLNode&lt;T&gt; &#123;</span><br><span class="line">    var value: T</span><br><span class="line">    var next :DLNode?// 下一个结点</span><br><span class="line">    weak var previous :DLNode?//前一个结点</span><br><span class="line">    public init(value:T) &#123;</span><br><span class="line">        self.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义一个双向链表"><a href="#定义一个双向链表" class="headerlink" title="定义一个双向链表"></a>定义一个双向链表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class DoubleLinkList&lt;T&gt; &#123;</span><br><span class="line">    //为了操作方便 将DLNode&lt;T&gt; 重新命名为 Node</span><br><span class="line">    public typealias Node = DLNode&lt;T&gt;</span><br><span class="line">   //头指针</span><br><span class="line">    fileprivate var head:Node?</span><br><span class="line">        public init() &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="双向链表是否为空"><a href="#双向链表是否为空" class="headerlink" title="双向链表是否为空"></a>双向链表是否为空</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public var isEmpty:Bool &#123;</span><br><span class="line">    return head == nil //首元结点是否为空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双向链表获取首元结点"><a href="#双向链表获取首元结点" class="headerlink" title="双向链表获取首元结点"></a>双向链表获取首元结点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public var first:Node?&#123;</span><br><span class="line">    return head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双向链表获取尾结点"><a href="#双向链表获取尾结点" class="headerlink" title="双向链表获取尾结点"></a>双向链表获取尾结点</h4><p>&emsp; 尾结点的next 指针指向的结点必定为空。所以从首结点开始遍历，如果 next 为空比为尾结点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public var last:Node? &#123;</span><br><span class="line">    if var node = head &#123;</span><br><span class="line">        while case let next? = node.next &#123;</span><br><span class="line">            node = next</span><br><span class="line">        &#125;</span><br><span class="line">        return node</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双向链表的长度"><a href="#双向链表的长度" class="headerlink" title="双向链表的长度"></a>双向链表的长度</h4><p>&emsp;从首元结点开始遍历，一直遍历到尾结点，直到遍历完成，每有一个结点长度加一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public var count:Int &#123;</span><br><span class="line">    if var node = head &#123;</span><br><span class="line">        var c = 1</span><br><span class="line">        while case let next? = node.next &#123;</span><br><span class="line">            node = next</span><br><span class="line">            c += 1</span><br><span class="line">        &#125;</span><br><span class="line">        return c</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双向链表的查找："><a href="#双向链表的查找：" class="headerlink" title="双向链表的查找："></a>双向链表的查找：</h4><p>&emsp; 从首元结点开始相后查找 复杂度为 O(n)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public func node(atIndex index: Int) -&gt; Node? &#123;</span><br><span class="line">      if index &gt;= 0 &#123;</span><br><span class="line">          var node = head</span><br><span class="line">          var i = index</span><br><span class="line">          while node != nil &#123;//从首元结点开始向后查找</span><br><span class="line">              if i == 0 &#123;</span><br><span class="line">                  return node</span><br><span class="line">              &#125;</span><br><span class="line">              i -= 1</span><br><span class="line">              node = node!.next</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return nil</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="双向链表的插入"><a href="#双向链表的插入" class="headerlink" title="双向链表的插入"></a>双向链表的插入</h4><p>&emsp;在某个位置插入一个结点。双向链表的插入步骤；</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/14/1649955ba305b27d?w=1856&amp;h=1064&amp;f=png&amp;s=141343" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public func insert(_ node: Node, atIndex index: Int) &#123;</span><br><span class="line">    let oldNode = getNode(atIndex: index)</span><br><span class="line">    let newNode = DLNode(value: node.value)</span><br><span class="line">    newNode.previous = oldNode?.previous</span><br><span class="line">    oldNode?.previous?.next = newNode</span><br><span class="line">    newNode.next = oldNode</span><br><span class="line">    oldNode?.previous = newNode</span><br><span class="line">    if oldNode?.previous == nil &#123;</span><br><span class="line">        head = newNode</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="双向链表的删除"><a href="#双向链表的删除" class="headerlink" title="双向链表的删除"></a>双向链表的删除</h4><p>&emsp;删除链表中某一个结点，步骤如下</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/14/164995caa25cdb98?w=1354&amp;h=762&amp;f=png&amp;s=75054" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult public func remove(atIndex index: Int) -&gt; T &#123;</span><br><span class="line">        let node = self.getNode(atIndex: index)</span><br><span class="line">        assert(node != nil)</span><br><span class="line">        return remove(node: node!)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">@discardableResult public func remove(node: Node) -&gt; T &#123;</span><br><span class="line">        let prev = node.previous</span><br><span class="line">        let next = node.next</span><br><span class="line">        </span><br><span class="line">        if let prev = prev &#123;</span><br><span class="line">            prev.next = next</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            head = next</span><br><span class="line">        &#125;</span><br><span class="line">        next?.previous = prev</span><br><span class="line">        </span><br><span class="line">        node.previous = nil</span><br><span class="line">        node.next = nil</span><br><span class="line">        return node.value</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="双向链表翻转"><a href="#双向链表翻转" class="headerlink" title="双向链表翻转"></a>双向链表翻转</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public func reverse() &#123;</span><br><span class="line">        var node = head</span><br><span class="line">        while let currentNode = node &#123;</span><br><span class="line">            node = currentNode.next // 把下一个赋值给node</span><br><span class="line">            swap(&amp;currentNode.next, &amp;currentNode.previous) // 交换</span><br><span class="line">            head = currentNode</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox" checked> 以上为双向链表的操作，单链表和单循环链表以及双向循环链表的操作实现可以参照双向链表的操作。</li></ul><h3 id="链表的运算效率分析"><a href="#链表的运算效率分析" class="headerlink" title="链表的运算效率分析"></a>链表的运算效率分析</h3><ol><li><p>查找:  因线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为 O(n)。</p></li><li><p>插入和删除:  因线性链表不需要移动元素，只要修改指针，一般情况下时间复杂度为 O(1)。</p></li></ol><p>但是，如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为 O(n) 。</p><h4 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h4><p>&emsp;单链表的最后一个指针域指向链表中的第一个结点即可。循环单链表可以以实现从任何一个结点出发访问链表中的任何结点。</p><ul><li style="list-style: none"><input type="checkbox" checked> 注意: 这里说第一个结点而不是说首元结点是因为,如果循环单链表是带头结点的,则最后一个结点的指针域要指向头结点,如果循环单链表的不带头节点,则最后一个指针域要指向首元结点</li></ul><h4 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h4><p>&emsp;首尾相接的链表，源自于双链表。即将终端结点的后继结点设为第一个结点（首元结点或者头结点）将链表中的第一个结点的前继结点设为终端结点。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/14/1649741aa870a1ce?w=2104&amp;h=360&amp;f=png&amp;s=51071" alt=""></p><h3 id="链表的优缺点"><a href="#链表的优缺点" class="headerlink" title="链表的优缺点"></a>链表的优缺点</h3><ul><li>优点</li></ul><ol><li>数据元素的个数可以自由扩充</li><li>插入、删除等操作不必移动数据，只需修改链接指针，修改效率较高</li></ol><ul><li>缺点：</li></ul><ol><li>存储密度小</li><li>存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问（顺藤摸瓜）</li></ol><h2 id="顺序表和链表的比较："><a href="#顺序表和链表的比较：" class="headerlink" title="顺序表和链表的比较："></a>顺序表和链表的比较：</h2><h4 id="基于空间的比较"><a href="#基于空间的比较" class="headerlink" title="基于空间的比较"></a>基于空间的比较</h4><ol><li>存储分配方式：顺序表的存储空间是静态分配的，链表的存储空间是动态分配的</li><li>存储密度：（存储密度= 结点值域所占的存储量/结点结构所占的存储总量），顺序表的存储密度 = 1 链表的存储密度 &lt; 1 (因为结点中存储的有指针域)</li></ol><h4 id="基于时间的比较："><a href="#基于时间的比较：" class="headerlink" title="基于时间的比较："></a>基于时间的比较：</h4><ol><li>存取方式：顺序表可以随机存取，也可以顺序存取，链表是顺序存取</li><li>插入删除时移动的元素的个数：顺序表平均需要移动近一半的元素，链表不需要移动，只需要修改指针</li></ol><p><a href="https://github.com/JiWuChao/DataStructure" target="_blank" rel="noopener">更多详细代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;&lt;em&gt;写在前面的话&lt;/em&gt;&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;做了几年的开发,越来越感觉到计算机基础知识的重要性,虽然
      
    
    </summary>
    
      <category term="数据结构" scheme="http://www.wuchao.net.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.wuchao.net.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构笔记—栈和队列</title>
    <link href="http://www.wuchao.net.cn/2018/08/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://www.wuchao.net.cn/2018/08/13/数据结构笔记—栈和队列/</id>
    <published>2018-08-13T06:46:36.000Z</published>
    <updated>2018-09-29T07:50:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>只能在表的一端（栈顶）进行插入和删除运算的线性表</p></blockquote><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><blockquote><p>与线性表相同，仍为一对一关系</p></blockquote><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><blockquote><p>用顺序栈或链栈存储均可，但以顺序栈更常见</p></blockquote><h3 id="运算规则"><a href="#运算规则" class="headerlink" title="运算规则"></a>运算规则</h3><blockquote><p>只能在栈顶运算，且访问结点时依照后进先出（LIFO）或先进后出（FILO）的原则</p></blockquote><h3 id="栈与一般线性表的区别"><a href="#栈与一般线性表的区别" class="headerlink" title="栈与一般线性表的区别"></a>栈与一般线性表的区别</h3><table><thead><tr><th>比较维度</th><th>一般线性表</th><th>栈</th></tr></thead><tbody><tr><td>逻辑结构</td><td>一对一</td><td>一对一</td></tr><tr><td>存储结构</td><td>顺序表、链表</td><td>顺序表、链表</td></tr><tr><td>运算规则</td><td>随机、顺序存取</td><td>==后进先出==</td></tr></tbody></table><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><blockquote><p>关键是编写入栈和出栈函数，具体实现依顺序栈或链栈的不同而不同<br>基本操作有入栈、出栈、读栈顶元素值、建栈、判断栈满、栈空等</p></blockquote><h4 id="定义一个栈"><a href="#定义一个栈" class="headerlink" title="定义一个栈"></a>定义一个栈</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public struct Stack&lt;T&gt; &#123;</span><br><span class="line">    fileprivate var stackData = [T]()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//struct 的实例方法中默认不能修改属性值 如果要修改 需要加上 mutating 关键字</span><br><span class="line">    // push</span><br><span class="line">    public mutating func push(_ element: T) &#123;</span><br><span class="line">        stackData.append(element)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public mutating func pop() -&gt; T? &#123;</span><br><span class="line">        return stackData.popLast()// popLast() 删除并返回数组中的最后一个值</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="栈顶元素"><a href="#栈顶元素" class="headerlink" title="栈顶元素"></a>栈顶元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//栈顶</span><br><span class="line">    public var top: T? &#123;</span><br><span class="line">        return stackData.last //数组的最后一个值 及栈顶</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="栈判空"><a href="#栈判空" class="headerlink" title="栈判空"></a>栈判空</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public var isEmpty: Bool &#123;</span><br><span class="line">    return stackData.isEmpty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈的应用举例：十进制转八进制"><a href="#栈的应用举例：十进制转八进制" class="headerlink" title="栈的应用举例：十进制转八进制"></a>栈的应用举例：十进制转八进制</h4><blockquote><p>对于任意一个非负整数，打印出与其相等的对应八进制</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public mutating func tenTransformEight(value:Int) &#123;</span><br><span class="line">        var val = value</span><br><span class="line">        while val &gt; 0 &#123;</span><br><span class="line">            push(val % 8)</span><br><span class="line">            val = val / 8</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var stack = Stack.init()</span><br><span class="line"></span><br><span class="line">    stack.tenTransformEight(value: 1348)</span><br><span class="line"></span><br><span class="line">    print(stack.popAll() ?? &quot;&quot;)</span><br><span class="line">    </span><br><span class="line">    //输出结果：2504</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote><p>　队列是一种先进先出(FIFO) 的线性表. 它只允许在表的一端进行插入,而在另一端删除元素</p></blockquote><h2 id="未完待续。。。。"><a href="#未完待续。。。。" class="headerlink" title="未完待续。。。。"></a><em>未完待续。。。。</em></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;blockquot
      
    
    </summary>
    
      <category term="数据结构" scheme="http://www.wuchao.net.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.wuchao.net.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构笔记—图</title>
    <link href="http://www.wuchao.net.cn/2018/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%E2%80%94%E5%9B%BE/"/>
    <id>http://www.wuchao.net.cn/2018/08/12/数据结构笔记—图/</id>
    <published>2018-08-12T06:47:57.000Z</published>
    <updated>2018-09-29T07:50:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的定义和基本术语"><a href="#图的定义和基本术语" class="headerlink" title="图的定义和基本术语"></a>图的定义和基本术语</h2><h3 id="图的知识图谱"><a href="#图的知识图谱" class="headerlink" title="图的知识图谱"></a>图的知识图谱</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/26/164d72d46a3e4705?w=1304&amp;h=686&amp;f=png&amp;s=144994" alt=""></p><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><p>&emsp;Graph=(V,E)<br>  V：顶点(数据元素)的有穷非空集合,和 E：边的有穷集合组成</p><p><strong>有向图</strong>：每条边都是有方向的</p><p><strong>无向图</strong>： 每条边都是无方向的</p><p><strong>完全图</strong>：任意两个点都有一条边相连</p><p><strong>稀疏图</strong>：有很少边或弧的图。</p><p><strong>稠密图</strong>：有较多边或弧的图。</p><p><strong>网</strong>：边/弧带权的图。</p><p><strong>邻接</strong>：有边/弧相连的两个顶点之间的关系。<br>            存在(vi, vj)，则称vi和vj互为邻接点；<br>              存在&lt;vi, vj&gt;，则称vi邻接到vj， vj邻接于vi </p><p><strong>关联(依附)</strong>：边/弧与顶点之间的关系。<br>            存在(vi, vj)/ &lt;vi, vj&gt;， 则称该边/弧关联于vi和vj</p><p><strong>顶点的度</strong>：与该顶点相关联的边的数目，记为TD(v)。在有向图中, 顶点的度等于该顶点的入度与出度之和。<br>顶点 v 的入度是以 v 为终点的有向边的条数, 记作 ID(v)<br>顶点 v 的出度是以 v 为始点的有向边的条数, 记作OD(v)</p><p><strong>路径</strong>：接续的边构成的顶点序列。</p><p><strong>路径长度</strong>：路径上边或弧的数目/权值之和。</p><p><strong>回路(环)</strong>：第一个顶点和最后一个顶点相同的路径。<br>1<br><strong>简单路径</strong>：顶点不重复出现的路径。</p><p><strong>简单回路(简单环)</strong>：除路径起点和终点相同外，其余顶点均不相同的路径。</p><p><strong>连通图（强连通图）</strong> 在无（有）向图G=( V, {E} )中，若对任何两个顶点 v、u 都存在从v 到 u 的路径，则称G是连通图（强连通图）。</p><p><strong>权与网</strong> 图中边或弧所具有的相关数称为权。表明从一个顶点到另一个顶点的距离或耗费。带权的图称为网。</p><p><strong>子图</strong> 设有两个图G=（V，{E}）、G1=（V1，{E1}），若V1包含于 V，E1 包含于 E，则称 G1是G的子图。</p><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="顺序存储结构："><a href="#顺序存储结构：" class="headerlink" title="顺序存储结构："></a>顺序存储结构：</h3><p>&emsp;数组表示法（邻接矩阵）</p><h4 id="邻接矩阵表示法的特点"><a href="#邻接矩阵表示法的特点" class="headerlink" title="邻接矩阵表示法的特点"></a>邻接矩阵表示法的特点</h4><p><strong>优点</strong>：容易实现图的操作，如：求某顶点的度、判断顶点之间是否有边、找顶点的邻接点等等。</p><p><strong>缺点</strong>：n个顶点需要n*n个单元存储边;空间效率为O(n2)。 对稀疏图而言尤其浪费空间。</p><h3 id="链式存储结构："><a href="#链式存储结构：" class="headerlink" title="链式存储结构："></a>链式存储结构：</h3><h4 id="邻接表表示法的特点"><a href="#邻接表表示法的特点" class="headerlink" title="邻接表表示法的特点"></a>邻接表表示法的特点</h4><p><strong>优点</strong>：空间效率高，容易寻找顶点的邻接点；</p><p><strong>缺点</strong>：判断两顶点间是否有边或弧，需搜索两结点对应的单链表，没有邻接矩阵方便。</p><p>多重链表</p><ol><li><p>邻接表:</p></li><li><p>邻接多重表:</p></li><li>十字链表:</li></ol><h3 id="邻接矩阵与邻接表表示法的关系"><a href="#邻接矩阵与邻接表表示法的关系" class="headerlink" title="邻接矩阵与邻接表表示法的关系"></a>邻接矩阵与邻接表表示法的关系</h3><p><strong>联系</strong>：邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数。</p><p><strong>区别</strong>：</p><p>① 对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致），但邻接表不唯一（链接次序与顶点编号无关）。</p><p>② 邻接矩阵的空间复杂度为O(n2),而邻接表的空间复杂度为O(n+e)。</p><p><strong>用途</strong>：邻接矩阵多用于稠密图；而邻接表多用于稀疏图</p><h2 id="图的实现"><a href="#图的实现" class="headerlink" title="图的实现"></a>图的实现</h2><p>&emsp;链式存储结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">       第一</span><br><span class="line">    /   /\  \ 1</span><br><span class="line"> 6 /   /  \  \</span><br><span class="line">第四   /5   \3 第二</span><br><span class="line"> \   /      \  |</span><br><span class="line"> 7\ /        \ |2</span><br><span class="line">  第五 ---4--- 第三</span><br><span class="line">  </span><br><span class="line">   图</span><br></pre></td></tr></table></figure><h3 id="定义一个顶点"><a href="#定义一个顶点" class="headerlink" title="定义一个顶点"></a>定义一个顶点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public struct Vertex&lt;T:Hashable&gt; &#123;</span><br><span class="line">    var data :T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Vertex:Hashable &#123;</span><br><span class="line">    </span><br><span class="line">    public var hashValue: Int &#123;</span><br><span class="line">        return &quot;\(data)&quot;.hashValue</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static public func == (lhs:Vertex,rhs:Vertex) -&gt; Bool &#123;</span><br><span class="line">        return lhs.data == rhs.data</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Vertex: CustomStringConvertible &#123;</span><br><span class="line">    public var description: String &#123;</span><br><span class="line">        return &quot;\(data)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义边"><a href="#定义边" class="headerlink" title="定义边"></a>定义边</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public enum EdgeType &#123;</span><br><span class="line">    case directed // 有方向的</span><br><span class="line">    case undirected // 无方向的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public struct Edge&lt;T:Hashable&gt; &#123;</span><br><span class="line">    public var source:Vertex&lt;T&gt; //原点</span><br><span class="line">    public var destination:Vertex&lt;T&gt;//目的地</span><br><span class="line">    public let weight: Double? //权重</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Edge :Hashable &#123;</span><br><span class="line">    </span><br><span class="line">    public var hashValue: Int &#123;</span><br><span class="line">        return &quot;\(source)\(destination)\(weight)&quot;.hashValue</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static public func == (lhs:Edge&lt;T&gt;,rhs:Edge&lt;T&gt;) -&gt; Bool &#123;</span><br><span class="line">        return lhs.source == rhs.source &amp;&amp; lhs.destination == rhs.destination &amp;&amp; lhs.weight == rhs.weight</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义协议"><a href="#定义协议" class="headerlink" title="定义协议"></a>定义协议</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protocol Graphable &#123;</span><br><span class="line">    //协议需要一个称为元素的关联类型。这允许协议是通用的，可以容纳任何类型。</span><br><span class="line">    associatedtype Element: Hashable //</span><br><span class="line">    //为了让使用者定义一个输出的格式</span><br><span class="line">    var description: CustomStringConvertible &#123; get &#125; // 2</span><br><span class="line">    //提供一个通用的方法生成一个顶点</span><br><span class="line">    func createVertex(data: Element) -&gt; Vertex&lt;Element&gt; // 3</span><br><span class="line">    //提供一个通用的方法 在两个顶点之间添加一条边</span><br><span class="line">    func add(_ type: EdgeType, from source: Vertex&lt;Element&gt;, to destination: Vertex&lt;Element&gt;, weight: Double?)</span><br><span class="line">    //获取两个顶点之间的权重</span><br><span class="line">    func weight(from source: Vertex&lt;Element&gt;, to destination: Vertex&lt;Element&gt;) -&gt; Double?</span><br><span class="line">    // 获取与顶点相连的所有的边</span><br><span class="line">    func edges(from source: Vertex&lt;Element&gt;) -&gt; [Edge&lt;Element&gt;]? // 6</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义一个表实现协议"><a href="#定义一个表实现协议" class="headerlink" title="定义一个表实现协议"></a>定义一个表实现协议</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">open class AdjacencyList&lt;T: Hashable&gt; &#123;</span><br><span class="line">    // adjacencyDict 是一个字典 key 是顶点 value 是于顶点相连的所有边</span><br><span class="line">    public var adjacencyDict : [Vertex&lt;T&gt;: [Edge&lt;T&gt;]] = [:]</span><br><span class="line">    public init() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    /// 添加一个有方向的边</span><br><span class="line">    ///</span><br><span class="line">    /// - Parameters:</span><br><span class="line">    ///   - source: 顶点</span><br><span class="line">    ///   - destination: 终点</span><br><span class="line">    ///   - weight: 权重</span><br><span class="line">    fileprivate func addDirectedEdge(from source: Vertex&lt;Element&gt;, to destination: Vertex&lt;Element&gt;, weight: Double?) &#123;</span><br><span class="line">        let edge = Edge(source: source, destination: destination, weight: weight) // 1</span><br><span class="line">        adjacencyDict[source]?.append(edge) // 2</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 添加一个无方向的边：无论是源点或者是终点，其对应的边点数组都要添加这条边</span><br><span class="line">    ///</span><br><span class="line">    /// - Parameters:</span><br><span class="line">    ///   - vertices: 源点和终点</span><br><span class="line">    ///   - weight: 权重</span><br><span class="line">    fileprivate func addUndirectedEdge(vertices: (Vertex&lt;Element&gt;, Vertex&lt;Element&gt;), weight: Double?) &#123;</span><br><span class="line">        let (source, destination) = vertices</span><br><span class="line">        addDirectedEdge(from: source, to: destination, weight: weight)</span><br><span class="line">        addDirectedEdge(from: destination, to: source, weight: weight)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extension AdjacencyList:Graphable &#123;</span><br><span class="line">    public typealias Element = T</span><br><span class="line">    //为了让使用者定义一个输出的格式</span><br><span class="line">   public var description: CustomStringConvertible &#123;</span><br><span class="line">        var result = &quot;&quot;</span><br><span class="line">        for (vertex, edges) in adjacencyDict &#123;</span><br><span class="line">            var edgeString = &quot;&quot;</span><br><span class="line">            for (index, edge) in edges.enumerated() &#123;</span><br><span class="line">                if index != edges.count - 1 &#123;</span><br><span class="line">                    edgeString.append(&quot;\(edge.destination), &quot;)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    edgeString.append(&quot;\(edge.destination)&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.append(&quot;\(vertex) ---&gt; [ \(edgeString) ] \n &quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125; // 2</span><br><span class="line">    //提供一个通用的方法生成一个顶点</span><br><span class="line">    public func createVertex(data: Element) -&gt; Vertex&lt;Element&gt; &#123;</span><br><span class="line">        let vertex = Vertex(data: data) //生成一个顶点</span><br><span class="line">        if adjacencyDict[vertex] == nil &#123; //如果当前存储边的数组为 nil（即还没有初始化） 则生成一个数组</span><br><span class="line">            adjacencyDict[vertex] = []</span><br><span class="line">        &#125;</span><br><span class="line">        return vertex //返回顶点</span><br><span class="line">    &#125;</span><br><span class="line">    //提供一个通用的方法 在两个顶点之间添加一条边</span><br><span class="line">   public func add(_ type: EdgeType, from source: Vertex&lt;Element&gt;, to destination: Vertex&lt;Element&gt;, weight: Double?) &#123;</span><br><span class="line">        switch type &#123;</span><br><span class="line">        case .directed://有向图</span><br><span class="line">            addDirectedEdge(from: source, to: destination, weight: weight)</span><br><span class="line">            break</span><br><span class="line">        case .undirected://无向图</span><br><span class="line">            addUndirectedEdge(vertices: (source, destination), weight: weight)</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    //获取两个顶点之间的权重</span><br><span class="line">  public  func weight(from source: Vertex&lt;Element&gt;, to destination: Vertex&lt;Element&gt;) -&gt; Double? &#123;</span><br><span class="line">        //获取当前源点的所有边</span><br><span class="line">        guard let edges = adjacencyDict[source] else &#123; return nil &#125;</span><br><span class="line">        for edge in edges &#123;// 遍历所有边</span><br><span class="line">            if edge.destination == destination &#123;//如果当前边的目的地等于要查询的目的地</span><br><span class="line">                return edge.weight //则返回 权重</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取与顶点相连的所有的边</span><br><span class="line">   public func edges(from source: Vertex&lt;Element&gt;) -&gt; [Edge&lt;Element&gt;]? &#123;</span><br><span class="line">        return adjacencyDict[source]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">let list = AdjacencyList&lt;String&gt;.init()</span><br><span class="line"></span><br><span class="line">  let first =  list.createVertex(data: &quot;第一&quot;)</span><br><span class="line">  let second =   list.createVertex(data: &quot;第二&quot;)</span><br><span class="line">  let third =   list.createVertex(data: &quot;第三&quot;)</span><br><span class="line">  let forth =   list.createVertex(data: &quot;第四&quot;)</span><br><span class="line">  let fifth =   list.createVertex(data: &quot;第五&quot;)</span><br><span class="line"></span><br><span class="line">list.add(.undirected, from: first, to: second, weight: 1)</span><br><span class="line">list.add(.undirected, from: first, to: third, weight: 3)</span><br><span class="line">list.add(.undirected, from: first, to: forth, weight: 6)</span><br><span class="line">list.add(.undirected, from: first, to: fifth, weight: 5)</span><br><span class="line">list.add(.undirected, from: forth, to: fifth, weight: 7)</span><br><span class="line">list.add(.undirected, from: fifth, to: third, weight: 4)</span><br><span class="line">list.add(.undirected, from: second, to: third, weight: 2)</span><br><span class="line"></span><br><span class="line">print(list.description)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">第四 ---&gt; [ 第一, 第五 ] </span><br><span class="line"> 第一 ---&gt; [ 第二, 第三, 第四, 第五 ] </span><br><span class="line"> 第五 ---&gt; [ 第一, 第四, 第三 ] </span><br><span class="line"> 第三 ---&gt; [ 第一, 第五, 第二 ] </span><br><span class="line"> 第二 ---&gt; [ 第一, 第三 ] </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">//print(list.edges(from: third))</span><br><span class="line">print(list.weight(from: third, to: fifth) ?? 0)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"> 4.0</span><br></pre></td></tr></table></figure><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>&emsp;从已给的连通图中某一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，就叫做图的遍历，它是图的基本运算。</p><h3 id="遍历实质"><a href="#遍历实质" class="headerlink" title="遍历实质"></a>遍历实质</h3><p>&emsp;找每个顶点的邻接点的过程。</p><h3 id="图的特点"><a href="#图的特点" class="headerlink" title="图的特点"></a>图的特点</h3><p>&emsp;图中可能存在回路，且图的任一顶点都可能与其它顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。</p><h3 id="图常用的遍历："><a href="#图常用的遍历：" class="headerlink" title="图常用的遍历："></a>图常用的遍历：</h3><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>&emsp;仿树的先序遍历过程</p><p><strong>简单归纳：</strong></p><ol><li>访问起始点v;</li><li>若v的第1个邻接点没访问过，深度遍历此邻接点；</li><li>若当前邻接点已访问过，再找v的第2个邻接点重新遍历。</li></ol><p><strong>深度优先搜索算法实现</strong></p><p>&emsp;与广度优先搜索算法不同的是广度优先算法需要一个队列作铺助，而广度优先搜索算法需要一个栈，因为栈是先进后出，深度优先搜索算法需要实现回退的逻辑，而栈正好符合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public func depthFirstSearch(from source: Vertex&lt;Element&gt;, to destination: Vertex&lt;Element&gt;)</span><br><span class="line">    -&gt; [Edge&lt;Element&gt;]?  &#123;</span><br><span class="line">        // 之所以用队列的原因就是 深度优先算法需要回退</span><br><span class="line">        var stack = Stack&lt;Vertex&lt;Element&gt;&gt;() // 创建一个堆栈来存储从起点到终点的潜在路径。</span><br><span class="line">            stack.push(source)//把开始的顶点压入栈</span><br><span class="line">         var visits : [Vertex&lt;Element&gt; : Visit&lt;Element&gt;] = [source: .source]//存储已经访问过的顶点</span><br><span class="line">         while let vertex = stack.pop()  &#123;</span><br><span class="line">            if vertex == destination &#123; // 如果源点和终点相同</span><br><span class="line">                var vertex = destination //</span><br><span class="line">                var route: [Edge&lt;Element&gt;] = []// 访问的路径</span><br><span class="line">                while let visit = visits[vertex],</span><br><span class="line">                    case .edge(let edge) = visit &#123;</span><br><span class="line">                        route = [edge] + route</span><br><span class="line">                        vertex = edge.source</span><br><span class="line">                &#125;</span><br><span class="line">                return route</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            guard let neighbors = self.edges(from: vertex), neighbors.count &gt; 0 else &#123;</span><br><span class="line">                _ = stack.pop()</span><br><span class="line">                continue</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            for edge in neighbors &#123;</span><br><span class="line">                if visits[edge.destination] == nil &#123;</span><br><span class="line">                    stack.push(edge.destination)</span><br><span class="line">                    visits[edge.destination] = .edge(edge)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">上文中的图用深度优先算法搜索 原点是“第五” 终点是“第二”</span><br><span class="line"></span><br><span class="line">if let ed = list.depthFirstSearch(from: fifth, to: second) &#123;</span><br><span class="line">    print(&quot;深度优先&quot;)</span><br><span class="line">    for edge in ed &#123;</span><br><span class="line">        print(&quot;\(edge.source) -&gt; \(edge.destination)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果是：</span><br><span class="line"></span><br><span class="line">深度优先</span><br><span class="line">第五 -&gt; 第三</span><br><span class="line">第三 -&gt; 第二</span><br></pre></td></tr></table></figure><h4 id="DFS算法效率分析"><a href="#DFS算法效率分析" class="headerlink" title="DFS算法效率分析"></a>DFS算法效率分析</h4><ol><li>用邻接矩阵来表示图，遍历图中每一个顶点都要从头扫描该顶点所在行，时间复杂度为O(n2)。</li><li>用邻接表来表示图，虽然有 2e 个表结点，但只需扫描 e 个结点即可完成遍历，加上访问 n个头结点的时间，时间复杂度为O(n+e)。</li></ol><p><strong>结论：</strong><br>稠密图适于在邻接矩阵上进行深度遍历；<br>稀疏图适于在邻接表上进行深度遍历。</p><h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><p>&emsp;基本思想：——仿树的层次遍历过程</p><p><strong>步骤简单归纳：</strong></p><p>1.在访问了起始点v之后，依次访问 v的邻接点；</p><p>2.然后再依次访问这些顶点中未被访问过的邻接点；<br>直到所有顶点都被访问过为止。</p><p><strong>代码实现以及步骤</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">  public func breadthFirstSearch(from source: Vertex&lt;Element&gt;, to destination: Vertex&lt;Element&gt;)</span><br><span class="line">        -&gt; [Edge&lt;Element&gt;]? &#123;</span><br><span class="line">            var queue = GraphaQueue&lt;Vertex&lt;Element&gt;&gt;()</span><br><span class="line">                queue.enqueue(source) // 1先把源点加入队列</span><br><span class="line">            /*</span><br><span class="line">                用字典 记录已经访问过的顶点用于记录访问的路径</span><br><span class="line">                键:顶点</span><br><span class="line">                值:一个枚举值</span><br><span class="line">                     enum Visit&lt;Element: Hashable&gt; &#123;</span><br><span class="line">                        case source 原点</span><br><span class="line">                        case edge(Edge&lt;Element&gt;) 边</span><br><span class="line">                     &#125;</span><br><span class="line">             */</span><br><span class="line">             var visits : [Vertex&lt;Element&gt; : Visit&lt;Element&gt;] = [source: .source]</span><br><span class="line">            while let visitedVertex = queue.dequeue() &#123; // 2遍历取出然后取出出队的元素</span><br><span class="line">                if visitedVertex == destination &#123; // 3如果源点和终点相同</span><br><span class="line">                    var vertex = destination //</span><br><span class="line">                    var route: [Edge&lt;Element&gt;] = []// 访问的路径</span><br><span class="line">                    </span><br><span class="line">                    while let visit = visits[vertex],</span><br><span class="line">                        case .edge(let edge) = visit &#123;</span><br><span class="line">                            route = [edge] + route</span><br><span class="line">                            vertex = edge.source</span><br><span class="line">                            </span><br><span class="line">                    &#125;</span><br><span class="line">                    return route</span><br><span class="line">                &#125;</span><br><span class="line">                /*</span><br><span class="line">                 1 取出跟原点相关的所有边</span><br><span class="line">                 2 遍历跟原点相关的所有边 --&gt; 找到边的终点</span><br><span class="line">                 3 判断：如果边的终点没有被访问过：即邻接点还没有被访问过</span><br><span class="line">                 4 把此邻接点加入队列</span><br><span class="line">                 5 把邻接点标记为已访问</span><br><span class="line">                 */</span><br><span class="line">                let neighbourEdges = edges(from: visitedVertex) ?? [] // 1</span><br><span class="line">                for edge in neighbourEdges &#123;//2</span><br><span class="line">                    if visits[edge.destination] == nil &#123;//3</span><br><span class="line">                        queue.enqueue(edge.destination)//4</span><br><span class="line">                        visits[edge.destination] = .edge(edge)//5</span><br><span class="line">                    &#125;</span><br><span class="line">                    print(&quot;\(edge.destination)&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                print(&quot;---end---\n&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">上文中的图用广度优先搜索，原点是“第五” 终点是“第二”</span><br><span class="line"></span><br><span class="line">if let ed = list.breadthFirstSearch(from: fifth, to: second) &#123;</span><br><span class="line">    print(&quot;广度优先&quot;)</span><br><span class="line">    for edge in ed &#123;</span><br><span class="line">        print(&quot;\(edge.source) -&gt; \(edge.destination)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">广度优先</span><br><span class="line">第五 -&gt; 第一</span><br><span class="line">第一 -&gt; 第二</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox" checked> 注意：同样是从“第五”到“第二”，广度优先算法和深度优先算法的结果是不同的</li></ul><p><strong>总结</strong>：广度优先搜索是一种分层的搜索过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有回退的情况。<br>因此，广度优先搜索不是一个递归的过程，其算法也不是递归的。</p><h4 id="广度优先算法效率分析"><a href="#广度优先算法效率分析" class="headerlink" title="广度优先算法效率分析"></a>广度优先算法效率分析</h4><ul><li>如果使用邻接矩阵，则BFS对于每一个被访问到的顶点，都要循环检测矩阵中的整整一行（ n 个元素），总的时间代价为O(n2)。</li><li>用邻接表来表示图，虽然有 2e 个表结点，但只需扫描 e 个结点即可完成遍历，加上访问 n个头结点的时间，时间复杂度为O(n+e)。</li></ul><h4 id="广度优先与深度优先算法效率比较"><a href="#广度优先与深度优先算法效率比较" class="headerlink" title="广度优先与深度优先算法效率比较"></a>广度优先与深度优先算法效率比较</h4><ul><li><p>空间复杂度相同，都是O(n)(借用了堆栈或队列）；</p></li><li><p>时间复杂度只与存储结构（邻接矩阵或邻接表）有关，而与搜索路径无关。</p></li></ul><h2 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h2><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><blockquote><p>极小连通子图：该子图是G 的连通子图，在该子图中删除任何一条边，子图不再连通。</p></blockquote><blockquote><p>生成树：包含图G所有顶点的极小连通子图（n-1条边）。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/7/26/164d7401eb75216a?w=1368&amp;h=504&amp;f=png&amp;s=110462" alt=""></p><h4 id="最小生成树的典型用途"><a href="#最小生成树的典型用途" class="headerlink" title="最小生成树的典型用途"></a>最小生成树的典型用途</h4><p>&emsp;欲在n个城市间建立通信网，则n个城市应铺n-1条线路；但因为每条线路都会有对应的经济成本，而n个城市可能有n(n-1)/2 条线路，那么，如何选择n–1条线路，使总费用最少？</p><blockquote><p>首先明确：<br>使用不同的遍历图的方法，可以得到不同的生成树<br>从不同的顶点出发，也可能得到不同的生成树。<br>按照生成树的定义，n 个顶点的连通网络的生成树有 n 个顶点、n-1 条边。</p></blockquote><p>&emsp;目标：<br>在网的多个生成树中，寻找一个各边权值之和最小的生成树</p><h4 id="构造最小生成树的准则"><a href="#构造最小生成树的准则" class="headerlink" title="构造最小生成树的准则"></a>构造最小生成树的准则</h4><ul><li>必须只使用该网中的边来构造最小生成树；</li><li>必须使用且仅使用n-1条边来联结网络中的n个顶点</li><li>不能使用产生回路的边</li></ul><h4 id="如何求最小生成树"><a href="#如何求最小生成树" class="headerlink" title="如何求最小生成树"></a>如何求最小生成树</h4><h5 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法:"></a>Prim算法:</h5><p>&emsp;归并顶点，与边数无关，适于稠密网</p><p>代码实现： 要依赖一个优先队列（堆）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Prim&lt;T:Hashable&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    typealias Graph = AdjacencyList&lt;T&gt;</span><br><span class="line">    //定义一个小堆</span><br><span class="line">    var heap = Heap&lt;(vertex:Vertex&lt;T&gt;,weight:Double,parent:Vertex&lt;T&gt;?)&gt;.init &#123; (vertex, vertex2) -&gt; Bool in</span><br><span class="line">        return vertex.weight &lt; vertex2.weight</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 生成最小生成树</span><br><span class="line">    ///</span><br><span class="line">    /// - Parameter graph: &lt;#graph description#&gt;</span><br><span class="line">    /// - Returns: &lt;#return value description#&gt;</span><br><span class="line">    func createMinimumSpanningTree(graph:Graph) -&gt; (cost:Double,mst:Graph) &#123;</span><br><span class="line">        var cost = 0.0</span><br><span class="line">        let mst = Graph()</span><br><span class="line">        var visited = Set&lt;Vertex&lt;T&gt;&gt;()</span><br><span class="line">        </span><br><span class="line">        guard let start = graph.getAllVertices().first else&#123;</span><br><span class="line">            print(mst.description)</span><br><span class="line">            return (cost:cost,mst:mst)</span><br><span class="line">        &#125;</span><br><span class="line">        //先把开始的顶点加入到堆中</span><br><span class="line">        heap.enqueue((vertex: start, weight: 0.0, parent: nil))</span><br><span class="line">        </span><br><span class="line">        while let head = heap.dequeue() &#123;</span><br><span class="line">            let vertex = head.vertex //取出堆中的第一个顶点</span><br><span class="line">            if visited.contains(vertex) &#123;//检查是否已经访问过了 如果已经访问过了 则进行下一次循环</span><br><span class="line">                continue</span><br><span class="line">            &#125;</span><br><span class="line">            visited.insert(vertex)</span><br><span class="line">            cost += head.weight</span><br><span class="line">            if let prev = head.parent &#123; // 5</span><br><span class="line">                print(prev.description)</span><br><span class="line">                let pre = mst.createVertex(data: prev.data)</span><br><span class="line">                let ver = mst.createVertex(data: vertex.data)</span><br><span class="line">                mst.add(.undirected, from: pre, to: ver, weight: head.weight)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if let neighbours = graph.edges(from: vertex) &#123;</span><br><span class="line">                for neighbour in neighbours &#123;</span><br><span class="line">                    if !visited.contains(neighbour.destination) &#123;</span><br><span class="line">                        heap.enqueue((vertex: neighbour.destination, weight: neighbour.weight ?? 0, parent: vertex))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (cost:cost,mst:mst)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">let list = AdjacencyList&lt;String&gt;.init()</span><br><span class="line"></span><br><span class="line">let first =  list.createVertex(data: &quot;第一&quot;)</span><br><span class="line">let second =   list.createVertex(data: &quot;第二&quot;)</span><br><span class="line">let third =   list.createVertex(data: &quot;第三&quot;)</span><br><span class="line">let forth =   list.createVertex(data: &quot;第四&quot;)</span><br><span class="line">let fifth =   list.createVertex(data: &quot;第五&quot;)</span><br><span class="line"></span><br><span class="line">list.add(.undirected, from: first, to: second, weight: 1)</span><br><span class="line">list.add(.undirected, from: first, to: third, weight: 3)</span><br><span class="line">list.add(.undirected, from: first, to: forth, weight: 6)</span><br><span class="line">list.add(.undirected, from: first, to: fifth, weight: 5)</span><br><span class="line">list.add(.undirected, from: forth, to: fifth, weight: 7)</span><br><span class="line">list.add(.undirected, from: fifth, to: third, weight: 4)</span><br><span class="line">list.add(.undirected, from: second, to: third, weight: 2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let prim = Prim&lt;String&gt;.init()</span><br><span class="line">let (cost,mst) = prim.createMinimumSpanningTree(graph: list)</span><br><span class="line"></span><br><span class="line">print(&quot;权值:\(cost)&quot;)</span><br><span class="line">print(&quot;最小生成树:&quot;)</span><br><span class="line"></span><br><span class="line">print(mst.description)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">权值:13.0</span><br><span class="line">最小生成树:</span><br><span class="line">第四 ---&gt; [ 第一 ] </span><br><span class="line"> 第一 ---&gt; [ 第四, 第二 ] </span><br><span class="line"> 第五 ---&gt; [ 第三 ] </span><br><span class="line"> 第三 ---&gt; [ 第二, 第五 ] </span><br><span class="line"> 第二 ---&gt; [ 第一, 第三 ]</span><br></pre></td></tr></table></figure></p><h5 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h5><p>&emsp;归并边，适于稀疏网</p><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p><strong>典型用途：</strong> 交通问题。如：城市A到城市B有多条线路，但每条线路的交通费（或所需时间）不同，那么，如何选择一条线路，使总费用（或总时间）最少？</p><p><strong>问题抽象：</strong> 在带权有向图中A点（源点）到达B点（终点）的多条路径中，寻找一条各边权值之和最小的路径，即最短路径。</p><ul><li style="list-style: none"><input type="checkbox"> 注意：最短路径与最小生成树不同，路径上不一定包含n个顶点</li></ul><h4 id="两种常见的最短路径问题："><a href="#两种常见的最短路径问题：" class="headerlink" title="两种常见的最短路径问题："></a>两种常见的最短路径问题：</h4><h5 id="单源最短路径—用Dijkstra（迪杰斯特拉）算法"><a href="#单源最短路径—用Dijkstra（迪杰斯特拉）算法" class="headerlink" title="单源最短路径—用Dijkstra（迪杰斯特拉）算法"></a>单源最短路径—用Dijkstra（迪杰斯特拉）算法</h5><p>&emsp;一顶点到其余各顶点</p><h5 id="所有顶点间的最短路径—用Floyd（弗洛伊德）算法"><a href="#所有顶点间的最短路径—用Floyd（弗洛伊德）算法" class="headerlink" title="所有顶点间的最短路径—用Floyd（弗洛伊德）算法"></a>所有顶点间的最短路径—用Floyd（弗洛伊德）算法</h5><p>&emsp;任意两顶点之间</p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><h4 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h4><p>&emsp;用有向图来描述一个工程或系统的进行过程。<br>一个工程可以分为若干个子工程，只要完成了这些子工程（活动），就可以导致整个工程的完成。</p><blockquote><p>拓扑排序算法的思想－重复选择没有直接前驱的顶点</p></blockquote><ol><li>输入AOV网络。令 n 为顶点个数。    </li><li>在AOV网络中选一个没有直接前驱的顶点, 并输出之; </li><li>从图中删去该顶点, 同时删去所有它发出的有向边;</li><li>重复以上 2、3 步, 直到：</li></ol><p>&emsp;1&gt;全部顶点均已输出，拓扑有序序列形成，拓扑排序完成</p><p>&emsp;2&gt;图中还有未输出的顶点，但已跳出处理循环。这说明图中还剩下一些顶点，它们都有直接前驱，再也找不到没有前驱的顶点了。这时AOV网络中必定存在有向环。</p><h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><h4 id="解决的问题-1"><a href="#解决的问题-1" class="headerlink" title="解决的问题"></a>解决的问题</h4><p>&emsp;        假设以有向网表示一个施工流图，弧上的权值表示完成该项子工程所需时间。<br>问：哪些子工程项是“关键工程”？<br>即：哪些子工程项将影响整个工程的完成期限的。</p><p>&emsp;整个工程完成的时间为：从有向图的源点到汇点的最长路径。</p><p>&emsp;关键活动指的是：该弧上的权值增加 将使有向图上的最长路径的长度增加。</p><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图的定义和基本术语&quot;&gt;&lt;a href=&quot;#图的定义和基本术语&quot; class=&quot;headerlink&quot; title=&quot;图的定义和基本术语&quot;&gt;&lt;/a&gt;图的定义和基本术语&lt;/h2&gt;&lt;h3 id=&quot;图的知识图谱&quot;&gt;&lt;a href=&quot;#图的知识图谱&quot; class=&quot;head
      
    
    </summary>
    
      <category term="数据结构" scheme="http://www.wuchao.net.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.wuchao.net.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构笔记—树和二叉树</title>
    <link href="http://www.wuchao.net.cn/2018/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%E2%80%94%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://www.wuchao.net.cn/2018/08/11/数据结构笔记—树和二叉树/</id>
    <published>2018-08-11T06:48:53.000Z</published>
    <updated>2018-09-29T07:50:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>树是n个结点的有限集</p></blockquote><h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">            A</span><br><span class="line">        /   |   \</span><br><span class="line">      B     C     D</span><br><span class="line">    /  \    |  /  |  \</span><br><span class="line">   E     F  G  H  I   J </span><br><span class="line"> /  \          |</span><br><span class="line">K    L         M</span><br></pre></td></tr></table></figure><ul><li>根：即根结点(没有前驱)</li><li>叶子：即终端结点(没有后继)</li><li>森林：指m棵不相交的树的集合(例如删除A后的子树个数)</li><li>有序树：结点各子树从左至右有序，不能互换（左为第一）</li><li>无序树：结点各子树可互换位置</li><li>双亲：即上层的那个结点(直接前驱)</li><li>孩子：即下层结点的子树的根(直接后继)</li><li>兄弟：同一双亲下的同层结点（孩子之间互称兄弟）</li><li>堂兄弟：即双亲位于同一层的结点（但并非同一双亲）</li><li>祖先：即从根到该结点所经分支的所有结点</li><li>子孙：即该结点下层子树中的任一结点</li><li>结点：即树的数据元素</li><li>结点的度：结点拥有的子树数</li><li>结点的层次：从根到该结点的层数（根结点算第一层）</li><li>终端结点：即度为0的结点，即叶子</li><li>分支结点：即度不为0的结点（也称为内部结点）</li><li>树的度:所有结点度中的最大值</li><li>树的深度(或高度):指所有结点中最大的层数</li></ul><h4 id="树的实现"><a href="#树的实现" class="headerlink" title="树的实现"></a>树的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">    构造如下的树</span><br><span class="line"> </span><br><span class="line">             1</span><br><span class="line">           /   \</span><br><span class="line">          2     3</span><br><span class="line">         /|\    |  \</span><br><span class="line">        4 5 6   10   11</span><br><span class="line">       /|\     / | \</span><br><span class="line">      7 8 9   12 13 14</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/// 树的结点定义</span><br><span class="line">public class TreeNode&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    public var value:T</span><br><span class="line">    </span><br><span class="line">    public weak var parent:TreeNode? // 父节点 只有一个</span><br><span class="line"> </span><br><span class="line">    public var children = [TreeNode&lt;T&gt;]()// 有多个</span><br><span class="line">    </span><br><span class="line">    init(value:T) &#123;</span><br><span class="line">        self.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public func addChild(_ node:TreeNode&lt;T&gt;) &#123;</span><br><span class="line">        children.append(node)</span><br><span class="line">        node.parent = self</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension TreeNode: CustomStringConvertible &#123;</span><br><span class="line">    public var description: String &#123;</span><br><span class="line">        var s = &quot;\(value)&quot;</span><br><span class="line">        if !children.isEmpty &#123;</span><br><span class="line">           s += &quot; &#123;&quot; + children.map &#123;</span><br><span class="line">                $0.description</span><br><span class="line">            &#125;.joined(separator: &quot;, &quot;) + &quot;&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        return s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extension TreeNode where T:Equatable &#123;</span><br><span class="line">    //搜索</span><br><span class="line">    public func search(_ value:T) -&gt;TreeNode? &#123;</span><br><span class="line">        if value == self.value &#123;</span><br><span class="line">            return self</span><br><span class="line">        &#125;</span><br><span class="line">        for child in children &#123;</span><br><span class="line">            if let found = child.search(value) &#123;</span><br><span class="line">                return found</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><blockquote><p>二叉树基本特点：<br>结点的度小于等于2<br>有序树（子树有序，不能颠倒）</p></blockquote><h4 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h4><ol><li>在二叉树的第i层上至多有2i-1个结点,至少有1个结点</li><li>深度为k的二叉树至多有2k-1个结点，至少有 k 个结点</li><li>对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2＋1 （即n0=n2+1）</li><li>性质4: 具有n个结点的完全二叉树的深度必为log2n＋1 (log2n向下取整)</li><li>对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2 (i/2向下取整)。</li></ol><h5 id="特殊形态的二叉树"><a href="#特殊形态的二叉树" class="headerlink" title="特殊形态的二叉树"></a>特殊形态的二叉树</h5><ol><li>满二叉树：一棵深度为k 且有2k -1个结点的二叉树。（特点：每层都“充满”了结点）</li></ol><p><img src="https://github.com/JiWuChao/DataStructure/blob/master/Resource/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png?raw=true" alt="满二叉树"></p><p>2.完全二叉树：深度为k 的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k 的满二叉树中编号从1至n的结点一一对应</p><p><img src="https://github.com/JiWuChao/DataStructure/blob/master/Resource/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png?raw=true" alt="完全二叉树"></p><h5 id="满二叉树和完全二叉树的区别"><a href="#满二叉树和完全二叉树的区别" class="headerlink" title="满二叉树和完全二叉树的区别"></a>满二叉树和完全二叉树的区别</h5><p>&emsp;满二叉树是叶子一个也不少的树，而完全二叉树虽然前n-1层是满的，但最底层却允许在右边缺少连续若干个结点。满二叉树是完全二叉树的一个特例。</p><ul><li style="list-style: none"><input type="checkbox" checked> 注意：从存储形式来讲适合顺序存储。如果其他形式的二叉树用顺序存储结点间关系蕴含在其存储位置中必将浪费空间</li></ul><h4 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h4><h4 id="定义结点"><a href="#定义结点" class="headerlink" title="定义结点"></a>定义结点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public indirect enum BinaryTree&lt;T&gt; &#123;</span><br><span class="line">    //左子树 / 值 / 右子树</span><br><span class="line">    case node(BinaryTree&lt;T&gt;,T,BinaryTree&lt;T&gt;)</span><br><span class="line">    case empty</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求结点数"><a href="#求结点数" class="headerlink" title="求结点数"></a>求结点数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//计算结点数</span><br><span class="line"> public var count: Int &#123;</span><br><span class="line">     switch self &#123;</span><br><span class="line">     case let .node(left, _, right):</span><br><span class="line">         return left.count + 1 + right.count //递归</span><br><span class="line">     case .empty:</span><br><span class="line">         return 0</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树构造过程"><a href="#二叉树构造过程" class="headerlink" title="二叉树构造过程"></a>二叉树构造过程</h4><p>&emsp;构造二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      1</span><br><span class="line">    /   \</span><br><span class="line">   2      3</span><br><span class="line"> /  \    /</span><br><span class="line">4    5  6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//二叉树的构造过程</span><br><span class="line">先从叶子结点开始</span><br><span class="line"></span><br><span class="line">let node5 = BinaryTree.node(.empty, &quot;5&quot;, .empty)</span><br><span class="line">let node6 = BinaryTree.node(.empty, &quot;6&quot;, .empty)</span><br><span class="line">let node4 = BinaryTree.node(.empty, &quot;4&quot;, .empty)</span><br><span class="line"></span><br><span class="line">let node2 = BinaryTree.node(node4, &quot;2&quot;, node5)</span><br><span class="line">let node3 = BinaryTree.node(node6, &quot;3&quot;, .empty)</span><br><span class="line">let node1 = BinaryTree.node(node2, &quot;1&quot;, node3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(node1)</span><br><span class="line">    </span><br><span class="line">    结果：</span><br><span class="line">        value: 1, left = [value: 2, left = [value: 4, left = [], right = []], right = [value: 5, left = [], right = []]], right = [value: 3, left = [value: 6, left = [], right = []], right = []]</span><br><span class="line"></span><br><span class="line">print(node1.count)</span><br><span class="line">    结果： 6</span><br></pre></td></tr></table></figure><h3 id="遍历二叉树和线索二叉树"><a href="#遍历二叉树和线索二叉树" class="headerlink" title="遍历二叉树和线索二叉树"></a>遍历二叉树和线索二叉树</h3><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><p>&emsp;遍历定义——指按某条搜索路线遍访每个结点且不重复（又称周游）。</p><p>&emsp;遍历用途——它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。  </p><h4 id="遍历规则"><a href="#遍历规则" class="headerlink" title="遍历规则"></a>遍历规则</h4><ol><li>DLR—先序遍历，即先根再左再右</li><li>LDR—中序遍历，即先左再根再右</li><li>LRD—后序遍历，即先左再右再根</li></ol><p>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">          A</span><br><span class="line">        /   \</span><br><span class="line">       B     C</span><br><span class="line">     /  \ </span><br><span class="line">    D    E</span><br><span class="line">    </span><br><span class="line">先序遍历：A B D E C</span><br><span class="line"></span><br><span class="line">中序遍历：D B E A C</span><br><span class="line"></span><br><span class="line">后序遍历：D E B C A</span><br></pre></td></tr></table></figure></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">     DLR—先序遍历，即先根再左再右</span><br><span class="line">     LDR—中序遍历，即先左再根再右</span><br><span class="line">     LRD—后序遍历，即先左再右再根</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //先序遍历</span><br><span class="line">    func traverseDLR(process:(T)-&gt;Void) &#123;</span><br><span class="line">        if case let .node(left, value, right) = self&#123;</span><br><span class="line">            process(value)</span><br><span class="line">            left.traverseDLR(process: process)</span><br><span class="line">            right.traverseDLR(process: process)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //中序遍历</span><br><span class="line">    func traverseLDR(process:(T)-&gt;Void) &#123;</span><br><span class="line">        if case let .node(left, value, right) = self&#123;</span><br><span class="line">            left.traverseLDR(process: process)</span><br><span class="line">            process(value)</span><br><span class="line">            right.traverseLDR(process: process)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 后续遍历</span><br><span class="line">    </span><br><span class="line">    func traverseLRD(process:(T)-&gt;Void) &#123;</span><br><span class="line">        if case let .node(left, value, right) = self&#123;</span><br><span class="line">            left.traverseLRD(process: process)</span><br><span class="line">            right.traverseLRD(process: process)</span><br><span class="line">            process(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">  </span><br><span class="line">      1</span><br><span class="line">    /   \</span><br><span class="line">   2      3</span><br><span class="line"> /  \    /</span><br><span class="line">4    5  6</span><br><span class="line"></span><br><span class="line">以遍历此树为例：</span><br><span class="line"></span><br><span class="line">//先序遍历</span><br><span class="line">var s1 = &quot;&quot;</span><br><span class="line">tree.traverseDLR &#123; (value) in</span><br><span class="line">    s1 += &quot; -&gt; &quot; + &quot;\(value)&quot;</span><br><span class="line">    print(s1)</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">  遍历过程打印：</span><br><span class="line"> -&gt; 1 </span><br><span class="line"> -&gt; 1 -&gt; 2 </span><br><span class="line"> -&gt; 1 -&gt; 2 -&gt; 4</span><br><span class="line"> -&gt; 1 -&gt; 2 -&gt; 4 -&gt; 5</span><br><span class="line"> -&gt; 1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 3</span><br><span class="line"> -&gt; 1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 3 -&gt; 6</span><br><span class="line"></span><br><span class="line">//中序 </span><br><span class="line">var s2 = &quot;&quot;</span><br><span class="line">node1.traverseLDR &#123; (value) in</span><br><span class="line">    s2 += &quot; -&gt; &quot; + &quot;\(value)&quot;</span><br><span class="line">    print(s2)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> 遍历过程打印：</span><br><span class="line"> -&gt; 4</span><br><span class="line"> -&gt; 4 -&gt; 2</span><br><span class="line"> -&gt; 4 -&gt; 2 -&gt; 5</span><br><span class="line"> -&gt; 4 -&gt; 2 -&gt; 5 -&gt; 1</span><br><span class="line"> -&gt; 4 -&gt; 2 -&gt; 5 -&gt; 1 -&gt; 6</span><br><span class="line"> -&gt; 4 -&gt; 2 -&gt; 5 -&gt; 1 -&gt; 6 -&gt; 3</span><br><span class="line"> </span><br><span class="line">//后序遍历</span><br><span class="line">var s3 = &quot;&quot;</span><br><span class="line">node1.traverseLRD &#123; (value) in</span><br><span class="line">    s3 += &quot; -&gt; &quot; + &quot;\(value)&quot;</span><br><span class="line">    print(s3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 遍历过程打印：</span><br><span class="line"> -&gt; 4</span><br><span class="line"> -&gt; 4 -&gt; 5</span><br><span class="line"> -&gt; 4 -&gt; 5 -&gt; 2</span><br><span class="line"> -&gt; 4 -&gt; 5 -&gt; 2 -&gt; 6</span><br><span class="line"> -&gt; 4 -&gt; 5 -&gt; 2 -&gt; 6 -&gt; 3</span><br><span class="line"> -&gt; 4 -&gt; 5 -&gt; 2 -&gt; 6 -&gt; 3 -&gt; 1</span><br></pre></td></tr></table></figure><h4 id="遍历算法的分析"><a href="#遍历算法的分析" class="headerlink" title="遍历算法的分析"></a>遍历算法的分析</h4><p>&emsp;从递归的角度看，三种算法是完全相同的，或说这三种算法的访问路径是相同的，只是访问结点的时机不同。</p><blockquote><p>时间效率:O(n) //每个结点只访问一次</p></blockquote><blockquote><p>空间效率:O(n) //栈占用的最大辅助空间</p></blockquote><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>&emsp;普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得<br>若将遍历后对应的有关前驱和后继预存起来，则从第一个结点(++可能是根、或最左（右）叶子++)开始就能很快“顺藤摸瓜”而遍历整个树</p><p>&emsp;例如中序遍历结果：B D C E A F H G，实际上已将二叉树转为线性排列，显然具有唯一前驱和唯一后继！</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li>线索：指向结点前驱和后继的指针</li><li>线索链表：加上线索二叉链表</li><li>线索二叉树：加上线索的二叉树（图形式样）</li><li>线索化：对二叉树以某种次序遍历使其变为线索二叉树的过程</li></ul><h4 id="线索化规则"><a href="#线索化规则" class="headerlink" title="线索化规则"></a>线索化规则</h4><ol><li>若结点有左子树，则lchild指向其左孩子；否则， lchild指向其直接前驱(即线索)；</li><li>若结点有右子树，则rchild指向其右孩子；否则， rchild指向其直接后继(即线索) 。</li></ol><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><h3 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h3><h4 id="术语-1"><a href="#术语-1" class="headerlink" title="术语"></a>术语</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      A</span><br><span class="line">    /   \</span><br><span class="line">   B     C</span><br><span class="line"> /  \   /  \ </span><br><span class="line">D    E F    G</span><br></pre></td></tr></table></figure><ul><li><p>路径：由一结点到另一结点间的分支所构成- 路径长度：路径上的分支数目。 <em>如：A→E 的路径长度＝2</em></p></li><li><p>带权路径长度：结点到根的路径长度与结点上权的乘积</p></li><li>树的带权路径长度：树中所有叶子结点的带权路径长度之和</li></ul><ul><li>==霍夫曼树==：带权路径长度最小的树</li></ul><h4 id="霍夫曼树的构造过程"><a href="#霍夫曼树的构造过程" class="headerlink" title="霍夫曼树的构造过程"></a>霍夫曼树的构造过程</h4><blockquote><p>基本思想：使权大的结点靠近根</p></blockquote><blockquote><p>操作要点：对权值的合并、删除与替换，总是合并当前值最小的两个</p></blockquote><ol><li>根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。</li><li>在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。</li><li>在森林中删除这两棵树，同时将新得到的二叉树加入森林中。</li><li>重复上述两步，直到只含一棵树为止，这棵树即霍夫曼树。</li></ol><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;树和二叉树&quot;&gt;&lt;a href=&quot;#树和二叉树&quot; class=&quot;headerlink&quot; title=&quot;树和二叉树&quot;&gt;&lt;/a&gt;树和二叉树&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定
      
    
    </summary>
    
      <category term="数据结构" scheme="http://www.wuchao.net.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.wuchao.net.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-排序</title>
    <link href="http://www.wuchao.net.cn/2018/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.wuchao.net.cn/2018/08/10/数据结构-排序/</id>
    <published>2018-08-10T07:56:01.000Z</published>
    <updated>2018-09-29T07:50:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="https://user-gold-cdn.xitu.io/2018/8/1/164f5d1796b0c479?w=959&amp;h=702&amp;f=png&amp;s=120160" alt="image"></p><h2 id="排序的定义："><a href="#排序的定义：" class="headerlink" title="排序的定义："></a>排序的定义：</h2><blockquote><p>将一组杂乱无章的数据按一定规律顺次排列起来。</p></blockquote><h2 id="排序的目的："><a href="#排序的目的：" class="headerlink" title="排序的目的："></a>排序的目的：</h2><blockquote><p>便于查找！</p></blockquote><h2 id="内部排序和外部排序"><a href="#内部排序和外部排序" class="headerlink" title="内部排序和外部排序"></a>内部排序和外部排序</h2><ul><li>若待排序记录都在内存中，称为内部排序；</li></ul><ul><li><p>若待排序记录一部分在内存，一部分在外存，则称为外部排序。</p></li><li><p>[ ] 注意:外部排序时，要将数据分批调入内存来排序，中间结果还要及时放入外存，显然外部排序要复杂得多。 </p></li></ul><h2 id="衡量标准"><a href="#衡量标准" class="headerlink" title="衡量标准"></a>衡量标准</h2><ul><li>时间效率——排序速度（比较次数与移动次数）</li><li>空间效率——占内存辅助空间的大小</li><li>稳定性——A和B的关键字相等，排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><h5 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h5><p>&emsp;一般的排序过程：整个排序过程为n-1趟插入，即先将序列中第1个记录看成是一个有序子序列，然后从第2个记录开始，逐个进行插入，直至整个序列有序。</p><p><strong>下文实现一个和一般的不同的算法</strong></p><h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><p>为了便于理解，把比较的过程也打印了出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"> /*</span><br><span class="line"> 插入排序：</span><br><span class="line">    此实现的算法与上文中所说有差异，是修改版的</span><br><span class="line">    不需要和前面的进行交换</span><br><span class="line"> </span><br><span class="line">    思路：</span><br><span class="line">    1 从 数组中的第二个元素开始</span><br><span class="line">    2 和第一个元素进行比较 如果满足排序条件sortBy:(T,T) -&gt; Bool)</span><br><span class="line">    3 则把第一个元素向后移一位 然后把第二个元素放在第一个位置上</span><br><span class="line">    4 如果是第三次插入则要和前面的两个进行比较 是否需要移动</span><br><span class="line">    5 依此类推</span><br><span class="line">    总结：此算法整个过程就是找一个合适的位置进行插入</span><br><span class="line"> </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/// 插入排序</span><br><span class="line">///</span><br><span class="line">/// - Parameters:</span><br><span class="line">///   - contents: 要排序的内容</span><br><span class="line">///   - sortBy: 排序的条件</span><br><span class="line">/// - Returns: &lt;#return value description#&gt;</span><br><span class="line">func insertSort&lt;T&gt;(_ contents: [T], sortBy:(T,T) -&gt; Bool) -&gt;[T] &#123;</span><br><span class="line">    </span><br><span class="line">    guard contents.count &gt; 1 else &#123;</span><br><span class="line">        return contents</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var cntnts = contents</span><br><span class="line">    </span><br><span class="line">    for i in 1..&lt;cntnts.count &#123; //从第二个元素开始 因为第一个元素是有序的</span><br><span class="line">        print(&quot;--------第\(i)趟--------&quot;)</span><br><span class="line">        var j = i</span><br><span class="line">        let temp = cntnts[j]//保存当前的值</span><br><span class="line">        print(&quot;第\(i - j)次 是否需要移动 ？&quot;)</span><br><span class="line">        while j &gt; 0 &amp;&amp; sortBy(temp,cntnts[j-1]) &#123;//当前的值与其前一个值做比较</span><br><span class="line">             print(&quot;+++第\(i - j)次 需要移动+++&quot;)</span><br><span class="line">             print(&quot;+++第\(i - j)次 \(cntnts[j-1])向后移动到\(cntnts[j])的位置+++&quot;)</span><br><span class="line">            cntnts[j] = cntnts[j-1] // 向后移动一位</span><br><span class="line">            j -= 1</span><br><span class="line">        &#125;</span><br><span class="line">        print(&quot;**第\(i - j)次 不需要移动**&quot;)</span><br><span class="line">        print(&quot;+++\(temp)放到\(cntnts[j])的位置+++&quot;)</span><br><span class="line">        cntnts[j] = temp</span><br><span class="line">        print(cntnts)</span><br><span class="line">    &#125;</span><br><span class="line">    return cntnts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">var nums = [11,3,27,8,9]</span><br><span class="line"></span><br><span class="line">nums = insertSort(nums, sortBy: &#123; (n1, n2) -&gt; Bool in</span><br><span class="line">    return n1 &lt; n2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">print(nums)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">原始数组：</span><br><span class="line">[11, 3, 27, 8, 9]</span><br><span class="line">--------第1趟--------</span><br><span class="line">第0次 是否需要移动 ？</span><br><span class="line">+++第0次 需要移动+++</span><br><span class="line">+++第0次 11向后移动到3的位置+++</span><br><span class="line">**第1次 不需要移动**</span><br><span class="line">+++3放到11的位置+++</span><br><span class="line">[3, 11, 27, 8, 9]</span><br><span class="line">--------第2趟--------</span><br><span class="line">第0次 是否需要移动 ？</span><br><span class="line">**第0次 不需要移动**</span><br><span class="line">+++27放到27的位置+++</span><br><span class="line">[3, 11, 27, 8, 9]</span><br><span class="line">--------第3趟--------</span><br><span class="line">第0次 是否需要移动 ？</span><br><span class="line">+++第0次 需要移动+++</span><br><span class="line">+++第0次 27向后移动到8的位置+++</span><br><span class="line">+++第1次 需要移动+++</span><br><span class="line">+++第1次 11向后移动到27的位置+++</span><br><span class="line">**第2次 不需要移动**</span><br><span class="line">+++8放到11的位置+++</span><br><span class="line">[3, 8, 11, 27, 9]</span><br><span class="line">--------第4趟--------</span><br><span class="line">第0次 是否需要移动 ？</span><br><span class="line">+++第0次 需要移动+++</span><br><span class="line">+++第0次 27向后移动到9的位置+++</span><br><span class="line">+++第1次 需要移动+++</span><br><span class="line">+++第1次 11向后移动到27的位置+++</span><br><span class="line">**第2次 不需要移动**</span><br><span class="line">+++9放到11的位置+++</span><br><span class="line">[3, 8, 9, 11, 27]</span><br><span class="line">[3, 8, 9, 11, 27]</span><br><span class="line"></span><br><span class="line">比较字符串也是可以的：</span><br><span class="line"></span><br><span class="line">var strs = [&quot;11&quot;,&quot;3&quot;,&quot;27&quot;,&quot;8&quot;,&quot;9&quot;]</span><br><span class="line"></span><br><span class="line">strs = insertSort(strs, sortBy: &#123; (s1, s2) -&gt; Bool in</span><br><span class="line">    return s1.compare(s2) == .orderedAscending</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(strs)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">[&quot;11&quot;, &quot;27&quot;, &quot;3&quot;, &quot;8&quot;, &quot;9&quot;]</span><br></pre></td></tr></table></figure><h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><ul><li>设对象个数为n，则执行n-1趟</li><li><p>比较次数和移动次数与初始排列有关</p><ol><li>最好情况下：<br>　每趟只需比较 1 次，不移动<br>　总比较次数为 n-1</li></ol></li></ul><ol start="2"><li>最坏情况下：第 i 趟比较i次，移动i+1次</li></ol><blockquote><p>若出现各种可能排列的概率相同，则可取最好情况和最坏情况的平均情况<br>平均情况比较次数和移动次数为n^2/4</p></blockquote><p>结果：</p><ul><li>时间复杂度为 o(n^2)</li><li>空间复杂度为 o(1)</li><li>是一种稳定的排序方法</li></ul><h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><blockquote><p>折半插入排序（Binary Insertion Sort）是一种插入排序算法，通过不断地将数据元素插入到合适的位置进行排序，在寻找插入点时采用了折半查找</p></blockquote><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line">    折半（二分）插入排序：</span><br><span class="line"> </span><br><span class="line">    直接插入排序相当于在已经排好序的数组部分逐个比较 找到合适的插入位置，在查找插入的位置时从第一个到最后一个，因为已经插入的内容是有序的，所有很多冗余的比较。即如果插入的比最后一个还大(还小)，则仍然会从第一个比较到最后一个</span><br><span class="line">    折半插入排序是直接插入排序的优化版</span><br><span class="line">    优化：</span><br><span class="line">    由于直接插入排序是在查找插入位置的时候比较浪费时间，所以折半插入排序就优化查找。</span><br><span class="line"> 由于在逐渐插入的时候已经插入部分是有序的，查找插入位置其实就是在已经排好序的数组中找到一个位置，这时二分查找算法正好适合。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/// 寻找要插入的位置</span><br><span class="line">///</span><br><span class="line">/// - Parameters:</span><br><span class="line">///   - contents: &lt;#contents description#&gt;</span><br><span class="line">///   - value: &lt;#value description#&gt;</span><br><span class="line">///   - low: &lt;#low description#&gt;</span><br><span class="line">///   - high: &lt;#high description#&gt;</span><br><span class="line">/// - Returns: &lt;#return value description#&gt;</span><br><span class="line">func binarySearchLocation&lt;T:Comparable&gt;(_ contents: inout [T],_ value:T ,_ low:Int,_ high:Int) -&gt;Int &#123;</span><br><span class="line">    if high &lt;= low &#123;</span><br><span class="line">        return (value &gt; contents[low]) ? (low + 1): low</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;开始查找&quot;)</span><br><span class="line">    let midIdx = low + (high - low ) / 2</span><br><span class="line">    print(&quot;----当前已排好序的数组内容部分的中间位置是：第\(midIdx)个&quot;)</span><br><span class="line">    if value == contents[midIdx] &#123;</span><br><span class="line">        return midIdx + 1</span><br><span class="line">    &#125;</span><br><span class="line">    if value &gt; contents[midIdx]&#123;//binarySearchLocation(&amp;contents, value, midIdx+1, high)</span><br><span class="line">        print(&quot;-----从右边找&quot;)</span><br><span class="line">        return binarySearchLocation(&amp;contents, value, midIdx+1, high)</span><br><span class="line">    &#125;</span><br><span class="line">    if value &lt; contents[midIdx]&#123;//binarySearchLocation(&amp;contents, value, low, midIdx - 1)</span><br><span class="line">        print(&quot;-----从左边找&quot;)</span><br><span class="line">        return binarySearchLocation(&amp;contents, value, low, midIdx - 1)</span><br><span class="line">    &#125;</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func binaryInsertSort&lt;T:Comparable&gt;(_ contents:inout [T]) -&gt; [T] &#123;</span><br><span class="line">    var j = 0</span><br><span class="line">    for i in 1..&lt;contents.count &#123;</span><br><span class="line">        print(&quot;\n\n***********第\(i)次***********\n&quot;)</span><br><span class="line">        j = i - 1</span><br><span class="line">        let temp = contents[i] // 开始插入temp</span><br><span class="line">        print(&quot;要插入的是\(temp)&quot;)//binarySearchLocation(&amp;contents, temp, 0, j)</span><br><span class="line">        let location = binarySearchLocation(&amp;contents, temp, 0, j) //找到temp应该插入的位置</span><br><span class="line">        print(&quot;-----找到了:第\(location)个合适&quot;)</span><br><span class="line">        while j &gt;= location  &#123;</span><br><span class="line">            print(&quot;--------第\(j)个向后移动到第\(j+1)个&quot;)</span><br><span class="line">            contents[j+1] = contents[j]</span><br><span class="line">            j -= 1</span><br><span class="line">        &#125;</span><br><span class="line">        print(&quot;结果:\n+++++   把\(temp)放到第\(j+1)个位置  +++++&quot;)</span><br><span class="line">        contents[j+1] = temp</span><br><span class="line">        print(&quot;当前的排序结果是: \(contents[0...i])&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return contents</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [1,33,0,2,4,44,3]</span><br><span class="line"></span><br><span class="line">arr = binaryInsertSort(&amp;arr)</span><br><span class="line">print(&quot;\n--------最终结果是---------\n\(arr)&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">排序过程和结果：</span><br><span class="line"></span><br><span class="line">***********第1次***********</span><br><span class="line"></span><br><span class="line">要插入的是33</span><br><span class="line">-----找到了:第1个合适</span><br><span class="line">结果:</span><br><span class="line">+++++   把33放到第1个位置  +++++</span><br><span class="line">当前的排序结果是: [1, 33]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***********第2次***********</span><br><span class="line"></span><br><span class="line">要插入的是0</span><br><span class="line">开始查找</span><br><span class="line">----当前已排好序的数组内容部分的中间位置是：第0个</span><br><span class="line">-----从左边找</span><br><span class="line">-----找到了:第0个合适</span><br><span class="line">--------第1个向后移动到第2个</span><br><span class="line">--------第0个向后移动到第1个</span><br><span class="line">结果:</span><br><span class="line">+++++   把0放到第0个位置  +++++</span><br><span class="line">当前的排序结果是: [0, 1, 33]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***********第3次***********</span><br><span class="line"></span><br><span class="line">要插入的是2</span><br><span class="line">开始查找</span><br><span class="line">----当前已排好序的数组内容部分的中间位置是：第1个</span><br><span class="line">-----从右边找</span><br><span class="line">-----找到了:第2个合适</span><br><span class="line">--------第2个向后移动到第3个</span><br><span class="line">结果:</span><br><span class="line">+++++   把2放到第2个位置  +++++</span><br><span class="line">当前的排序结果是: [0, 1, 2, 33]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***********第4次***********</span><br><span class="line"></span><br><span class="line">要插入的是4</span><br><span class="line">开始查找</span><br><span class="line">----当前已排好序的数组内容部分的中间位置是：第1个</span><br><span class="line">-----从右边找</span><br><span class="line">开始查找</span><br><span class="line">----当前已排好序的数组内容部分的中间位置是：第2个</span><br><span class="line">-----从右边找</span><br><span class="line">-----找到了:第3个合适</span><br><span class="line">--------第3个向后移动到第4个</span><br><span class="line">结果:</span><br><span class="line">+++++   把4放到第3个位置  +++++</span><br><span class="line">当前的排序结果是: [0, 1, 2, 4, 33]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***********第5次***********</span><br><span class="line"></span><br><span class="line">要插入的是44</span><br><span class="line">开始查找</span><br><span class="line">----当前已排好序的数组内容部分的中间位置是：第2个</span><br><span class="line">-----从右边找</span><br><span class="line">开始查找</span><br><span class="line">----当前已排好序的数组内容部分的中间位置是：第3个</span><br><span class="line">-----从右边找</span><br><span class="line">-----找到了:第5个合适</span><br><span class="line">结果:</span><br><span class="line">+++++   把44放到第5个位置  +++++</span><br><span class="line">当前的排序结果是: [0, 1, 2, 4, 33, 44]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***********第6次***********</span><br><span class="line"></span><br><span class="line">要插入的是3</span><br><span class="line">开始查找</span><br><span class="line">----当前已排好序的数组内容部分的中间位置是：第2个</span><br><span class="line">-----从右边找</span><br><span class="line">开始查找</span><br><span class="line">----当前已排好序的数组内容部分的中间位置是：第4个</span><br><span class="line">-----从左边找</span><br><span class="line">-----找到了:第3个合适</span><br><span class="line">--------第5个向后移动到第6个</span><br><span class="line">--------第4个向后移动到第5个</span><br><span class="line">--------第3个向后移动到第4个</span><br><span class="line">结果:</span><br><span class="line">+++++   把3放到第3个位置  +++++</span><br><span class="line">当前的排序结果是: [0, 1, 2, 3, 4, 33, 44]</span><br><span class="line"></span><br><span class="line">--------最终结果是---------</span><br><span class="line">[0, 1, 2, 3, 4, 33, 44]</span><br></pre></td></tr></table></figure><h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>折半查找比顺序查找快，所以折半插入排序就平均性能来说比直接插入排序要快</li></ul><ul><li><p>它所需要的关键码比较次数与待排序对象序列的初始排列无关，仅依赖于对象个数。在插入第 i 个对象时，需要经过 log2i +1  次关键码比较，才能确定它应插入的位置</p></li><li><p>当 n 较大时，总关键码比较次数比直接插入排序的最坏情况要好得多，但比其最好情况要差</p></li><li>在对象的初始排列已经按关键码排好序或接近有序时，直接插入排序比折半插入排序执行的关键码比较次数要少</li><li>折半插入排序的对象移动次数与直接插入排序相同，依赖于对象的初始排列</li></ul><p><strong>总结：</strong></p><p>相比较直接插入排序而言</p><ol><li>减少了比较次数，但没有减少移动次数</li><li>平均性能优于直接插入排序</li></ol><ul><li>时间复杂度为 o(n2)</li><li>空间复杂度为 o(1)</li><li>是一种稳定的排序方法</li></ul><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h5 id="希尔排序的出发点是："><a href="#希尔排序的出发点是：" class="headerlink" title="希尔排序的出发点是："></a>希尔排序的出发点是：</h5><ul><li>直接插入排序在基本有序时，效率较高</li><li>在待排序的记录个数较少时，效率较高</li></ul><h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h5><p>&emsp;先将整个待排记录序列分割成若干子序列,分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。</p><h5 id="分段方法"><a href="#分段方法" class="headerlink" title="分段方法"></a>分段方法</h5><p>&emsp;子序列的构成不是简单地“逐段分割”<br>将相隔某个增量dk的记录组成一个子序列<br>让增量dk逐趟缩短（例如依次取5,3,1）<br>直到dk＝1为止。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>&emsp;小元素跳跃式前移<br>最后一趟增量为1时，序列已基本有序<br>平均性能优于直接插入排序</p><h5 id="排序过程"><a href="#排序过程" class="headerlink" title="排序过程"></a>排序过程</h5><p>例：关键字序列 T=(49，38，65，97, 76, 13, 27, 49*，55,  04）</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/29/164e69798049da91?w=482&amp;h=437&amp;f=jpeg&amp;s=27645" alt=""></p><ul><li>dk 值较大，子序列中对象较少，速度较快；</li><li>dk 值逐渐变小，子序列中对象变多，但大多数对象已基本有序，所以排序速度仍然很快。</li></ul><h5 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">func insertionSort&lt;T:Comparable&gt;(_ list: inout [T],sortBy:(T,T) -&gt; Bool, start: Int, dk: Int) &#123;</span><br><span class="line">    for i in stride(from: (start + dk), to: list.count, by: dk) &#123;</span><br><span class="line">        let currentValue = list[i]</span><br><span class="line">        var loc = i</span><br><span class="line">        while loc &gt;= dk &amp;&amp; sortBy(list[loc - dk] ,currentValue)&#123;</span><br><span class="line">            print(&quot;\(list[loc - dk]) 向后移动\(dk)位&quot;)</span><br><span class="line">            list[loc] = list[loc - dk]</span><br><span class="line">            loc -= dk</span><br><span class="line">            print(&quot;list: \(list)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        list[loc] = currentValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func shellSort&lt;T:Comparable&gt;(_ contents: inout [T], sortBy:(T,T) -&gt; Bool) &#123;</span><br><span class="line">    var sublistCount = contents.count / 2</span><br><span class="line">    </span><br><span class="line">    while sublistCount &gt; 0 &#123;</span><br><span class="line">        print(&quot;---- dk= \(sublistCount) -----&quot;)</span><br><span class="line">        for loc in 0..&lt;sublistCount &#123;</span><br><span class="line">            print(&quot; loc = \(loc)&quot;)</span><br><span class="line">            insertionSort(&amp;contents, sortBy: sortBy, start: loc, dk: sublistCount)</span><br><span class="line">        &#125;</span><br><span class="line">        print(&quot;移动结果：\(contents)&quot;)</span><br><span class="line">        sublistCount = sublistCount / 2</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var arr = [33,2,12,34,21]</span><br><span class="line"></span><br><span class="line">print(&quot;原始数组是：\n\(arr)\n&quot;)</span><br><span class="line">shellSort(&amp;arr) &#123; (v1, v2) -&gt; Bool in</span><br><span class="line">    return v1 &gt; v2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;最终结果：\n\(arr)\n&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">原始数组是：</span><br><span class="line">[33, 2, 12, 34, 21]</span><br><span class="line"></span><br><span class="line">---- dk= 2 -----</span><br><span class="line"> loc = 0</span><br><span class="line">33 向后移动2位</span><br><span class="line">list: [33, 2, 33, 34, 21]</span><br><span class="line">33 向后移动2位</span><br><span class="line">list: [12, 2, 33, 34, 33]</span><br><span class="line"> loc = 1</span><br><span class="line">移动结果：[12, 2, 21, 34, 33]</span><br><span class="line">---- dk= 1 -----</span><br><span class="line"> loc = 0</span><br><span class="line">12 向后移动1位</span><br><span class="line">list: [12, 12, 21, 34, 33]</span><br><span class="line">34 向后移动1位</span><br><span class="line">list: [2, 12, 21, 34, 34]</span><br><span class="line">移动结果：[2, 12, 21, 33, 34]</span><br><span class="line">最终结果：</span><br><span class="line">[2, 12, 21, 33, 34]</span><br></pre></td></tr></table></figure><h5 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h5><ul><li><p>时间复杂度是n和d的函数：</p><p>O(n^1.25）～ O(1.6n^1.25）—经验公式</p></li><li><p>空间复杂度为 o(1)</p></li><li>是一种不稳定的排序方法</li></ul><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h5 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h5><blockquote><p>每趟不断将记录两两比较，并按“前小后大” 规则交换</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">21，25，49， 25*，16，  08</span><br><span class="line">21，25，25*，16， 08 ， 49</span><br><span class="line">21，25， 16， 08 ，25*，49</span><br><span class="line">21，16， 08 ，25， 25*，49</span><br><span class="line">16，08 ，21， 25， 25*，49</span><br><span class="line">08，16， 21， 25， 25*，49</span><br></pre></td></tr></table></figure><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><blockquote><p>每趟结束时，不仅能挤出一个最大值到最后面位置，还能同时部分理顺其他元素；<br>           一旦下趟没有交换，还可提前结束排序</p></blockquote><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line">    使用泛型 需要外界传入是升序还是降序也就是 比较的规则 这样写的好处是</span><br><span class="line"> 这个排序方法任何容器中装的任何类型都可以使用 比如 Int ，String ,甚至是你自定义的 model 根据你model任意一个字段 作比较都是可以的</span><br><span class="line"> </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/// 冒泡排序</span><br><span class="line">///</span><br><span class="line">/// - Parameters:</span><br><span class="line">///   - contents: 要比较的内容</span><br><span class="line">///   - sortBy: 排序规则</span><br><span class="line">/// - Returns: 返回排好序的内容</span><br><span class="line">func bubbleSort&lt;T&gt;(_ contents: inout [T],_ sortBy:(T,T)-&gt;Bool)-&gt;[T] &#123;</span><br><span class="line">    guard contents.count &gt; 1 else &#123;</span><br><span class="line">        return contents</span><br><span class="line">    &#125;</span><br><span class="line">    let n = contents.count</span><br><span class="line">    for i in 0..&lt;n &#123;</span><br><span class="line">        for j in 0..&lt;(n - 1 - i) &#123;</span><br><span class="line">            if sortBy(contents[j],contents[j+1])&#123;</span><br><span class="line">                contents.swapAt(j, j + 1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return contents</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line"></span><br><span class="line">var nums = [11,3,27,8,9]</span><br><span class="line">nums = bubbleSort(&amp;nums, &#123; (n1, n2) -&gt; Bool in</span><br><span class="line">    return n1 &gt; n2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">print(nums)</span><br><span class="line">结果：</span><br><span class="line">[3, 8, 9, 11, 27]</span><br><span class="line"></span><br><span class="line">var strs = [&quot;11&quot;,&quot;3&quot;,&quot;27&quot;,&quot;8&quot;,&quot;9&quot;]</span><br><span class="line">strs = bubbleSort(&amp;strs, &#123; (n1, n2) -&gt; Bool in</span><br><span class="line">    return n1.compare(n2) == .orderedAscending</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">print(strs)</span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">[&quot;9&quot;, &quot;8&quot;, &quot;3&quot;, &quot;27&quot;, &quot;11&quot;]</span><br></pre></td></tr></table></figure><h5 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h5><ul><li>时间复杂度为 o(n^2)</li><li>空间复杂度为 o(1)</li><li>是一种稳定的排序方法</li></ul><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><img src="https://user-gold-cdn.xitu.io/2018/8/1/164f5d28f64b06f2?w=383&amp;h=342&amp;f=jpeg&amp;s=25623" alt="图片来源于网络"></p><h5 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h5><ul><li>任取一个元素 (如第一个) 为中心</li><li>所有比它小的元素一律前放，比它大的元素一律后放，形成左右两个子表；</li><li>对各子表重新选择中心元素并依此规则调整，直到每个子表的元素只剩一个</li></ul><p>①每一趟的子表的形成是采用从两头向中间交替式逼近法；</p><p>②由于每趟中对各子表的操作都相似，可采用递归算法。</p><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"> /*</span><br><span class="line"> 快速排序</span><br><span class="line"> */</span><br><span class="line">func quicklySort&lt;T: Comparable&gt;(_ contents:inout [T], low: Int, high: Int) &#123;</span><br><span class="line">    var i = low</span><br><span class="line">    var j = high</span><br><span class="line">    guard low &lt; high,low &gt;= 0,high &lt; contents.count  else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    let piv = (low + (high - low) / 2)//标志位</span><br><span class="line">    let lowValue = contents[piv] //</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     一个循环的流程</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     从高位（右边）开始：</span><br><span class="line">     1 循环判断 当前高位的值是否大于标志位值 如果大于 则再向前一位比较 一直找到小于标志位的index</span><br><span class="line">     2 高位找到比标志位的值小的index 之后 停止开始从低位（左边）开始</span><br><span class="line">     </span><br><span class="line">     低位开始 ：</span><br><span class="line">     </span><br><span class="line">     1 循环判断 当前低位的值是否小于标志位 如果小于标志位则index + 1 进行下一位比较，直到找到比标志位大的值</span><br><span class="line">     2 低位找到比标志位大的值之后停止</span><br><span class="line">     </span><br><span class="line">     交换：</span><br><span class="line">     </span><br><span class="line">     从低位和高位找到了 比标志位大的值和比标志位小的值 然后这两个值交换</span><br><span class="line">     </span><br><span class="line">     当i &gt;= j 即低位的index &gt;= 高位的index时 停止这一轮的循环</span><br><span class="line">     </span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">    print(&quot;\n标志位&quot;)</span><br><span class="line">    print(lowValue)</span><br><span class="line">    </span><br><span class="line">    while i &lt; j &#123;</span><br><span class="line">        while contents[j] &gt;  lowValue &#123;</span><br><span class="line">            j -= 1//高位的 index - 1</span><br><span class="line">        &#125;</span><br><span class="line">        while contents[i] &lt; lowValue &#123;</span><br><span class="line">            i += 1</span><br><span class="line">        &#125;</span><br><span class="line">        if i &lt;= j  &#123;</span><br><span class="line">           contents.swapAt(i, j)</span><br><span class="line">            print(&quot;contenti--&gt;\(contents[i])&quot; +  &quot;和&quot; +  &quot; contentj--&gt;\(contents[j])&quot; + &quot;交换&quot;)</span><br><span class="line">            /*</span><br><span class="line">                交换完成后 i 向下一步</span><br><span class="line">                j 向前一步</span><br><span class="line">             */</span><br><span class="line">            i += 1</span><br><span class="line">            j -= 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;本轮排序结果:\n\(contents)&quot;)</span><br><span class="line">    print(&quot;\n----------下一轮分割线--------------&quot;)</span><br><span class="line">    print(&quot;low = \(low),high = \(high), i = \(i),j = \(j)&quot;)</span><br><span class="line">    if low &lt; j &#123;</span><br><span class="line">        print(&quot;\n----------左边--------------&quot;)</span><br><span class="line">        quicklySort(&amp;contents, low: low, high: j)</span><br><span class="line">    &#125;</span><br><span class="line">    if i &lt; high &#123;</span><br><span class="line">        print(&quot;\n----------右边--------------&quot;)</span><br><span class="line">        quicklySort(&amp;contents, low: i, high: high)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var arr2 = [7,32,2,1,5]</span><br><span class="line">print(&quot;初始化数组&quot;)</span><br><span class="line">print(arr2)</span><br><span class="line">quicklySort(&amp;arr2, low: 0, high: arr2.count - 1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">初始化数组</span><br><span class="line">[7, 32, 2, 1, 5]</span><br><span class="line"></span><br><span class="line">标志位</span><br><span class="line">2</span><br><span class="line">contenti--&gt;1和 contentj--&gt;7交换</span><br><span class="line">contenti--&gt;2和 contentj--&gt;32交换</span><br><span class="line">本轮排序结果:</span><br><span class="line">[1, 2, 32, 7, 5]</span><br><span class="line"></span><br><span class="line">----------下一轮分割线--------------</span><br><span class="line">low = 0,high = 4, i = 2,j = 1</span><br><span class="line"></span><br><span class="line">----------左边--------------</span><br><span class="line"></span><br><span class="line">标志位</span><br><span class="line">1</span><br><span class="line">contenti--&gt;1和 contentj--&gt;1交换</span><br><span class="line">本轮排序结果:</span><br><span class="line">[1, 2, 32, 7, 5]</span><br><span class="line"></span><br><span class="line">----------下一轮分割线--------------</span><br><span class="line">low = 0,high = 1, i = 1,j = -1</span><br><span class="line"></span><br><span class="line">----------右边--------------</span><br><span class="line"></span><br><span class="line">标志位</span><br><span class="line">7</span><br><span class="line">contenti--&gt;5和 contentj--&gt;32交换</span><br><span class="line">本轮排序结果:</span><br><span class="line">[1, 2, 5, 7, 32]</span><br><span class="line"></span><br><span class="line">----------下一轮分割线--------------</span><br><span class="line">low = 2,high = 4, i = 3,j = 3</span><br><span class="line"></span><br><span class="line">----------左边--------------</span><br><span class="line"></span><br><span class="line">标志位</span><br><span class="line">5</span><br><span class="line">contenti--&gt;5和 contentj--&gt;5交换</span><br><span class="line">本轮排序结果:</span><br><span class="line">[1, 2, 5, 7, 32]</span><br><span class="line"></span><br><span class="line">----------下一轮分割线--------------</span><br><span class="line">low = 2,high = 3, i = 3,j = 1</span><br><span class="line"></span><br><span class="line">----------右边--------------</span><br><span class="line"></span><br><span class="line">标志位</span><br><span class="line">7</span><br><span class="line">contenti--&gt;7和 contentj--&gt;7交换</span><br><span class="line">本轮排序结果:</span><br><span class="line">[1, 2, 5, 7, 32]</span><br><span class="line"></span><br><span class="line">----------下一轮分割线--------------</span><br><span class="line">low = 3,high = 4, i = 4,j = 2</span><br></pre></td></tr></table></figure><h5 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h5><ul><li>时间效率：O(nlog2n) —每趟确定的元素呈指数增加</li><li>空间效率：O（log2n）—递归要用到栈空间</li><li>稳 定 性： 不稳定   —可选任一元素为支点。</li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><h5 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h5><p>&emsp;每一趟在后面 n-i +1个中选出关键码最小的对象, 作为有序序列的第 i 个记录</p><h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><h5 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h5><ul><li>时间复杂度：O(n²)</li><li>空间复杂度：O(1)</li><li>不稳定</li></ul><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h5><ul><li>（1）将序列r[1..n] 建初堆，交换r[1]和r[n]，则r[n]为关键字最大的记录。</li><li>（2）将r[1..n-1]重新调整为堆，交换r[1]和r[n-1] ，则r[n-1]为关键字次大的记录。</li><li>（3）循环n-1次，直到交换了r[1]和r[2]为止，得到了一个非递减的有序序列r[1..n]。</li></ul><h5 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h5><ul><li>时间效率：O(nlog2n) </li><li>空间效率：O（1）</li><li>稳 定 性：不稳定</li></ul><p>==适用于n 较大的情况==</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/1/164f5d1796b0c479?w=95
      
    
    </summary>
    
      <category term="数据结构" scheme="http://www.wuchao.net.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.wuchao.net.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>自定义UIActionSheet</title>
    <link href="http://www.wuchao.net.cn/2018/06/18/%E8%87%AA%E5%AE%9A%E4%B9%89UIActionSheet/"/>
    <id>http://www.wuchao.net.cn/2018/06/18/自定义UIActionSheet/</id>
    <published>2018-06-18T02:37:40.000Z</published>
    <updated>2018-09-29T07:50:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>&emsp; 在开发中用过很多次 UIActionSheet ,有的设计师有自己的想法,用”iOS系统提供的有自己的样式,要不就用系统的样式吧”这样的理由人家根本不买账,来一句:”不行,还是按照我设计的样式来吧”。没办法，只有自己去自定义了。在维护的 APP 大改版时，有好几种不一样的样式，即使看上去一样的样式，有些细节也不一样，比如字体，有的是17号字有的是15号字。每一个选项的高有的是40p 有的是55p。 为了满足多种样式，只有自己定义了一个组件,自动布局要依赖 SnapKit.</p><h2 id="类之间的关系设计"><a href="#类之间的关系设计" class="headerlink" title="类之间的关系设计"></a>类之间的关系设计</h2><p>&emsp; 如果只是用语言描述,感觉总是苍白无力描述不清,为了让感兴趣的小伙伴迅速了解类与类之间的关系以及整体的架构,所以简单的画了张图,然后在解释下.</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/17/16409d0f41444d7b?w=1705&amp;h=539&amp;f=png&amp;s=108111" alt="类图"></p><p>&emsp; 首先说下JWCBaseContainer,这个类主要是一个 base 类,方便与有类似功能的子类继承使用父类的 API。</p><p><strong>功能：</strong></p><ol><li>提供列表的隐藏动画和弹出动画</li><li>处理点击列表空白处事件(隐藏列表)</li><li>提供屏幕旋转事件,供子类处理</li></ol><p>如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//显示/隐藏动画</span><br><span class="line">    func transAni(type:String ,subType:String,function:String) -&gt; CATransition &#123;</span><br><span class="line">        let animation = CATransition()</span><br><span class="line">        animation.timingFunction = CAMediaTimingFunction(name: function)</span><br><span class="line">        animation.duration = 0.3</span><br><span class="line">        animation.type = type</span><br><span class="line">        animation.subtype = subType</span><br><span class="line">        return animation</span><br><span class="line">    &#125;</span><br><span class="line">    // 透明度渐渐变淡动画</span><br><span class="line">    func opacityReduce_Animation(time : TimeInterval) -&gt; CABasicAnimation &#123;</span><br><span class="line">        let animation = CABasicAnimation(keyPath:&quot;opacity&quot;)</span><br><span class="line">        animation.fromValue = 1</span><br><span class="line">        animation.toValue = 0</span><br><span class="line">        animation.duration = time</span><br><span class="line">        animation.autoreverses = true</span><br><span class="line">        animation.isRemovedOnCompletion = true</span><br><span class="line">        animation.fillMode = kCAFillModeForwards</span><br><span class="line">        animation.timingFunction = CAMediaTimingFunction.init(name: kCAMediaTimingFunctionEaseIn)</span><br><span class="line">        return animation</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp; 其次,JWCActionSheetItem类,这个类是比较重要的类,主要供使用这配置ActionSheet 的 每一个 item 的样式,类似于我们常用的 tableView的数据 Model,主要可以配置每一个 item 的一下内容;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//标题</span><br><span class="line">  var title:String = &quot;&quot;</span><br><span class="line"> //标题颜色: 默认为黑</span><br><span class="line">  var titleColor:UIColor = UIColor.black</span><br><span class="line"> // 标题的字体,默认为14</span><br><span class="line">  var titleFont = UIFont.systemFont(ofSize: 14)</span><br><span class="line"> // item 的高度 默认为30</span><br><span class="line">  var height:Float = 30</span><br><span class="line"> //两个 item 的之间的分割线颜色 默认为灰色</span><br><span class="line">  var bottomLineColor:UIColor = UIColor.init(white: 0, alpha: 0.2)</span><br><span class="line"> //两个 item 的之间的分割线高度 默认为1</span><br><span class="line">  var bottomLineHeight:Float = 1.0</span><br><span class="line"> // item 的背景颜色</span><br><span class="line">  var backgroundColor:UIColor = UIColor.white</span><br></pre></td></tr></table></figure><p>为了方便使用,声明了两个便利构造函数,根据需要选择合适的便利构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convenience init(title:String,titleColor:UIColor,titleFont:UIFont,height:Float,bottomLineColor:UIColor,bottomLineHeight:Float,backgroundColor:UIColor)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convenience init(title:String,titleFont:UIFont,titleColor:UIColor,height:Float,bottomLineHeight:Float)</span><br></pre></td></tr></table></figure><p>&emsp; 再者,JWCActionSheetCell 类,此类功能比较简单,主要是在被赋值一个JWCActionSheetItem类型的数据源时,根据JWCActionSheetItem的内容来渲染自己的 UI</p><p>&emsp; 最后,JWCActionSheet 类。此类是前面几个类的应用与集成。提供两个类方法，方便使用：</p><ul><li style="list-style: none"><input type="checkbox"> JWCActionSheet中比较重要的几个方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/// 类方法1</span><br><span class="line">     ///</span><br><span class="line">     /// - Parameters:</span><br><span class="line">     ///   - titles: 数据源 String 类型</span><br><span class="line">     ///   - headView:headerView 如果没有则传 nil</span><br><span class="line">     /// - Returns: </span><br><span class="line">class func actionSheet(titles:[String],headView:UIView?) -&gt; JWCActionSheet &#123;</span><br><span class="line">        let action = JWCActionSheet.init(titles: titles, headView: headView)</span><br><span class="line">        return action</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中 headerView 是可选的，根据自己的需要，在外面生成一个继承自 UIView 的类传入即可。这个传入的参数是 String 类型的数组，因为此方法会生成一个默认样式的 ActionSheet ，主要是为了方便</p><ul><li style="list-style: none"><input type="checkbox" checked> 注意： ==headerView 传入时一定要有大小==</li></ul><p>第二个类方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/// 类方法2</span><br><span class="line">    ///</span><br><span class="line">    /// - Parameters:</span><br><span class="line">    ///   - items: 数据源 JWCActionSheetItem 类型的数组</span><br><span class="line">    ///   - headView: headerView 如果没有则传 nil</span><br><span class="line">    ///  </span><br><span class="line">    class func actionSheet(items:[JWCActionSheetItem],headView:UIView?) -&gt; JWCActionSheet &#123;</span><br><span class="line">       let action = JWCActionSheet.init(items: items, headView: headView)</span><br><span class="line">       return action</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个类方法和第一个类方法的区别之处就在于，传入的参数有区别，此类方法传入的是 JWCActionSheetItem 类型的数组，传入的JWCActionSheetItem 都是使用者根据自己的需要自己定义的。</p><ul><li style="list-style: none"><input type="checkbox" checked> 注意：如果默认的样式无法满足自己的需要则可以调用此方法</li></ul><p>JWCActionSheet的 show 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/// 弹出</span><br><span class="line">    ///</span><br><span class="line">    /// - Parameter callback: &lt;#callback description#&gt;</span><br><span class="line">    func show(callback:(ResultCallback?)) &#123;</span><br><span class="line">        resultCallback = callback</span><br><span class="line">        </span><br><span class="line">        var window: UIWindow! = UIApplication.shared.delegate?.window as? UIWindow</span><br><span class="line">        if window == nil &#123;</span><br><span class="line">            window = UIApplication.shared.keyWindow</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if window.isKind(of: UIWindow.self) &#123;</span><br><span class="line">            window.addSubview(self)</span><br><span class="line">            self.snp.makeConstraints &#123; (make) in</span><br><span class="line">                make.edges.equalTo(window)</span><br><span class="line">            &#125;</span><br><span class="line">            self.setNeedsLayout()</span><br><span class="line">            self.layoutIfNeeded()</span><br><span class="line">        &#125;</span><br><span class="line">        if tableView.isHidden &#123;</span><br><span class="line">            tableView.isHidden = false</span><br><span class="line">        &#125;</span><br><span class="line">        let trans = transAni(type: kCATransitionMoveIn, subType: kCATransitionFromTop, function: kCAMediaTimingFunctionEaseOut)</span><br><span class="line">        tableView.layer.add(trans, forKey: nil)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当生成JWCActionSheet的对象后，需要这是展示JWCActionSheet的时候调用，当发生选择点击事件时回走ResultCallback 闭包，可以在此闭包内处理选择事件</p><ul><li style="list-style: none"><input type="checkbox"> JWCActionSheet 内部逻辑处理</li></ul><ol><li><p>tableView 的高</p><p> tableView 的高根据每一个 Item 的高和底部下划线的高相加而得出</p></li><li><p>点击事件：<br>点击事件分为两种</p><p> (1) 点击ActionSheet空白处: 隐藏ActionSheet,回调出去的值为 index = -1 title = nil</p><p> (2) 选中某一个item 回调出去的值 index = 当前 item 的 index title 为当前 item 的 title</p></li><li><p>tableView 的 headerView: 在提供的对外初始化的两个方法中有 headerView 参数,如果没有则传入 nil 反之传入自定义的 headerView</p></li></ol><p> 附:使用例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// MARK: 默认样式</span><br><span class="line">   func style0() &#123;</span><br><span class="line">       JWCActionSheet.actionSheet(titles: [&quot;拍照&quot;,&quot;相册选取&quot;,&quot;取消&quot;],headView:nil).show &#123; (index, title) in</span><br><span class="line">           print(&quot;index:\(index),title:\(String(describing: title))&quot;)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// MARK: 添加头视图1</span><br><span class="line">    func style3() &#123;</span><br><span class="line">        </span><br><span class="line">        let headerView = UILabel.init(frame: CGRect.init(x: 0, y: 0, width: UIScreen.main.bounds.width, height: 35))</span><br><span class="line">            headerView.text = &quot;请选择获取照片的方式&quot;</span><br><span class="line">            headerView.textAlignment = .center</span><br><span class="line">            headerView.font = UIFont.systemFont(ofSize: 15)</span><br><span class="line">            headerView.textColor = UIColor.red</span><br><span class="line">            headerView.backgroundColor = UIColor.blue</span><br><span class="line">        JWCActionSheet.actionSheet(titles: [&quot;拍照&quot;,&quot;相册选取&quot;,&quot;取消&quot;], headView: headerView).show &#123; (index, title) in</span><br><span class="line">            print(&quot;index:\(index),title:\(String(describing: title))&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>几张效果图:</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/17/16409cccf8d194fa?w=744&amp;h=1316&amp;f=jpeg&amp;s=90237" alt="style0"></p><p><img src="https://user-gold-cdn.xitu.io/2018/6/17/16409cd23a03c58d?w=740&amp;h=1332&amp;f=jpeg&amp;s=93801" alt="style1"></p><p><img src="https://user-gold-cdn.xitu.io/2018/6/17/16409cd803a431a3?w=750&amp;h=1340&amp;f=jpeg&amp;s=101769" alt="style2"></p><p><img src="https://user-gold-cdn.xitu.io/2018/6/17/16409cdbd8279cdf?w=730&amp;h=1312&amp;f=jpeg&amp;s=100685" alt="style3"></p><p><img src="https://user-gold-cdn.xitu.io/2018/6/17/16409cdf02fe9d9f?w=748&amp;h=1316&amp;f=jpeg&amp;s=106310" alt="style4"></p><p><img src="https://user-gold-cdn.xitu.io/2018/6/17/16409ce297221a40?w=752&amp;h=1320&amp;f=jpeg&amp;s=101719" alt="style5"></p><h2 id="写在后面的话"><a href="#写在后面的话" class="headerlink" title="写在后面的话"></a>写在后面的话</h2><p>&emsp; 感觉这个小组件还是比较简单,也有一些缺点,比如其内部自动布局要依赖于 SnapKit。写出来的主要目的是不能让自己犯懒，如果一直拖着不写博客，时间久了，就很难再写了，会越来越懒。手动[Doge]</p><p> <a href="https://github.com/JiWuChao/ActionSheet.git" target="_blank" rel="noopener">Demo 在此</a></p><p>要养成随手点赞的好习惯 O(∩_∩)O~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;&amp;emsp; 在开发中用过很多次 UIActionSheet ,有的设计师有自己的想法,用”iOS系统提供的有自己的样式,要不就用系统的样式
      
    
    </summary>
    
      <category term="组件化" scheme="http://www.wuchao.net.cn/categories/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
    
      <category term="UI" scheme="http://www.wuchao.net.cn/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>TextField 输入身份证号手机号银行卡号格式化解决方案</title>
    <link href="http://www.wuchao.net.cn/2018/01/10/TextField%E8%BE%93%E5%85%A5%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E6%89%8B%E6%9C%BA%E5%8F%B7%E9%93%B6%E8%A1%8C%E5%8D%A1%E5%8F%B7%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%20/"/>
    <id>http://www.wuchao.net.cn/2018/01/10/TextField输入身份证号手机号银行卡号格式化解决方案 /</id>
    <published>2018-01-10T04:56:01.000Z</published>
    <updated>2018-09-29T07:50:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>TextField中输入身份证号，手机号，银行卡号时每隔几位需要添加空格。当输入错误时需要从末尾或者中间删除，删除之后还要保持当前textfield的中内容保持每隔几位就有一个空格的格式。这篇文章主要是为了解决这个问题</p></blockquote><p>==解决上面的问题主要要解决两个点:==</p><ul><li style="list-style: none"><input type="checkbox"> 光标的位置</li><li style="list-style: none"><input type="checkbox"> 空格的位置</li></ul><p>上面的两种情况又可以分为:</p><ul><li>从最后一位删除</li><li>从中间删除</li><li>一次删除一个和多个</li><li>从最后一位添加</li><li>从中间添加</li><li>一次添加一位和多位</li></ul><p>这几种情况都要考虑光标的位置和空格的位置,每次添加和删除都要重新计算.</p><h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><p><strong>首先</strong>详细说下👇的这个代理方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string</span><br></pre></td></tr></table></figure><h5 id="range"><a href="#range" class="headerlink" title="range"></a><strong>range</strong></h5><p>shouldChangeCharactersInRange ：有location 和length 两个参数<br>location 是即将被替代的内容的位置<br>length 是即将被替代的内容的长度</p><h5 id="string"><a href="#string" class="headerlink" title="string"></a><strong>string</strong></h5><p>用来替代在range位置内容的字符串 </p><ul><li style="list-style: none"><input type="checkbox" checked> 假如：textfield中有内容为1234</li></ul><p>三种情况解释下string 和range参数 ：</p><ol><li>光标在最后一位时删除一位 ：那么string就是为空 range的location 就是光标前面的内容的下标即为3  length就是1 表示被删除的内容长度为1 ，结果是string占据了range表示的位置 即123，3后面的4被空字符串占据了即被删除了</li><li>光标在最后一位删除两位：操作，长按textfield选中23，点击删除。可以发现string依旧为空 ，range变为 location=1, length=2 即位置在下标为1 长度为2的字符串被空字符串替代了，还剩1，所谓的23被删除了</li><li>添加一个：光标在最后一位。输入一个2，此时range：location为1，length为0 即被替代的内容位置在下标为1的地方，长度是空。string为2，那么结果就是一个下标为1，长度为0的字符串被string替代了，即textfield内容添加了一个2，复制到textfield中的内容range 和 string 也是同样的适用</li></ol><p>说的这么详细主要为下一步做准备。</p><h4 id="UITextInput协议-中的几个属性和方法"><a href="#UITextInput协议-中的几个属性和方法" class="headerlink" title="UITextInput协议 中的几个属性和方法"></a>UITextInput协议 中的几个属性和方法</h4><p>设置光标的位置需要下面的两个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 获取以fromPosition为基准偏移offset的光标位置。</span><br><span class="line">- (nullable UITextPosition *)positionFromPosition:(UITextPosition *)position offset:(NSInteger)offset;</span><br><span class="line">// 创建一个UITextRange</span><br><span class="line">- (nullable UITextRange *)textRangeFromPosition:(UITextPosition *)fromPosition toPosition:(UITextPosition *)toPosition;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox" checked> 设置光标位置的方法</li></ul><p>根据UITextInput协议的两个方法可以得出设置光标的位置的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (void)setCursorLocation:(UITextField *)textField withOffset:(NSInteger) offset&#123;</span><br><span class="line">    // offset 光标要所处的位置</span><br><span class="line">    // 生成新的postion</span><br><span class="line">    UITextPosition *newPostion = [textField positionFromPosition:textField.beginningOfDocument offset:offset] ;</span><br><span class="line">    //设置光标 从一个点到另外一个点如果两个点一样 那么光标就在这个点</span><br><span class="line">    textField.selectedTextRange = [textField textRangeFromPosition:newPostion toPosition:newPostion];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ==<strong>注意</strong>==：在textField中，有一个属性称之为selectedTextRange，这个属性为UITextRange类型，包含[start,end)两个值，通过实验可以发现，在没有文字被选取时，start 和 end的值一样 代表当前光标的位置；当有区域被选择时，start和end分别是选择的头和尾的光标位置 </p><p>可以看出 setCursorLocation 方法中很重要的一个参数是偏移量</p><ul><li style="list-style: none"><input type="checkbox" checked> 添加空格的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 在指定的位置添加空格</span><br><span class="line">+(NSString*)insertString:(NSString*)string withBlankLocations:(NSArray&lt;NSNumber *&gt;*)locations &#123;</span><br><span class="line">    if (!string) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    NSMutableString* mutableString = [NSMutableString stringWithString:[string stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;]];</span><br><span class="line">    for (NSNumber *location in locations) &#123;</span><br><span class="line">        if (mutableString.length &gt; location.integerValue) &#123;</span><br><span class="line">            [mutableString insertString:@&quot; &quot; atIndex:location.integerValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return  mutableString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个方法是根据传入的空格的位置,遍历整个字符串,在指定的位置为字符串添加一个空格. 这个方法调用的时机就是 textField 中的 text 发生改变时调用,比如说删除或者增加字符串</p><p> ++那么以下就根据不同的情况来计算偏移量设置光标 和 添加空格++</p><h3 id="删除字符串"><a href="#删除字符串" class="headerlink" title="删除字符串"></a>删除字符串</h3><h6 id="如何判断是点击了键盘的删除"><a href="#如何判断是点击了键盘的删除" class="headerlink" title="如何判断是点击了键盘的删除"></a>如何判断是点击了键盘的删除</h6><p>如上面所说 在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string</span><br></pre></td></tr></table></figure></p><p>这个代理方法中 当string为空时就是删除。range是一个位置表示string的位置 如果string为空时 range.length  表示删除的长度</p><ol><li>删除一位<br>如果 range.length == 1<br>如果string 为空 且 range的location 为当前textField.text的长度减一 即location是textField.text的最后一个字符时 表示在最后一位删除</li></ol><p>① 如果在最后一位删除一位不需要设置光标的位置和添加空格</p><p>② 如果不是最后一位删除一位则要判断删除的是不是空格。如果是空格则会连续删除两次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 不是最后一位</span><br><span class="line">                        NSInteger locationOffset = range.location;</span><br><span class="line">                        if (range.location &lt; text.length &amp;&amp; [text characterAtIndex:range.location] == &apos; &apos; &amp;&amp; [textField.selectedTextRange isEmpty]) &#123;</span><br><span class="line">                            [textField deleteBackward]; // 删除空格</span><br><span class="line">                            locationOffset --;</span><br><span class="line">                        &#125;</span><br><span class="line">                        [textField deleteBackward];// 删除空格前面的字符</span><br></pre></td></tr></table></figure><p>上面的代码调用了两次[textField deleteBackward] 删除了两次</p><p>此时需要修改空格的位置和光标的位置,偏移量 offset 就是 range.location 的值 ,每删除一位 offset 就要减1</p><ol start="2"><li>删除多位<br>同删除一位的逻辑一样 string为空切 range.length &gt; 1 就表示一次删除多位</li></ol><p>①  是否是在最后一位开始删除,如果再最后一位开始删除那么仍然不需要设置光标的位置,但是需要设置空格的位置</p><p>②  如果不是最后一位开始删除,则需要计算光标的位置,偏移量仍然是当前 range.location</p><h3 id="添加字符串"><a href="#添加字符串" class="headerlink" title="添加字符串"></a>添加字符串</h3><h6 id="如何判断是添加"><a href="#如何判断是添加" class="headerlink" title="如何判断是添加?"></a>如何判断是添加?</h6><p>如上面所说 在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string</span><br></pre></td></tr></table></figure></p><p>这个代理方法中 当string不为空时就是添加。range是一个位置表示string的位置 如果string不为空时 range.length  表示添加的字符串的长度</p><p>如果所输入的字符串长度还没有超出限制则直接添加到 textField 中然后在预定的位置添加空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 添加到textField 中 这个方法是 UIKeyInput 协议中的方法</span><br><span class="line">[textField insertText:string];</span><br><span class="line">//textField中的字符串发生变化需要重新设置空格</span><br><span class="line">textField.text = [self insertString:textField.text withBlankLocations:blankLocation];</span><br></pre></td></tr></table></figure><p>此时要计算偏移量 ,在计算是光标的位置是 range.location + string.length ,但是如果在光标位置出正好有空格则offset需要 +1  如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSInteger offset = range.location + string.length;</span><br><span class="line">            </span><br><span class="line">            for (NSNumber *location in blankLocation) &#123;</span><br><span class="line">                if (range.location == location.integerValue) &#123;</span><br><span class="line">                    offset ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            [self setCursorLocation:textField withOffset:offset];</span><br></pre></td></tr></table></figure><p>通过以上几种情况就可以解决文章开头描述的问题了.</p><p>Demo 在这里<br><a href="https://github.com/OlderChicken/TextField" target="_blank" rel="noopener">我是 Demo</a></p><p>如果解决了您的问题,请点赞支持下哈!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;TextField中输入身份证号，手机号，银行卡号时每隔几位需要添加空格。当输入错误时需要从末尾或
      
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.wuchao.net.cn/categories/Objective-C/"/>
    
    
      <category term="UI" scheme="http://www.wuchao.net.cn/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你高效快捷的创建Swift Framework</title>
    <link href="http://www.wuchao.net.cn/2018/01/07/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%AB%98%E6%95%88%E5%BF%AB%E6%8D%B7%E7%9A%84%E5%88%9B%E5%BB%BASwiftFramework/"/>
    <id>http://www.wuchao.net.cn/2018/01/07/手把手教你高效快捷的创建SwiftFramework/</id>
    <published>2018-01-07T02:26:00.000Z</published>
    <updated>2018-09-29T07:50:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章首发在简书 <a href="https://www.jianshu.com/p/51c5376c5a36" target="_blank" rel="noopener">手把手教你高效快捷的创建Swift Framework</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><p>&emsp;在我们开发中最离不开的就是 Framework 比如 UIKit.framework,所以对 framework 应该是比较熟悉的,那么在开发中也经常把自己的所做模块的代码做成 framework,场景如下:</p><ol><li>方便给别人使用我们自己的模块</li><li>提供给第三方使用,且又不愿意别人看到自己的内部实现逻辑</li><li>模块化提高代码的复用性 </li></ol><h3 id="动态库和静态库的区别"><a href="#动态库和静态库的区别" class="headerlink" title="动态库和静态库的区别"></a>动态库和静态库的区别</h3><h5 id="静态库："><a href="#静态库：" class="headerlink" title="静态库："></a>静态库：</h5><p>&emsp;链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。</p><h5 id="动态库："><a href="#动态库：" class="headerlink" title="动态库："></a>动态库：</h5><p>&emsp;链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别:"></a>区别:</h5><blockquote><p>静态库和动态库是相对编译期和运行期的：静态库在程序编译时会被链接到目标代码中，程序运行时将不再需要改静态库；而动态库在程序编译时并不会被链接到目标代码中，只是在程序运行时才被载入，因为在程序运行期间还需要动态库的存在。</p></blockquote><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><blockquote><p>同一个静态库在不同程序中使用时，每一个程序中都得导入一次，打包时也被打包进去，形成一个程序。而动态库在不同程序中，打包时并没有被打包进去，只在程序运行使用时，才链接载入（如系统的框架如UIKit、Foundation等），所以程序体积会小很多，但是苹果不让使用自己的动态库，否则审核就无法通过。</p></blockquote><p><strong>下面就一步一步的演示如何制作一个 framework, 以及制作自己的 framework 中可能会遇到的坑,以及如何解决。作为演示做个比较简单的数组乱序的 framework</strong></p><h4 id="新建一个-framework"><a href="#新建一个-framework" class="headerlink" title="新建一个 framework"></a>新建一个 framework</h4><ol><li>File -&gt; new -&gt; Progect-&gt; 选中 iOS -&gt; Cocoa Touch Framework</li></ol><p><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/1.png?raw=true" alt="第一步"></p><ol start="2"><li>点击 Next -&gt; Protect Name 为 ArrayDisorderSDK launguage 选为 Swift  点击 Next 新建完成</li></ol><p><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/2.png?raw=true" alt="image"></p><ol start="3"><li>在 Framework 中新建文件:<br>选 source 的时候 可以选择Cocoa Touch Class 或者Swift File 等 都是可以的可以根据自己的需要选择</li></ol><p><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/3.png?raw=true" alt="image"></p><p>类名就取为 ArrayDisorder，然后新建完成</p><p><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/4.png?raw=true" alt="image"></p><ol start="4"><li>在ArrayDisorder 类中写下数组乱序的代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">open class ArrayDisorder: NSObject &#123;</span><br><span class="line">    </span><br><span class="line">    open func disorder (orders:Array&lt;Any&gt;) -&gt; Array&lt;Any&gt; &#123;</span><br><span class="line">        var temp = orders</span><br><span class="line">        var count = Int(temp.count)</span><br><span class="line">        while count &gt; 0 &#123;</span><br><span class="line">            let index = Int(arc4random_uniform(UInt32(Int32(count))))</span><br><span class="line">            let last =  Int(count-1)</span><br><span class="line">            temp.swapAt(index, last)</span><br><span class="line">            count -= 1</span><br><span class="line">        &#125;</span><br><span class="line">        return temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox" checked> 注意：也许你会发现 在 class 前面或者在disorder方法前有 open 关键字，说到这里先说下和这个地方和oc 制作 Framework 不同的地方</li><li>oc 制作 framework 会生成一个和 framework 名字一样的类 只有.h 文件 内容如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//! Project version number for ArrayDisorderSDK.</span><br><span class="line">FOUNDATION_EXPORT double ArrayDisorderSDKVersionNumber;</span><br><span class="line"></span><br><span class="line">//! Project version string for ArrayDisorderSDK.</span><br><span class="line">FOUNDATION_EXPORT const unsigned char ArrayDisorderSDKVersionString[];</span><br><span class="line"></span><br><span class="line">// In this header, you should import all the public headers of your framework using statements like #import &lt;ArrayDisorderSDK/PublicHeader.h&gt;</span><br><span class="line">上面的这句注释说的很清楚 如果你想让别人外面找到你在 framework 中的类你必须像 &lt;ArrayDisorderSDK/PublicHeader.h&gt; 这种格式一样把 你的类导入这文件中</span><br></pre></td></tr></table></figure><p>最后一句 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// In this header, you should import all the public headers of your framework using statements like #import &lt;ArrayDisorderSDK/PublicHeader.h&gt;</span><br></pre></td></tr></table></figure><p>说的很清楚如果你想让别人外面找到你在 framework 中的类你必须像 &lt;ArrayDisorderSDK/PublicHeader.h&gt; 这种格式一样把 你的类导入这文件中,在编译成 SDK 之后生成的头文件中就可以看到你对外开放的类和方法</p><p>创建 Swift framework也会生成一个这样的文件但是 则不需要这样导入头文件。只需要在要暴露给使用者的类名和方法名前面写上 Open 或者 Public 当编译成 Framework 之后会生成 “你的 framework 的名字-Swift.h”的文件 在这个文件中你可以看到类名前面 表有 Public 或者 Open 关键字的类.</p><p>什么时候用 Open 什么时候用 Public?</p><ol><li><p>Open 在作用域外是可以被访问,继承 ,用 Open 关键字修饰的开放类成员在作用域之外是可访问和可覆盖的。</p></li><li><p>Pubic 在作用域外是可访问的，但在作用域之外没有子类。公共类成员是可访问的，但在作用域之外是不可覆盖的。</p></li></ol><h4 id="配置你的-Framework"><a href="#配置你的-Framework" class="headerlink" title="配置你的 Framework"></a>配置你的 Framework</h4><ol><li>配置动态或者静态库</li></ol><p>点击 framework 的 target build settings - linking -&gt; Mach-o Type  -&gt; Static Library<br> 或者 Dynamic Library </p><ol start="2"><li>Development Target  </li></ol><p>在这个 Demo 中 设置为支持 iOS 8</p><p> <img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/8.png?raw=true" alt="image"></p><ol start="3"><li>还要配置 运行编译的成的 Build Configuration 为 release 如果不是 release 则在 release 环境下运行会出错</li></ol><p>走到这一步,基本 Framework 已经初步完成, Com + B   </p><ul><li style="list-style: none"><input type="checkbox" checked> 注意:编译的时候 选择的 Device 如果是模拟器 则生成的是 x86架构,仅支持模拟器,在真机上这个编译的 Framework 则不能用 ,如果 Device 不选或者选择你连接在电脑上的真机,则编译成的是arm64 可以在真机上跑但是不能用在模拟器,如果制作的 framework 需要在模拟器和真机上用,则需要把这两个架构合成一块,这个==待会下面详细讲.==</li></ul><p><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/9.png?raw=true" alt="image"></p><p>点击生成的 Framework 然后 Show In Finder </p><p><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/10.png?raw=true" alt="image"></p><p>如图中所示,生成了ArrayDisorderSDK.framework 那么这个文件就可以直接给别人使用了.</p><h2 id="调试-Framework"><a href="#调试-Framework" class="headerlink" title="调试 Framework"></a>调试 Framework</h2><p>在我们写代码时一般都习惯于边写边调试,那么在制作 Framework 时有两种方法调试我们的 Framework</p><h3 id="第一种-不推荐"><a href="#第一种-不推荐" class="headerlink" title="第一种(不推荐)"></a>第一种(不推荐)</h3><p>新建一个名字是 testArrayDisorderDemo的 Progect 如下</p><p><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/11.png?raw=true" alt="image"></p><p>直接把编译好的 Framework 拖入到 testArrayDisorderDemo中</p><p><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/12.png?raw=true" alt="image"></p><p>然后 import ArrayDisorderSDK</p><p>在 ViewDidLoad 中写入如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let disOrder = ArrayDisorder() //Framework 中的封装了乱序功能的类</span><br><span class="line">      //disOrder.disorder(orders: [1,2,3,4,5,6,7,8,9]) 调用ArrayDisorder 对外公布的类</span><br><span class="line">      print(disOrder.disorder(orders: [1,2,3,4,5,6,7,8,9]))</span><br><span class="line">      // 输出:[8, 6, 2, 5, 3, 4, 7, 9, 1]</span><br></pre></td></tr></table></figure><p>到此,我们简单的 framework 就可以算完成了.</p><p>但是这中调试framework 的方法效率比较低,我们每一次调试都需要重新把原来的 framework 从testArrayDisorderDemo中删除然后重新导入.这样比较麻烦.那么下面有一种比较方便高效的方法。</p><h3 id="第二种-创建一个依赖工程-推荐"><a href="#第二种-创建一个依赖工程-推荐" class="headerlink" title="第二种 创建一个依赖工程(推荐)"></a>第二种 创建一个依赖工程(推荐)</h3><p>还是testArrayDisorderDemo 这个测试 Framework 的工程</p><p>如图所示<br><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/14.png?raw=true" alt="image"> 两者都在桌面上</p><p>然后把ArrayDisorderSDK 拖入到testArrayDisorderDemo 文件中 如图<br><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/15.png?raw=true" alt="image"></p><p>然后打开testArrayDisorderDemo </p><p> – &gt; General -&gt;Embedded Binaries-&gt; 点击加号-&gt; add Other -&gt; 选中ArrayDisorderSDK.xcodeproj</p><p>如下图<br><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/16.png?raw=true" alt="image"><br><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/17.png?raw=true" alt="image"><br><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/18.png?raw=true" alt="image"></p><p>再选择 Target 的地方你会发现 现在已经有连个 Taeget 一个是testArrayDisorderDemo  一个是ArrayDisorderSDK</p><p>如果选中 testArrayDisorderDemo就是运行 Demo 如果选中ArrayDisorderSDK 就是编译 SDK </p><p>这时你会发现可以直接在testArrayDisorderDemo 的 ViewController 中直接 导入ArrayDisorderSDK就可以了 不需要在删除然后再拖入了. 最重要的是 ,当你选中的testArrayDisorderDemo Tagret 运行的时候 当程序走到 framework 中去的时候 你还可以打断点等方式调试. 效率会很高.</p><ul><li style="list-style: none"><input type="checkbox" checked> 注意: 当你修改 framework 中的代码时要想测试下修改的效果,你必需先编译下你的 framework 的 target 如本文中所示的就要先编译下ArrayDisorderSDK的 target,不编译的话就相当于你的 测试你 framework 的 Demo 用的还是原来的 framework 而不是修改后的</li></ul><h2 id="关于-Framework-的CPU架构"><a href="#关于-Framework-的CPU架构" class="headerlink" title="关于 Framework 的CPU架构"></a>关于 Framework 的CPU架构</h2><p>CPU 的架构在不同的机型上有不同的<br>主要有一下:</p><p>arm7: 在最老的支持 iOS7的设备上使用<br>arm7s: 在 iPhone 5 和 iPhone 5c 上使用<br>arm64: 在 iPhone 5s 的64位 ARM 处理器上<br>i386: 在32位模拟器上使用<br>x86_64: 在64位模拟器上使用</p><p>当然一个 Framework 不需要全部支持,可以根据需要.</p><p>如上文所说, 编译的时候 选择的 Device 如果是模拟器 则生成的是 x86架构,仅支持模拟器,在真机上这个编译的 Framework 则不能用 ,如果 Device 不选或者选择你连接在电脑上的真机,则编译成的是arm64 和 arm7 可以在真机上跑但是不能用在模拟器,如果制作的 framework 需要在模拟器和真机上用,则需要把这两个架构合成一块,那么这就需要合成架构了.</p><p>首先,我们要了解,如何查看一个 framework 的架构 </p><p> 用命令: lipo -info </p><ul><li style="list-style: none"><input type="checkbox" checked> 注意 -info 中 - 和 info 没有空格,info 后面有一个空格</li></ul><p>如图所示<br><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/20.png?raw=true" alt="image"></p><p>把ArrayDisorderSDK 文件拖入控制台 然后回车<br>控制台就可以输出ArrayDisorderSDK 的 CPU 架构 如 armv7 arm64</p><p><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/21.png?raw=true" alt="image"><br><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/22.png?raw=true" alt="image"></p><p>这个是支持真机的,如果支持模拟器则不行的,需要重新编译:</p><p>在上图中也能看到 当选中ArrayDisorderSDK.framework show in Finder 时你会发现在上一层有四个文件夹(最多为四个如果你只在 relesae 下真机上编译 就只有一个文件夹) ,主要分为 Debug 和 release 两种环境下的 真机和模拟器<br>Debug-iphoneos/ Debug-iphonesimulator Debug 下的模拟器<br>Release-iphoneos/Release-iphonesimulator relesase 下的真机和模拟器</p><p>那么我们需要做的就是把Release-iphoneos/Release-iphonesimulator 下的两种架构合成一个</p><h3 id="架构合并"><a href="#架构合并" class="headerlink" title="架构合并:"></a>架构合并:</h3><h4 id="第一种方法-不推荐"><a href="#第一种方法-不推荐" class="headerlink" title="第一种方法(不推荐)"></a>第一种方法(不推荐)</h4><p>用命令: lipo -create xx ## -output @@<br>加入你framework 的名字是 ArrayDisorderSDK</p><p>xx: 表示Release-iphoneos 文件夹下的 ArrayDisorderSDK.framework/ArrayDisorderSDK 的路径</p><p>##: Release-iphonesimulator 文件夹下的 ArrayDisorderSDK.framework/ArrayDisorderSDK</p><p>##: 生成的文件名 是和你的 framework 同名的,比如叫ArrayDisorderSDK</p><p>生成的output 出来的ArrayDisorderSDK是需要把Release-iphoneos 文件夹下的 ArrayDisorderSDK.framework 的中的ArrayDisorderSDK 替换掉的.</p><ul><li style="list-style: none"><input type="checkbox" checked> 注意:-create 以及-output 在 create 和 output前面以- 是没有空格,但是在create 和 output后面是有一个空格的</li></ul><p>上面说的可能不太好懂,那么下面演示一下,化繁为简:<br>如图<br><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/23.png?raw=true" alt="image"></p><p>总之这种方法还是太麻烦的,容易出错,下面介绍另外一种比较简单的.</p><h4 id="第二种-推荐"><a href="#第二种-推荐" class="headerlink" title="第二种:(推荐)"></a>第二种:(推荐)</h4><ol><li>选中ArrayDisorderSDK.xcodeproj 新建一个名字为UniversalArrayDisorder 的 target<br><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/24.png?raw=true" alt="image"><br><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/25.png?raw=true" alt="image"><br><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/26.png?raw=true" alt="image"></li><li>选中 UniversalArrayDisorder –&gt; Build Phases –&gt; 选中加号 –&gt; 选中 New Run Script Phase<br><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/27.png?raw=true" alt="image"><br><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/28.png?raw=true" alt="image"></li></ol><p>然后在 <a href="https://gist.github.com/cromandini/1a9c4aeab27ca84f5d79" target="_blank" rel="noopener">脚本地址</a>       </p><p>下载一个名为universal-framework.sh 文件 把文件内容拷贝到如图所示<br><img src="https://github.com/JiWuChao/swiftExercise/blob/master/picture/29.png?raw=true" alt="image"></p><ul><li style="list-style: none"><input type="checkbox" checked> 注意:universal-framework.sh 中 ${PROJECT_NAME}  要把这个换成你自己的 framework 的名字</li></ul><p>设置完成之后 ,编译UniversalArrayDisorder target 编译成功之后,会自动打开一个生成 Framework 的文件夹,然后再查看架构信息你会发现,即支持真机也支持模拟器啦.</p><h2 id="你可能会遇到的坑"><a href="#你可能会遇到的坑" class="headerlink" title="你可能会遇到的坑"></a>你可能会遇到的坑</h2><h5 id="1-找不到-framework"><a href="#1-找不到-framework" class="headerlink" title="1 找不到 framework"></a>1 找不到 framework</h5><p> <strong>错误提示</strong>: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No such module xxx</span><br></pre></td></tr></table></figure><p> <strong>解决</strong>:</p><blockquote><p>原因就是 Framework Search Path 中的路径错了 可以参考 <a href="https://stackoverflow.com/questions/29500227/getting-error-no-such-module-using-xcode-but-the-framework-is-there" target="_blank" rel="noopener">参考地址</a> 解决方案手动设置 这个路径是你向引用你的 framework 的项目拖自定义的 framework 时自动生成的 所以简单的解决方案就是 删除 framework 重新拖入 注意:拖的时候一定要确保 framework 和目标项目在同一个文件夹下,这样就不会出问题了</p></blockquote><h5 id="2-找不到类"><a href="#2-找不到类" class="headerlink" title="2 找不到类"></a>2 找不到类</h5><p> <strong>错误提示</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;xxxx&apos; is unavailable: cannot find Swift declaration for this class</span><br><span class="line"> xxxx 表示 framework 中的类名</span><br></pre></td></tr></table></figure><p> <strong>解决</strong>: </p><blockquote><p>framework 的架构错误: 如果如你的 framework 需要在模拟器上跑 那么你的 framework 必须包含x86<br> 如果还需要在真机上跑 那么必须包含arm64 架构 可以用命令检查架构 lipo -info <a href="https://stackoverflow.com/questions/29851550/myclass-is-unavailable-cannot-find-swift-declaration-for-this-class-release-b" target="_blank" rel="noopener">参考</a></p></blockquote><h5 id="3-动态库和静态库的问题"><a href="#3-动态库和静态库的问题" class="headerlink" title="3  动态库和静态库的问题"></a>3  动态库和静态库的问题</h5><p> <strong>错误提示:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reason: image not found</span><br><span class="line"> Message from debugger: Terminated due to signal 6</span><br></pre></td></tr></table></figure><p><strong>解决</strong>: </p><blockquote><p>动态库 embedded binaries没有 添加 your framework name.framework -&gt; 添加<br> 如果是静态库 则不需要添加</p></blockquote><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后:"></a>写在最后:</h3><p>参考文献:</p><p>1 :<a href="https://medium.com/flawless-app-stories/getting-started-with-reusable-frameworks-for-ios-development-f00d74827d11" target="_blank" rel="noopener">https://medium.com/flawless-app-stories/getting-started-with-reusable-frameworks-for-ios-development-f00d74827d11</a></p><p>2 :<a href="https://medium.com/captain-ios-experts/develop-a-swift-framework-1c7fdda27bf1" target="_blank" rel="noopener">https://medium.com/captain-ios-experts/develop-a-swift-framework-1c7fdda27bf1</a></p><p>3 :<a href="https://www.raywenderlich.com/65964/create-a-framework-for-ios" target="_blank" rel="noopener">https://www.raywenderlich.com/65964/create-a-framework-for-ios</a></p><blockquote><p>本文是在我开发中遇到的问题的一个总结,总体倾向与如何更方便高效的创建自己的 framework,对于 OC 和 Swift 创建 framework 的异同介绍较少,由于本文重点不在于此,有机会下次再总结. 由于工作繁忙,水平有限,难免有不全,或者说的不合适的地方,还请看到此文章的朋友不吝赐教.或者你对本文中有不理解的地方,都希望在评论区交流. 如果此文解决了你的问题,还请点赞支持下。</p></blockquote><p> <a href="https://github.com/JiWuChao/swiftExercise/tree/master/testArrayDisorderDemo" target="_blank" rel="noopener">Demo地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章首发在简书 &lt;a href=&quot;https://www.jianshu.com/p/51c5376c5a36&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;手把手教你高效快捷的创建Swift Framework&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="组件" scheme="http://www.wuchao.net.cn/categories/%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="Framework" scheme="http://www.wuchao.net.cn/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>collectionView无限轮播设计思路</title>
    <link href="http://www.wuchao.net.cn/2017/08/20/collectionView%E6%97%A0%E9%99%90%E8%BD%AE%E6%92%AD%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/"/>
    <id>http://www.wuchao.net.cn/2017/08/20/collectionView无限轮播设计思路/</id>
    <published>2017-08-20T02:29:35.000Z</published>
    <updated>2018-09-29T07:50:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="collectionView-无限轮播设计思路"><a href="#collectionView-无限轮播设计思路" class="headerlink" title="collectionView 无限轮播设计思路"></a>collectionView 无限轮播设计思路</h2><p>原来用scrollview实现过无限轮播，每张轮播图是UIImageView<br>，有页码，有标题，用scrollView实现起来比较简单。但是最近遇到一个需求<br>。每个轮播图上有好几个头像和按钮，用目前项目中用scrollView实现的轮播<br>图实现不了，或者说改动比较大。于是就想着用collectionView实现。当时的<br>初步构想就是每张轮播图就是一个自定义的cell ，这样就比较简单了。<br>在没开始之前先在在网上找了一下，好多demo实现的方式都是一样的，就是把dataSource设为一个很大的数字，创建n多个cell，用来达到无限。。。按道理，先不说性能如何，就是设为比较大的数字，在理论上该数字也是有限的！并不是无限轮播~~~</p><p>我的大致设计思路如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1，定时器。用于在固定的间隔滚动一页</span><br><span class="line">2，collectionView，自定义一个cell用于轮播展示</span><br><span class="line">3，对collectionView的数据源A进行处理。新建一个数组B，把A数组的最后一个添加到B数组的第一个，把A数组的第一个添加到B数组的最后一个。这样B数组中就比源数组A多了两个数据。在(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section 中返回的是数组B的长度</span><br><span class="line">4， 在scrollview的相关代理方法中处理相应人为拖动操作和滚动</span><br></pre></td></tr></table></figure><p>下面结合代码来说每步的具体实现。</p><p>1&gt; 每隔固定的时间调用此方法实现滚动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)startScrollAutomtically &#123; // 每次加 self.bounds.size.width 宽度</span><br><span class="line">    [self setContentOffset:CGPointMake(self.contentOffset.x + self.bounds.size.width, self.contentOffset.y) animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2&gt; 对数据源进行处理  如果原始数据源的长度大于一个则启动定时器，反之不启动定时器。如果原始数据源的长度大于一个则需要处理数据源，即上面3所说的。另外刷新完数据源则默认滚动到第一页</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)configWithData:(NSArray&lt;id&lt;JWCBannerDataProtocol&gt;&gt; *)datas &#123;</span><br><span class="line">    if (_originalData.count &gt; 1) &#123;</span><br><span class="line">        NSMutableArray *tempArr = [[NSMutableArray alloc] initWithArray:_originalData];</span><br><span class="line">        [tempArr insertObject:[_originalData lastObject] atIndex:0];</span><br><span class="line">        [tempArr addObject:[_originalData firstObject]];</span><br><span class="line">        self.customData = tempArr.copy;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [self scrollToPage:1 animated:YES];</span><br><span class="line">        &#125;);</span><br><span class="line">        [self startTimer];</span><br><span class="line">        self.isOnlyOne = NO;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        self.customData = _originalData.copy;</span><br><span class="line">        [self stopTimer];</span><br><span class="line">        self.isOnlyOne = YES;</span><br><span class="line">        self.currentIndex = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3&gt; scrollView的几个代理方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 将要开始拖拽 停止定时器</span><br><span class="line">- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView &#123;</span><br><span class="line">    [self stopTimer];</span><br><span class="line">&#125;</span><br><span class="line">// 将要停止拖拽 开始定时器</span><br><span class="line">- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset &#123;</span><br><span class="line">    if (_originalData.count &gt; 1) &#123; //如果数据源大于1 才启动定时器</span><br><span class="line">        [self startTimer];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 停止拖动</span><br><span class="line">- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123;</span><br><span class="line">    [self checkPageIndx];</span><br><span class="line">&#125;</span><br><span class="line">// 动画停止</span><br><span class="line">- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView &#123;</span><br><span class="line">    [self checkPageIndx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 此方法是人为拖动完成需要做的处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)checkPageIndx &#123;</span><br><span class="line">    //当滚动到最后一张图片时，继续滚向后动跳到page 1</span><br><span class="line">    if (self.contentOffset.x &gt;= (self.customData.count - 1) * self.bounds.size.width) &#123;</span><br><span class="line">        [self scrollToPage:1 animated:NO];</span><br><span class="line">    &#125;</span><br><span class="line">    //当滚动到第一张图片时，继续向前滚动跳到倒数第二</span><br><span class="line">    if (self.contentOffset.x &lt; 0) &#123;</span><br><span class="line">        [self scrollToPage:self.customData.count - 2 animated:NO];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 停止滚动 计算当前的index   此方法是无论人为还是自动改变scrollview的 offset 都会调用此方法 所以在此方法中计算当前的index 这个index可用于显示页码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;</span><br><span class="line">    CGFloat width = self.frame.size.width;</span><br><span class="line">    NSInteger index = (scrollView.contentOffset.x + width * 0.5 ) / width;</span><br><span class="line">    if (index == 0) &#123;</span><br><span class="line">        index = _originalData.count - 1;</span><br><span class="line">    &#125; else if (index &gt;= _customData.count - 1) &#123;</span><br><span class="line">        index = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        index = index - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    self.currentIndex = index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;以上只是写了大致的思路，具体的实现代码在 <a href="https://github.com/JiWuChao/bannerView.git" target="_blank" rel="noopener">Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;collectionView-无限轮播设计思路&quot;&gt;&lt;a href=&quot;#collectionView-无限轮播设计思路&quot; class=&quot;headerlink&quot; title=&quot;collectionView 无限轮播设计思路&quot;&gt;&lt;/a&gt;collectionView 无限
      
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.wuchao.net.cn/categories/Objective-C/"/>
    
    
      <category term="UI" scheme="http://www.wuchao.net.cn/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>自定义collocationViewLayout实现瀑布流</title>
    <link href="http://www.wuchao.net.cn/2017/08/07/%E8%87%AA%E5%AE%9A%E4%B9%89collocationViewLayout%E5%AE%9E%E7%8E%B0%E7%80%91%E5%B8%83%E6%B5%81/"/>
    <id>http://www.wuchao.net.cn/2017/08/07/自定义collocationViewLayout实现瀑布流/</id>
    <published>2017-08-07T01:22:48.000Z</published>
    <updated>2018-09-29T07:50:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;实现瀑布流简单，实现分区瀑布流，并且每个区的瀑布流的列数不一样且有区头和区尾，就不是太容易了。我嫌麻烦不愿意自己写（——&gt;我承认懒，不愿意动脑子 <em>V</em>）开始在网上找了好多，都是仅仅一个区的瀑布流，没区头和区尾，完全满足不了我的需求。没办法，产品的需求在那，不能不做吧，于是自己静下心来开始写。</p><p>其代理方法和属性模仿UICollectionViewFlowLayout 所写，使用方法和UICollectionViewFlowLayout类似</p><p>功能描述：</p><ol><li><p>满足UICollectionViewFlowLayout提供的普通的线性布局和网格布局</p></li><li><p>满足单区和多区的瀑布流布局。</p></li><li><p>满足多区瀑布流时每个区的列数可以不同</p></li><li><p>满足设置header和footer</p></li><li><p>满足设置header和footer的间距</p></li></ol><p><em>注意</em>：本文不涉及到装饰视图的相关代理方法以及计算。</p><p>首先要明白的事情：collectionView与collocationViewLayout的关系。</p><p>collocationView负责展示，collectionviewLayout负责提供如何展示，包括cell的大小位置，header和footer的大小位置等，UICollectionViewFlowLayout 继承自UICollectionViewLayout是苹果公司封装好的layout，可以实现简单的网格和线性布局，当cell的大小和间距一样时可以用UICollectionViewFlowLayout，如果要实现比较复杂的布局，就需要自定义了。</p><p>其次，要了解UICollectionViewLayoutAttributes 类的属性，以下是每一个cell的属性，都是通过UICollectionViewLayoutAttributes属性体现出来的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CGRect frame; // cell的大小已经x，y值</span><br><span class="line"></span><br><span class="line">CGPoint center;//cell的中心点</span><br><span class="line"></span><br><span class="line">CGSize size;// cell的size</span><br><span class="line"></span><br><span class="line">CATransform3D transform3D;// cell的3D旋转</span><br><span class="line"></span><br><span class="line">CGRect bounds NS_AVAILABLE_IOS(7_0);</span><br><span class="line"></span><br><span class="line">CGAffineTransform transform NS_AVAILABLE_IOS(7_0); // cell 的旋转</span><br><span class="line"></span><br><span class="line">CGFloat alpha;//alp值</span><br><span class="line"></span><br><span class="line">NSInteger zIndex; // default is 0 //z轴</span><br><span class="line"></span><br><span class="line">getter=isHidden) BOOL hidden; // As an optimization,</span><br></pre></td></tr></table></figure><p>还有，要理解UICollectionViewLayout的几个方法：</p><ol><li><p>prepareLayout ：是专门用来准备布局的，在prepareLayout方法里面我们可以事先就计算后面要用到的布局信息并存储起来，防止后面方法多次计算，提高性能。例如，我们可以在此方法就计算好每个cell的属性、整个CollectionView的内容尺寸等等。此方法在布局之前会调用一次，之后只有在调用invalidateLayout、shouldInvalidateLayoutForBoundsChange:返回YES和UICollectionView刷新的时候才会调用。</p></li><li></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath</span><br></pre></td></tr></table></figure><p> 返回对应的indexPath的cell的attributes</p><ol start="3"><li></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(UICollectionViewLayoutAttributes *)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath</span><br></pre></td></tr></table></figure><p> 返回对应的header和footer的attributes</p><p>4.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (CGSize)collectionViewContentSize</span><br></pre></td></tr></table></figure><p> ；<br>collectionView的size 这个size不是可视范围的size是整个collectionView的size</p><ol start="5"><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect</span><br></pre></td></tr></table></figure><p>返回在rect范围内所有cell footer和head的attribute</p></li></ol><p>了解以上的几点就可以开始计算了。计算的顺序是从上到下，即从区头到每个区的cell再到区尾</p><p>设置一些数组用于存储计算好的值：如下</p><p>//存放attribute的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSMutableArray *attrsArray;</span><br><span class="line"></span><br><span class="line">//存放当前区中各个列的当前的高度</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSMutableArray *columnHeights;</span><br><span class="line"></span><br><span class="line">//collectionView的Content的高度</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) CGFloat contentHeight;</span><br><span class="line"></span><br><span class="line">//记录每个区最高的</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) CGFloat lastContentHeight;</span><br><span class="line"></span><br><span class="line">//每个区的区头和上个区的区尾的距离</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) CGFloat spacingWithLastSection;</span><br></pre></td></tr></table></figure><p>首先是重写 prepareLayout方法，也是最重要的一步。在此方法中完成初始化。所有的计算都置为零。</p><p><strong>第一步</strong>：通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.collectionView numberOfSections]</span><br></pre></td></tr></table></figure><p> 方法获取collectionView中一共有几个区。设置一个for循环。</p><p><strong>第二步</strong>：通过 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (UICollectionViewLayoutAttributes *)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath</span><br></pre></td></tr></table></figure><p> 获取每个header的属性。计算完成之后把attributes添加到attrsArray 数组中 ，同时还有根据sectionInsets 等参数改变contentHeight 的高度</p><p><strong>第三步</strong>: 设置区头完成之后，在循环中根据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.collectionView numberOfItemsInSection:i]</span><br></pre></td></tr></table></figure></p><p> 获取相应的区有多少个cell</p><p>在这一步中计算是最麻烦的。可以分为如下步骤：</p><ol><li>计算每一个cell的frame。 根据此区中一共有几列和屏幕的宽度，以及每个cell的之间的间距，计算出每个cell的宽度，因为高度是外面传过来的，所以高度不需要计算 。那么还需要知道cell的x值和y值。</li></ol><p>x值：首先取出当前区的中哪一列最低。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSInteger tempMinColumn = 0; //默认第 0 列最小</span><br><span class="line"></span><br><span class="line">CGFloat minColumnHeight = [self.columnHeights[0] doubleValue]; //</span><br></pre></td></tr></table></figure><p> 取出最小的那一列的高度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for (NSInteger i = 0; i &lt; self.columnCount; i ++) &#123;</span><br><span class="line"></span><br><span class="line">CGFloat columnH = [self.columnHeights[i] doubleValue];</span><br><span class="line"></span><br><span class="line">if (minColumnHeight &gt; columnH) &#123;</span><br><span class="line"></span><br><span class="line">minColumnHeight = columnH;</span><br><span class="line"></span><br><span class="line">tempMinColumn = i;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tempMinColumn 就是最小的那一列</p><p>x值就可以根据sectionInsets ， 每个cell的左右间距，和cell的宽度算出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGFloat cellX = self.sectionInsets.left + tempMinColumn * (cellWeight + self.interitemSpacing);</span><br></pre></td></tr></table></figure><p>y值：上面已经求出高度最小的那一列，以及最小的那一列的高度。</p><p>y值就 cellY = minColumnHeight</p><p>注意：//如果cell的y值不等于上个区的最高的高度 即不是此区的第一列 要加上此区的每个cell的上下间距</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (cellY != self.lastContentHeight) &#123;</span><br><span class="line"></span><br><span class="line">cellY += self.lineSpacing;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;&#125;</span><br></pre></td></tr></table></figure><p>这样就可以知道了 cell的frame了， 即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attributes.frame = CGRectMake(cellX, cellY, cellWeight, cellHeight);</span><br></pre></td></tr></table></figure><ol start="2"><li>要更新 contentHeight （当前collectionView的内容的高度） 和columnHeights（当区的每列的高度或者说每列的最后一个cell的y值 + height）</li></ol><p>那么这样相应cell的值就计算完毕 ，在此函数返回值处添加到attrsArray 中去。</p><p>第四部：同header的计算方式一样 在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (UICollectionViewLayoutAttributes *)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath</span><br></pre></td></tr></table></figure><p> 计算footer的frame</p><p>一共多少个区 ，每个区的header的frame是多少，每个区中有多少个cell 每个cell的frame是多少 ，每个区的footer的frame是多少，以此循环计算出所有的attributes，在- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect 返回计算的attributes</p><ul><li style="list-style: none"><input type="checkbox" checked> 注意 ：在计算每个attributes时 collectionView的内容的高度即contentHeight collectionView上个区的最高的那一列的高度即lastContentHeight 都在改变。</li></ul><p>在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (CGSize)collectionViewContentSize &#123;</span><br><span class="line"></span><br><span class="line">return CGSizeMake(self.collectionView.frame.size.width, self.contentHeight);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中返回collectionView ContentSize 完成布局。</p><p>为了支持扩展性和易用性，我完全模仿 UICollectionViewFlowLayout 的用法设置代理方法和属性。至于其使用方法，和UICollectionViewFlowLayout 一样的。代理方法和属性如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, weak) id delegate;</span><br><span class="line"></span><br><span class="line">// 区的sectionInsets</span><br><span class="line"></span><br><span class="line">@property (nonatomic,assign) UIEdgeInsets sectionInsets;</span><br><span class="line"></span><br><span class="line">//每个区的列数</span><br><span class="line"></span><br><span class="line">@property (nonatomic,assign) NSInteger columnCount;</span><br><span class="line"></span><br><span class="line">// 每个cell的上下间距</span><br><span class="line"></span><br><span class="line">@property (nonatomic,assign) CGFloat lineSpacing;</span><br><span class="line"></span><br><span class="line">//每个cell的左右间距</span><br><span class="line"></span><br><span class="line">@property (nonatomic,assign) CGFloat interitemSpacing;</span><br><span class="line"></span><br><span class="line">//header的size</span><br><span class="line"></span><br><span class="line">@property (nonatomic,assign) CGSize headerReferenceSize;</span><br><span class="line"></span><br><span class="line">// footer的size</span><br><span class="line"></span><br><span class="line">@property (nonatomic,assign) CGSize footerReferenceSize;</span><br></pre></td></tr></table></figure><p>上述的这些参数 如果每个区都一样，则可以在layout初始化的时候设置，如过每个区的参数设置都不一样，比如第一个区是两列，第二个区是一列，不用担心，用代理。</p><p>代理方法支持分区设置这些参数。</p><p>@protocol JWCCustomLayoutDelegate</p><h6 id="required"><a href="#required" class="headerlink" title="@required"></a>@required</h6><p>// cell 高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(JWCCustomLayout *)collectionViewLayout heightForRowAtIndexPath:(NSIndexPath *)indexPath itemWidth:(CGFloat)itemWidth ;</span><br></pre></td></tr></table></figure><h6 id="optional"><a href="#optional" class="headerlink" title="@optional"></a>@optional</h6><p>// headersize</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (CGSize)collectionView:(UICollectionView *)collectionView layout:(JWCCustomLayout *)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section;</span><br></pre></td></tr></table></figure><p>// footer 的 size</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (CGSize)collectionView:(UICollectionView *)collectionView layout:(JWCCustomLayout *)collectionViewLayout referenceSizeForFooterInSection:(NSInteger)section;</span><br></pre></td></tr></table></figure><p>// 每个区的边距</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(JWCCustomLayout*)collectionViewLayout insetForSectionAtIndex:(NSInteger)section;</span><br></pre></td></tr></table></figure><p>// 每个区多少列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSInteger)collectionView:(UICollectionView *)collectionView layout:(JWCCustomLayout *)collectionViewLayout columnNumberAtSection:(NSInteger )section;</span><br></pre></td></tr></table></figure><p>// 每个区多少中行距</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSInteger)collectionView:(UICollectionView *)collectionView layout:(JWCCustomLayout *)collectionViewLayout lineSpacingForSectionAtIndex:(NSInteger)section;</span><br></pre></td></tr></table></figure><p>// 每个 item 之间的左右间距</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(JWCCustomLayout*)collectionViewLayout interitemSpacingForSectionAtIndex:(NSInteger)section;</span><br></pre></td></tr></table></figure><p>// 本区区头和上个区区尾的间距</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(JWCCustomLayout*)collectionViewLayout spacingWithLastSectionForSectionAtIndex:(NSInteger)section;  （注意：在collectionViewFolwLayout中是无法设置当前的区头和上个区尾的间距的，为了弥补这一缺憾，特此添加这个方法）</span><br></pre></td></tr></table></figure><p>以上只是大致计算步骤，具体实现代码见 <a href="https://github.com/JiWuChao/CustomLayout.git" target="_blank" rel="noopener">Demo</a></p><p>看完如果对你有用 请点赞鼓励下中不中？🤣  🤣   </p><p> 效果图如下</p><p><img src="https://github.com/JiWuChao/CustomLayout/blob/master/pc3.png?raw=true" alt="第0区三列第一区四列"></p><p><img src="https://github.com/JiWuChao/CustomLayout/blob/master/pc2.png?raw=true" alt="区头和区尾设置间距"></p><p><img src="https://github.com/JiWuChao/CustomLayout/blob/master/pc1.png?raw=true" alt="单个区两列效果图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;实现瀑布流简单，实现分区瀑布流，并且每个区的瀑布流的列数不一样且有区头和区尾，就不是太容易了。我嫌麻烦不愿意自己写（——&amp;gt;我承认懒，不愿意动脑子 &lt;em&gt;V&lt;/em&gt;）开始在网上找了好多，都是仅仅一个区的瀑布流，没区头和区尾，完全满足不了我的需求。没办法，
      
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.wuchao.net.cn/categories/Objective-C/"/>
    
    
      <category term="UI" scheme="http://www.wuchao.net.cn/tags/UI/"/>
    
  </entry>
  
</feed>
