{"meta":{"title":"老JI","subtitle":"The transformation from ordinary to extraordinary will not occur overnight !","description":"iOS，swift ,OC","author":"老JI","url":"http://www.wuchao.net.cn"},"pages":[{"title":"","date":"2018-09-29T07:50:37.000Z","updated":"2018-09-29T07:50:37.000Z","comments":true,"path":"robots.html","permalink":"http://www.wuchao.net.cn/robots.html","excerpt":"","text":"User-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/Allow: /resources/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/ Sitemap: http://www.wuchao.net.cn/sitemap.xmlSitemap: http://www.wuchao.net.cn/baidusitemap.xml"},{"title":"分类","date":"2018-08-17T06:16:56.000Z","updated":"2018-09-29T07:50:37.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.wuchao.net.cn/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-08-17T06:28:18.000Z","updated":"2018-09-29T07:50:37.000Z","comments":true,"path":"about/index.html","permalink":"http://www.wuchao.net.cn/about/index.html","excerpt":"","text":"一个小白。。"},{"title":"tags","date":"2018-08-17T06:30:16.000Z","updated":"2018-09-29T07:50:37.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.wuchao.net.cn/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-09-29T07:50:37.000Z","updated":"2018-09-29T07:50:37.000Z","comments":true,"path":"top/index.html","permalink":"http://www.wuchao.net.cn/top/index.html","excerpt":"","text":"AV.initialize(\"ISSeOYnPycBRQe8e8J3yt6Jr-gzGzoHsz\", \"1glg9tTCEinuLtl0rQzKKyVw\"); var time=0 var title=\"\" var url=\"\" var query = new AV.Query('Counter'); query.notEqualTo('id',0); query.descending('time'); query.limit(1000); query.find().then(function (todo) { for (var i=0;i"}],"posts":[{"title":"线程同步方法和问题以及解决方案","slug":"线程同步方法和问题以及解决方案","date":"2018-09-29T08:07:37.000Z","updated":"2018-09-29T08:45:42.000Z","comments":true,"path":"2018/09/29/线程同步方法和问题以及解决方案/","link":"","permalink":"http://www.wuchao.net.cn/2018/09/29/线程同步方法和问题以及解决方案/","excerpt":"","text":"在日常开发中，需要当几个任务执行完之后再执行最后一个任务。一下就列举几个线程同步的常用方法，并指出其中的问题，以及提出解决方按。 Dispatch Group 调度组dispatch_group_notify 正常情况123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354- (void)dispathcGroupNotify &#123; NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); NSLog(@&quot;group---begin&quot;); dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_queue_create(&quot;com.jiwuchao.www&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.jiwuchao.www1&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.jiwuchao.www2&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_group_async(group, queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); &#125; &#125;); dispatch_group_async(group, queue1, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); &#125; &#125;); dispatch_group_async(group, queue2, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); &#125; &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; // 等前面的异步任务1、任务2都执行完毕后，回到主线程执行下边任务 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;4---%@&quot;,[NSThread currentThread]); &#125; NSLog(@&quot;group---end&quot;); &#125;);&#125;输出结果currentThread---&lt;NSThread: 0x600002cc7c40&gt;&#123;number = 1, name = main&#125;group---begin1---&lt;NSThread: 0x600002ca3a00&gt;&#123;number = 4, name = (null)&#125;1---&lt;NSThread: 0x600002c84300&gt;&#123;number = 3, name = (null)&#125;3---&lt;NSThread: 0x600002c66840&gt;&#123;number = 8, name = (null)&#125;1---&lt;NSThread: 0x600002c84300&gt;&#123;number = 3, name = (null)&#125;3---&lt;NSThread: 0x600002c66840&gt;&#123;number = 8, name = (null)&#125;1---&lt;NSThread: 0x600002ca3a00&gt;&#123;number = 4, name = (null)&#125;4---&lt;NSThread: 0x600002cc7c40&gt;&#123;number = 1, name = main&#125;4---&lt;NSThread: 0x600002cc7c40&gt;&#123;number = 1, name = main&#125;group---end &emsp; 以上执行结果是当任务1，2，3 执行完成之后才执行任务4 符合预期 dispatch_group_notify 异常情况问题描述： 理想是 任务1 任务2 任务3 执行完成之后再执行任务4 为什有时会出现某个任务还没有执行完就开始执行任务4？比如有多个接口进行网络请求，当所有接口返回之后才刷新界面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384- (void)dispathcGroupQuestion &#123; NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); NSLog(@&quot;group---begin&quot;); dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_queue_create(&quot;com.jiwuchao.www&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.jiwuchao.www1&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.jiwuchao.www2&quot;, DISPATCH_QUEUE_CONCURRENT); //任务1 dispatch_group_async(group, queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;任务1---%@&quot;,[NSThread currentThread]); &#125; &#125;); // 任务2 dispatch_group_async(group, queue1, ^&#123; // for (int i = 0; i &lt; 2; ++i) &#123;// [NSThread sleepForTimeInterval:2];// NSLog(@&quot;任务2---%@&quot;,[NSThread currentThread]);// &#125; dispatch_queue_t queue4 = dispatch_queue_create(&quot;wuchao.w&quot;, DISPATCH_QUEUE_CONCURRENT); /* 如果dispatch_async 换成 dispatch_sync 则不会出现 上面的乱序问题y，因为并发队列 + 同步执行 并不能创建多个线程 所有任务2 的线程结束就是任务2及其子线程执行完的时机 */ dispatch_async(queue4, ^&#123; // 子任务1 for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;任务2的-子任务1 - %@&quot;,[NSThread currentThread]); &#125; // 子任务2 for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;任务2的-子任务2 - %@&quot;,[NSThread currentThread]); &#125; // 子任务3 for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;任务2的-子任务3 - %@&quot;,[NSThread currentThread]); &#125; &#125;); &#125;); //任务3 dispatch_group_async(group, queue2, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;任务3---%@&quot;,[NSThread currentThread]); &#125; &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; // 等前面的异步任务1、任务2都执行完毕后，回到主线程执行下边任务 NSLog(@&quot;前面的异步操作都执行完毕&quot;); for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;开始执行dispatch_group_notify ---%@&quot;,[NSThread currentThread]); &#125; NSLog(@&quot;group---end&quot;); &#125;);&#125;输出:currentThread---&lt;NSThread: 0x600003787ec0&gt;&#123;number = 1, name = main&#125;group---begin任务3---&lt;NSThread: 0x60000372ed00&gt;&#123;number = 8, name = (null)&#125;任务1---&lt;NSThread: 0x6000037eaa80&gt;&#123;number = 4, name = (null)&#125;任务2的-子任务1 - &lt;NSThread: 0x6000037ca500&gt;&#123;number = 3, name = (null)&#125;任务3---&lt;NSThread: 0x60000372ed00&gt;&#123;number = 8, name = (null)&#125;任务1---&lt;NSThread: 0x6000037eaa80&gt;&#123;number = 4, name = (null)&#125;任务2的-子任务1 - &lt;NSThread: 0x6000037ca500&gt;&#123;number = 3, name = (null)&#125;前面的异步操作都执行完毕开始执行dispatch_group_notify ---&lt;NSThread: 0x600003787ec0&gt;&#123;number = 1, name =任务2的-子任务2 - &lt;NSThread: 0x6000037ca500&gt;&#123;number = 3, name = (null)&#125;开始执行dispatch_group_notify ---&lt;NSThread: 0x600003787ec0&gt;&#123;number = 1, name =group---end任务2的-子任务2 - &lt;NSThread: 0x6000037ca500&gt;&#123;number = 3, name = (null)&#125;任务2的-子任务3 - &lt;NSThread: 0x6000037ca500&gt;&#123;number = 3, name = (null)&#125;任务2的-子任务3 - &lt;NSThread: 0x6000037ca500&gt;&#123;number = 3, name = (null)&#125; 结论： 从上面的输出可以看出 ，当任务2 的子任务还没有执行完毕，就开始执行dispatch_group_notify中的任务，和预期任务2 执行完之后再执行 dispatch_group_notify中任务有出入 问题分析:为什么会出现这种情况？ 原因是：因为对于dispatch_group_notify 来说判断其之前的任务执行完毕的==根据是任务2 的线程执行完毕，不考虑任务2中其他子任务的线程是否执行完毕==。此时任务2的子任务是异步并发执行，开启多个线程。并没有阻塞任务2的线程，所以在其他线程中执行任务2的子任务的时候任务2的线程已经执行完了。当任务1 任务2 任务3 执行完毕之后就开始执行dispatch_group_notify 中的任务。但是任务2 中的子任务还在执行，这时就看到了输出的那样的结果。 问题解决:方法 1，2解决方法1 dispatch_group_enter 和 dispatch_group_leave&emsp; dispatch_group_enter与dispatch_group_leave 组合比dispatch_group_async 更灵活 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091- (void)dispathcGroupAnswer &#123; NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); NSLog(@&quot;group---begin&quot;); dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_queue_create(&quot;com.jiwuchao.www&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.jiwuchao.www1&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.jiwuchao.www2&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_group_enter(group); //任务1 dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;任务1---%@&quot;,[NSThread currentThread]); &#125; dispatch_group_leave(group); &#125;); //任务2 dispatch_group_enter(group); dispatch_async(queue1, ^&#123; dispatch_queue_t queue4 = dispatch_queue_create(&quot;wuchao.w&quot;, DISPATCH_QUEUE_CONCURRENT); /* 如果dispatch_async 换成 dispatch_sync 则不会出现 上面的乱序问题y，因为并发队列 + 同步执行 并不能创建多个线程 所有任务2 的线程结束就是任务2及其子线程执行完的时机 */ dispatch_async(queue4, ^&#123; // 子任务1 for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;任务2的-子任务1 - %@&quot;,[NSThread currentThread]); &#125; // 子任务2 for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;任务2的-子任务2 - %@&quot;,[NSThread currentThread]); &#125; // 子任务3 for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;任务2的-子任务3 - %@&quot;,[NSThread currentThread]); &#125; // 子任务1，2，3 是在同一个线程执行 当子任务1，2，3 执行完之后再leave 上层group 告诉nofify 这个任务2 已经完成了 才能正确完成同步 假如子任务中还有嵌套 那么还需要此种解决方法依次类推 dispatch_group_leave(group); &#125;); // 这一句放在这里是不行的// dispatch_group_leave(group); &#125;); //任务3 dispatch_group_enter(group); dispatch_async(queue2, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;任务3---%@&quot;,[NSThread currentThread]); &#125; dispatch_group_leave(group); &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; // 等前面的异步任务1、任务2都执行完毕后，回到主线程执行下边任务 NSLog(@&quot;前面的异步操作都执行完毕&quot;); for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;开始执行dispatch_group_notify ---%@&quot;,[NSThread currentThread]); &#125; NSLog(@&quot;group---end&quot;); &#125;); NSLog(@&quot;不会阻塞主线程-----&quot;);&#125;输出:currentThread---&lt;NSThread: 0x60000094d380&gt;&#123;number = 1, name = main&#125;group---begin不会阻塞主线程-----任务1---&lt;NSThread: 0x60000091aec0&gt;&#123;number = 4, name = (null)&#125;任务2的-子任务1 - &lt;NSThread: 0x6000009e7a80&gt;&#123;number = 7, name = (null)&#125;任务3---&lt;NSThread: 0x600000928300&gt;&#123;number = 8, name = (null)&#125;任务1---&lt;NSThread: 0x60000091aec0&gt;&#123;number = 4, name = (null)&#125;任务2的-子任务1 - &lt;NSThread: 0x6000009e7a80&gt;&#123;number = 7, name = (null)&#125;任务3---&lt;NSThread: 0x600000928300&gt;&#123;number = 8, name = (null)&#125;任务2的-子任务2 - &lt;NSThread: 0x6000009e7a80&gt;&#123;number = 7, name = (null)&#125;任务2的-子任务2 - &lt;NSThread: 0x6000009e7a80&gt;&#123;number = 7, name = (null)&#125;任务2的-子任务3 - &lt;NSThread: 0x6000009e7a80&gt;&#123;number = 7, name = (null)&#125;任务2的-子任务3 - &lt;NSThread: 0x6000009e7a80&gt;&#123;number = 7, name = (null)&#125;前面的异步操作都执行完毕开始执行dispatch_group_notify ---&lt;NSThread: 0x60000094d380&gt;&#123;number = 1, name =开始执行dispatch_group_notify ---&lt;NSThread: 0x60000094d380&gt;&#123;number = 1, name =group---end 结论：从输出接果可以看到输出结果符合预期。综合上述原因，用 dispatch_group_leave(group) 当任务2 的子任务的线程执行完之后才标识任务2执行完，才会触发 dispatch_group_notify 而不是当任务2线程执行完就触发dispatch_group_notify。 解决方法2 dispatch_semaphore_t 信号量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788- (void)dispathcGroupAnswer2 &#123; NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); NSLog(@&quot;group---begin&quot;); dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_queue_create(&quot;com.jiwuchao.www&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.jiwuchao.www1&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.jiwuchao.www2&quot;, DISPATCH_QUEUE_CONCURRENT); //任务1 dispatch_group_async(group, queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;任务1---%@&quot;,[NSThread currentThread]); &#125; &#125;); // 任务2 dispatch_group_async(group, queue1, ^&#123; dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); dispatch_queue_t queue4 = dispatch_queue_create(&quot;wuchao.w&quot;, DISPATCH_QUEUE_CONCURRENT); /* 如果dispatch_async 换成 dispatch_sync 则不会出现 上面的乱序问题y，因为并发队列 + 同步执行 并不能创建多个线程 所有任务2 的线程结束就是任务2及其子线程执行完的时机 */ dispatch_async(queue4, ^&#123; // 子任务1 for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;任务2的-子任务1 - %@&quot;,[NSThread currentThread]); &#125; // 子任务2 for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;任务2的-子任务2 - %@&quot;,[NSThread currentThread]); &#125; // 子任务3 for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;任务2的-子任务3 - %@&quot;,[NSThread currentThread]); &#125; // 信号量加 1 dispatch_semaphore_signal(semaphore); &#125;); // 信号量 -1 dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, (int64_t)(15 * NSEC_PER_SEC))); &#125;); //任务3 dispatch_group_async(group, queue2, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;任务3---%@&quot;,[NSThread currentThread]); &#125; &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; // 等前面的异步任务1、任务2都执行完毕后，回到主线程执行下边任务 NSLog(@&quot;前面的异步操作都执行完毕&quot;); for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;开始执行dispatch_group_notify ---%@&quot;,[NSThread currentThread]); &#125; NSLog(@&quot;group---end&quot;); &#125;);&#125;打印currentThread---&lt;NSThread: 0x600002332a00&gt;&#123;number = 1, name = main&#125;group---begin任务3---&lt;NSThread: 0x600002343580&gt;&#123;number = 8, name = (null)&#125;任务1---&lt;NSThread: 0x6000023435c0&gt;&#123;number = 9, name = (null)&#125;任务2的-子任务1 - &lt;NSThread: 0x6000023591c0&gt;&#123;number = 4, name = (null)&#125;任务3---&lt;NSThread: 0x600002343580&gt;&#123;number = 8, name = (null)&#125;任务2的-子任务1 - &lt;NSThread: 0x6000023591c0&gt;&#123;number = 4, name = (null)&#125;任务1---&lt;NSThread: 0x6000023435c0&gt;&#123;number = 9, name = (null)&#125;任务2的-子任务2 - &lt;NSThread: 0x6000023591c0&gt;&#123;number = 4, name = (null)&#125;任务2的-子任务2 - &lt;NSThread: 0x6000023591c0&gt;&#123;number = 4, name = (null)&#125;任务2的-子任务3 - &lt;NSThread: 0x6000023591c0&gt;&#123;number = 4, name = (null)&#125;任务2的-子任务3 - &lt;NSThread: 0x6000023591c0&gt;&#123;number = 4, name = (null)&#125;前面的异步操作都执行完毕开始执行dispatch_group_notify ---&lt;NSThread: 0x600002332a00&gt;&#123;number = 1, name = m开始执行dispatch_group_notify ---&lt;NSThread: 0x600002332a00&gt;&#123;number = 1, name = mgroup---end 结论： &emsp;输出结果符合预期。和dispatch_group_enter 和 dispatch_group_leave 作用一样。因为信号量初始化为0 ，当任务2 的子线程执行完成之后会执行 12//信号量加 1dispatch_semaphore_signal(semaphore); 使信号量加一操作，那么当走到 123信号量加1 此方法的作用是，可以使总信号量减1，当信号总量为0时，再减一就小于0了，就会一直等待（阻塞所在线程），否则就可以正常执行。 dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, (int64_t)(15 * NSEC_PER_SEC))); 这一句时，因为此时信号量等于1 ，那么不会阻塞当前(任务2)线程，那么任务2算是完成。假如任务2的子任务没有完成就不会走到 dispatch_semaphore_signal(semaphore) 这个方法，信号量仍然为0，会一直阻塞注任务2的线程。 dispatch_barrier_async 和 dispatch_barrier_sync 栅栏函数dispatch_barrier_async dispatch_barrier_async的作用是等待队列的前面的任务执行完毕后，才执行dispatch_barrier_async的block里面的任务,不会阻塞当前线程； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051- (void)barrierAsync &#123; // 创建一个并发队列 dispatch_queue_t queue = dispatch_queue_create(&quot;com.jiwuchao.barrierAsync&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;1 - %@&quot;,[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;2 - %@&quot;,[NSThread currentThread]); &#125; &#125;); dispatch_barrier_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;i %ld dispatch_barrier_async 任务&quot;,i); &#125; [NSThread sleepForTimeInterval:5]; &#125;); dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;3 - %@&quot;,[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;4 - %@&quot;,[NSThread currentThread]); &#125; &#125;); NSLog(@&quot;当前线程阻塞住了吗？没有&quot;);&#125;打印:2 - &lt;NSThread: 0x600002ac0ec0&gt;&#123;number = 4, name = (null)&#125;1 - &lt;NSThread: 0x600002a242c0&gt;&#123;number = 5, name = (null)&#125;1 - &lt;NSThread: 0x600002a242c0&gt;&#123;number = 5, name = (null)&#125;2 - &lt;NSThread: 0x600002ac0ec0&gt;&#123;number = 4, name = (null)&#125;i 0 dispatch_barrier_async 任务i 1 dispatch_barrier_async 任务3 - &lt;NSThread: 0x600002ac0ec0&gt;&#123;number = 4, name = (null)&#125;4 - &lt;NSThread: 0x600002ae3ec0&gt;&#123;number = 3, name = (null)&#125;4 - &lt;NSThread: 0x600002ae3ec0&gt;&#123;number = 3, name = (null)&#125;3 - &lt;NSThread: 0x600002ac0ec0&gt;&#123;number = 4, name = (null)&#125; 结论 ： dispatch_barrier_async 不会阻塞当前线程 dispatch_barrier_async 会等到前面的任务执行完之后再执行后面的任务 dispatch_barrier_sync dispatch_barrier_sync的作用是等待队列的前面的任务执行完毕后，才执行dispatch_barrier_async的block里面的任务,阻塞当前线程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455- (void)barrierSync &#123; // 创建一个并发队列 dispatch_queue_t queue = dispatch_queue_create(&quot;com.jiwuchao.barrierAsync&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;1 - %@&quot;,[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;2 - %@&quot;,[NSThread currentThread]); &#125; &#125;); dispatch_barrier_sync(queue, ^&#123; for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;i %ld dispatch_barrier_sync 任务&quot;,i); &#125; [NSThread sleepForTimeInterval:5]; &#125;); dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;3 - %@&quot;,[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;4 - %@&quot;,[NSThread currentThread]); &#125; &#125;); NSLog(@&quot;当前线程阻塞住了吗？阻塞住了&quot;);&#125;打印:2 - &lt;NSThread: 0x60000346c4c0&gt;&#123;number = 5, name = (null)&#125;1 - &lt;NSThread: 0x60000349f880&gt;&#123;number = 4, name = (null)&#125;1 - &lt;NSThread: 0x60000349f880&gt;&#123;number = 4, name = (null)&#125;2 - &lt;NSThread: 0x60000346c4c0&gt;&#123;number = 5, name = (null)&#125;i 0 dispatch_barrier_sync 任务i 1 dispatch_barrier_sync 任务当前线程阻塞住了吗？阻塞住了4 - &lt;NSThread: 0x60000345db80&gt;&#123;number = 10, name = (null)&#125;3 - &lt;NSThread: 0x60000345dc00&gt;&#123;number = 9, name = (null)&#125;3 - &lt;NSThread: 0x60000345dc00&gt;&#123;number = 9, name = (null)&#125;4 - &lt;NSThread: 0x60000345db80&gt;&#123;number = 10, name = (null)&#125; “ 当前线程阻塞住了吗？阻塞住了 “ 在当前线程中的输出 等到dispatch_barrier_sync 执行之后才执行 结论： dispatch_barrier_sync 会阻塞当前线程（主线程/非主线程） dispatch_barrier_sync会等到前面的任务执行完之后再执行后面的任务 问题描述:为什么没有等待 dispatch_barrier_async 之前的任务执行完就开始执行 dispatch_barrier_async 的block任务？？&emsp; 上述情况会在dispatch_barrier_async 出现，在dispatch_barrier_sync不会出现。 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596 - (void)barrierAsynQuestion &#123; NSLog(@&quot;1 current thread -%@&quot;,[NSThread currentThread]); // 创建一个并发队列 dispatch_queue_t queue = dispatch_queue_create(&quot;com.jiwuchao.barrierAsync&quot;, DISPATCH_QUEUE_CONCURRENT); //任务1 dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;任务1 - %@&quot;,[NSThread currentThread]); &#125; &#125;); //任务2 dispatch_async(queue, ^&#123; NSLog(@&quot;任务2 current thread -%@&quot;,[NSThread currentThread]); /* 第一种情况 会开启新线程 */// // 1 和 dispatch_async(queue, ^&#123;&#125; 是不是同一个线程 重新开启一个线程 异步 执行完之后回调// [Download downloadData:^(BOOL success) &#123;// NSLog(@&quot;正在执行下载完成之后的任务&quot;);// [NSThread sleepForTimeInterval:3];// NSLog(@&quot;下载完成之后的任务完成&quot;);// &#125;]; /* 第二种情况 如果是单个任务 不会开启新线程 如果是多个子任务则会开启线程 */ dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.wuchaoji.http&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue2, ^&#123; NSLog(@&quot;3 current thread -%@&quot;,[NSThread currentThread]); // 子任务1 for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;子任务1 - %@&quot;,[NSThread currentThread]); &#125; // 子任务2 for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;子任务2 - %@&quot;,[NSThread currentThread]); &#125; // 子任务3 for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;子任务3 - %@&quot;,[NSThread currentThread]); &#125; &#125;); &#125;); dispatch_barrier_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;i %ld dispatch_barrier_async 任务&quot;,i); &#125; [NSThread sleepForTimeInterval:5]; &#125;); // 任务3 dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;任务3 - %@&quot;,[NSThread currentThread]); &#125; &#125;); // 任务4 dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;任务4 - %@&quot;,[NSThread currentThread]); &#125; &#125;); &#125;打印:1 current thread -&lt;NSThread: 0x6000036be740&gt;&#123;number = 1, name = main&#125;任务2 current thread -&lt;NSThread: 0x6000036d1000&gt;&#123;number = 4, name = (null)&#125;3 current thread -&lt;NSThread: 0x600003633880&gt;&#123;number = 6, name = (null)&#125;任务1 - &lt;NSThread: 0x600003631280&gt;&#123;number = 5, name = (null)&#125;子任务1 - &lt;NSThread: 0x600003633880&gt;&#123;number = 6, name = (null)&#125;子任务1 - &lt;NSThread: 0x600003633880&gt;&#123;number = 6, name = (null)&#125;任务1 - &lt;NSThread: 0x600003631280&gt;&#123;number = 5, name = (null)&#125;子任务2 - &lt;NSThread: 0x600003633880&gt;&#123;number = 6, name = (null)&#125;i 0 dispatch_barrier_async 任务i 1 dispatch_barrier_async 任务子任务2 - &lt;NSThread: 0x600003633880&gt;&#123;number = 6, name = (null)&#125;子任务3 - &lt;NSThread: 0x600003633880&gt;&#123;number = 6, name = (null)&#125;子任务3 - &lt;NSThread: 0x600003633880&gt;&#123;number = 6, name = (null)&#125;任务3 - &lt;NSThread: 0x6000036e9380&gt;&#123;number = 3, name = (null)&#125;任务4 - &lt;NSThread: 0x600003633880&gt;&#123;number = 6, name = (null)&#125;任务3 - &lt;NSThread: 0x6000036e9380&gt;&#123;number = 3, name = (null)&#125;任务4 - &lt;NSThread: 0x600003633880&gt;&#123;number = 6, name = (null)&#125; 问题分析:和group_notify 类似情况1 在嵌套任务中有一个任务： 在并发队列中有单个任务时不会开启新的线程，那么和当前线程(任务2)的线程是同一个线程，当前任务2执行完也就是其中子线程的任务执行完毕。 情况2 在嵌套任务中有多个任务： 在并发队列中有多个任务就会开启多个线程异步执行，多个任务异步执行并不会阻塞任务2 的线程，那么任务2 线程执行完毕的标准是把其子任务全部提交到执行队列，那么此时dispatch_barrier_async 检测到 任务1 任务2 都已经完成就会执行dispatch_barrier_async 的任务，但是任务2 系统对完成的判断标准是把其子任务提交到执行队列，此线程的任务已经完成，但是此线程其他的线程它不负责 所以会出现在看似 线程2还没有执行完就开始执行dispatch_barrier_async 的任务，貌似dispatch_barrier_async 没有起作用和一样。 问题解决：信号量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102- (void)barrierAsynAnswer &#123; NSLog(@&quot;1 current thread -%@&quot;,[NSThread currentThread]); // 创建一个并发队列 dispatch_queue_t queue = dispatch_queue_create(&quot;com.jiwuchao.barrierAsync&quot;, DISPATCH_QUEUE_CONCURRENT); //任务1 dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;任务1 - %@&quot;,[NSThread currentThread]); &#125; &#125;); //任务2 dispatch_async(queue, ^&#123; NSLog(@&quot;任务2 current thread -%@&quot;,[NSThread currentThread]); /* 第一种情况 会开启新线程 */ // // 1 和 dispatch_async(queue, ^&#123;&#125; 是不是同一个线程 重新开启一个线程 异步 执行完之后回调 // [Download downloadData:^(BOOL success) &#123; // NSLog(@&quot;正在执行下载完成之后的任务&quot;); // [NSThread sleepForTimeInterval:3]; // NSLog(@&quot;下载完成之后的任务完成&quot;); // &#125;]; /* 第二种情况 如果是单个任务 不会开启新线程 如果是多个子任务则会开启线程 */ dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.wuchaoji.http&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); dispatch_async(queue2, ^&#123; NSLog(@&quot;3 current thread -%@&quot;,[NSThread currentThread]); // 子任务1 for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;子任务1 - %@&quot;,[NSThread currentThread]); &#125; // 子任务2 for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;子任务2 - %@&quot;,[NSThread currentThread]); &#125; // 子任务3 for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;子任务3 - %@&quot;,[NSThread currentThread]); &#125; dispatch_semaphore_signal(semaphore); &#125;); // 信号量 等待 最多等待15秒 dispatch_semaphore_wait(semaphore,dispatch_time(DISPATCH_TIME_NOW, (int64_t)(15 * NSEC_PER_SEC))); &#125;); dispatch_barrier_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;i %ld dispatch_barrier_async 任务&quot;,i); &#125; [NSThread sleepForTimeInterval:5]; &#125;); // 任务3 dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;任务3 - %@&quot;,[NSThread currentThread]); &#125; &#125;); // 任务4 dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;任务4 - %@&quot;,[NSThread currentThread]); &#125; &#125;); &#125;打印:1 current thread -&lt;NSThread: 0x600001327680&gt;&#123;number = 1, name = main&#125;任务2 current thread -&lt;NSThread: 0x60000136ec80&gt;&#123;number = 3, name = (null)&#125;3 current thread -&lt;NSThread: 0x6000013b1b80&gt;&#123;number = 5, name = (null)&#125;子任务1 - &lt;NSThread: 0x6000013b1b80&gt;&#123;number = 5, name = (null)&#125;任务1 - &lt;NSThread: 0x60000134f500&gt;&#123;number = 4, name = (null)&#125;子任务1 - &lt;NSThread: 0x6000013b1b80&gt;&#123;number = 5, name = (null)&#125;任务1 - &lt;NSThread: 0x60000134f500&gt;&#123;number = 4, name = (null)&#125;子任务2 - &lt;NSThread: 0x6000013b1b80&gt;&#123;number = 5, name = (null)&#125;子任务2 - &lt;NSThread: 0x6000013b1b80&gt;&#123;number = 5, name = (null)&#125;子任务3 - &lt;NSThread: 0x6000013b1b80&gt;&#123;number = 5, name = (null)&#125;子任务3 - &lt;NSThread: 0x6000013b1b80&gt;&#123;number = 5, name = (null)&#125;i 0 dispatch_barrier_async 任务i 1 dispatch_barrier_async 任务任务3 - &lt;NSThread: 0x60000136ec80&gt;&#123;number = 3, name = (null)&#125;任务4 - &lt;NSThread: 0x6000013819c0&gt;&#123;number = 6, name = (null)&#125;任务4 - &lt;NSThread: 0x6000013819c0&gt;&#123;number = 6, name = (null)&#125;任务3 - &lt;NSThread: 0x60000136ec80&gt;&#123;number = 3, name = (null)&#125; 结论：&emsp;输出结果符合预期。因为:在任务2 开始执行的时候生成一个信号量，信号量为0 dispatch_semaphore_wait 会一直阻塞任务2线程，直到超出等待时间。直到任务2 的子任务执行完之后才dispatch_semaphore_signal 使信号量加一 这样dispatch_semaphore_wait 取消阻塞任务2线程 Dispatch Semaphore 信号量&emsp;GCD 中的信号量是指 Dispatch Semaphore，是持有计数的信号。类似于过高速路收费站的栏杆。可以通过时，打开栏杆，不可以通过时，关闭栏杆。在 Dispatch Semaphore 中，使用计数来完成这个功能，计数为0时等待，不可通过。计数为1或大于1时，计数减1且不等待，可通过。Dispatch Semaphore 提供了三个函数。 dispatch_semaphore_create：创建一个Semaphore并初始化信号的总量 dispatch_semaphore_signal：发送一个信号，让信号总量加1 dispatch_semaphore_wait：可以使总信号量减1，当信号总量为0时就会一直等待（阻塞所在线程），否则就可以正常执行。 注意：信号量的使用前提是：想清楚你需要处理哪个线程等待（阻塞），又要哪个线程继续执行，然后使用信号量 Dispatch Semaphore 在实际开发中主要用于： 保持线程同步，将异步执行任务转换为同步执行任务 保证线程安全，为线程加锁 在此主要说下线程同步。 &emsp; 有一个全局的变量 number 要求在其他线程异步执行完赋值操作之后再输出，输出的值是在其他线程所赋的值。 1234567891011121314151617181920212223- (void)synchronization &#123; NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 NSLog(@&quot;semaphore---begin&quot;); dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); __block int number = 0; dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); number = 100; dispatch_semaphore_signal(semaphore); &#125;); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;semaphore---end,number = %d&quot;,number);&#125;打印:currentThread---&lt;NSThread: 0x600000d9a800&gt;&#123;number = 1, name = main&#125;semaphore---begin1---&lt;NSThread: 0x600000d17f40&gt;&#123;number = 6, name = (null)&#125;semaphore---end,number = 100 结论: 在其他线程异步赋值的number 输出的值正确，如果没有用dispatch_semaphore 那么输出的值是 number的初始化的值 0. 这里dispatch_semaphore 的目的是让执行synchronization 方法的main 线程和执行为number赋值的子线程 保持同步。 线程同步总结线程同步 Dispatch Group 中dispatch_group_enter 和 dispatch_group_leave 以及dispatch_group_async 比较 Dispatch Group 中有 dispatch_group_enter 和 dispatch_group_leave 以及dispatch_group_async。dispatch_group_async使用比较方便，但是不够灵活，稍微复杂一点的需求处理不是太容易。dispatch_group_enter 和 dispatch_group_leave使用没有dispatch_group_async简单，但是比较灵活，如上面解决复杂的同步问题。 dispatch_semaphore 和 dispatch group dispatch_semaphore 使用灵活，但是处理比较复杂的常见不太方便。最适合的是dispatch_semaphore 和 dispatch group 配合使用，才能灵活处理复杂场景。 结尾&emsp; 线程同步，需要根据不同的场景选择不同的技术，同时也要注意使用过程中的问题。 附Demo相关Demo这里点击 https://github.com/JiWuChao/OCKeyPoint/tree/master/Multithreading/GCD","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.wuchao.net.cn/categories/Objective-C/"}],"tags":[]},{"title":"数据结构笔记—两个有序链表合并成一个有序链表","slug":"数据结构笔记—两个有序链表合并成一个有序链表","date":"2018-08-15T06:43:06.000Z","updated":"2018-09-29T07:50:37.000Z","comments":true,"path":"2018/08/15/数据结构笔记—两个有序链表合并成一个有序链表/","link":"","permalink":"http://www.wuchao.net.cn/2018/08/15/数据结构笔记—两个有序链表合并成一个有序链表/","excerpt":"","text":"实现要求 两个升序的单链表，合并成一个升序的单链表 思路分析&emsp; 在网上看了很多其他语言实现的这个题目，不是太懂(主要是不太懂其他语言的语法)，总体而言就是把一个链表按照一定的规则插入到另一个链表中。现在用Swift实现一遍。 步骤&emsp;主要目的是找到一个插入位置 从链表的第一个结点开始，把插入的值和当前的结点做比较 如果插入的值大于当前的结点值 则继续寻找一个比它大的值，如此循环直到找到一个比它的值大的结点 找到之后把插入的值放到上一步找到的结点前面 具体实现定义定义一个结点1234567public class SLNode&lt;Int&gt; &#123; var value: Int var next :SLNode?// 下一个结点 public init(value:Int) &#123; self.value = value &#125;&#125; 定义一个链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public final class SingleLinkList &#123; public typealias Node = SLNode&lt;Int&gt; fileprivate var head:Node? // 头指针 指向首元结点 public init() &#123;&#125; //1 是否为空 func isEmpty() -&gt; Bool &#123; return head == nil &#125; //2 获取首元结点 public var first:Node?&#123; return head &#125; //3 获取尾结点 public var last:Node? &#123; if var node = head &#123; while case let next? = node.next &#123; node = next &#125; return node &#125; else &#123; return nil &#125; &#125; //4 链表的长度 public var count:Int &#123; if var node = head &#123; var c = 1 while case let next? = node.next &#123; node = next c += 1 &#125; return c &#125; else &#123; return 0 &#125; &#125; // 5 结点的获取 func getNode(atIndex index:Int) -&gt; Node? &#123; if index &gt;= 0 &#123; var node = head var i = index while node != nil &#123; if i == 0 &#123; return node &#125; i -= 1 node = node?.next &#125; &#125; return nil &#125; // 链表的添加 按照顺序添加 public func append(_ value: Int) &#123; let newNode = SLNode(value: value) if let lastNode = last &#123; lastNode.next = newNode &#125; else &#123; head = newNode &#125; &#125; &#125; 核心代码12345678910111213141516171819202122232425262728293031323334353637383940414243/// 链表合并 /// /// - Parameter list: &lt;#list description#&gt; func merge(list: SingleLinkList) &#123; var listNode = list.head //从一个结点开始 while listNode != nil &#123; self.insert(value: listNode!.value) listNode = listNode!.next &#125; &#125; // 插入一个值 不指定位置 按 升序插入 func insert(value: Int) &#123; if self.head == nil &#123; // 如果链表为空 self.head = Node.init(value: value) &#125; else &#123;// 如果链表不为空 则从首元结点开始查找插入位置 self.insert(node: &amp;self.head!, value: value) &#125; &#125; /* 思路：找到第一个比插入的值大的结点 1 插入的值和当前结点的值做比较 2 如果value 大于当前的结点值 则继续寻找一个比它大的值 3 找到之后把插入的值放到比它大的值前面 时间复杂度：O(n) */ // inout 内部可以改变外面传的参数值 func insert(node: inout Node, value: Int) &#123; if value &gt; node.value &#123; if node.next == nil &#123; node.next = Node.init(value: value) &#125; else &#123; self.insert(node: &amp;node.next!, value: value) &#125; &#125; else &#123; let newNode = Node.init(value: value) newNode.next = node // 头插法建立链表 node = newNode &#125; &#125; 结果1234567891011var link = SingleLinkList.init() link.append([1,3,5,6,8,10]) print(link) //结果：[1, 3, 5, 6, 8, 10] var linkTow = SingleLinkList.init() linkTow.append([0,2,4,7,9,11]) link.merge(list: linkTow) print(link) //结果：[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 更多详细代码 转载请注明出处，https://juejin.im/post/5b4d90b56fb9a04fdb16b014 谢谢。如果解决了您的问题请点赞支持下，如果有什么错误之处还请批评指出。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.wuchao.net.cn/categories/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.wuchao.net.cn/tags/数据结构/"}]},{"title":"数据结构笔记--线性表","slug":"数据结构笔记-线性表","date":"2018-08-14T06:41:05.000Z","updated":"2018-09-29T07:50:37.000Z","comments":true,"path":"2018/08/14/数据结构笔记-线性表/","link":"","permalink":"http://www.wuchao.net.cn/2018/08/14/数据结构笔记-线性表/","excerpt":"","text":"写在前面的话 做了几年的开发,越来越感觉到计算机基础知识的重要性,虽然在开发中可能直接使用计算机基础知识的地方不是太明显。当深入了解某个框架或者某个知识的原理时,需要一些基础知识,然而随着时间的推移基础知识长时间没看而逐渐遗忘或者不清晰，那时感觉力不从心，因此决定,复习一下基础知识做个总结 线性表&emsp; 线性表是最常用且最简单的一种数据结构,简言之,一个线性表是 n 个数据元素的有序序列. 特点 只有一个首结点和尾结点； 除首尾结点外，其他结点只有一个直接前驱和一个直接后继。 &emsp; 简言之，线性结构反映结点间的逻辑关系是 一对一的,线性结构包括线性表、堆栈、队列、字符串、数组等等，其中，最典型、最常用的 线性表的划分&emsp;从存储结构上来划分,可分为顺序存储结构称顺序表和链式存储结构称链表 顺序表顺序表的存储定义&emsp;把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。简单来说，逻辑上相邻，物理上也相邻 顺序表的特点: 利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即线性表的逻辑结构与存储结构一致 在访问线性表时，可以快速地计算出任何一个数据元素的存储地址。因此可以粗略地认为，访问每个元素所花时间相等 顺序表的复杂度:时间复杂度: 顺序表的查找、插入、删除算法的平均时间复杂度为O(n) 空间复杂度: 顺序表的时间复杂度为O(1) 顺序表的优缺点:优点：存储密度大（结点本身所占存储量/结点结构所占存储量）可以随机存取表中任一元素 缺点：在插入、删除某一元素时，需要移动大量元素浪费存储空间属于静态存储形式，数据元素的个数不能自由扩充 链表链表的特点 结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻线性表的链式表示又称为非顺序映像或链式映像。 结点&emsp; 数据元素的存储映像。由数据域和指针域两部分组成.数据域:存储元素数值数据.指针域：存储直接后继结点的存储位置数据域 | 指针域—|— 注意: ==头指针,头结点,首元结点==这几个概念: 头指针: 是指向链表中第一个结点的指针 首元结点:是指链表中存储第一个数据元素a1的结点 头结点:是在链表的首元结点之前附设的一个结点；数据域内只放空表标志和表长等信息。其作用主要是为了链表的操作方便 头结点可以有也可以没有，但是头指针必须要有。 链表的形式：单链表 结点只有一个指针域的链表。每个结点中除了包含数据域以外还包含一个指针域，用于指向其后继结点。 数据域 指针域 单链表的存储映像 带头结点的单链表：头指针指向其头结点，头结点的值域可以不含任何信息，从头结点的后继结点开始存储信息 不带头结点的单链表:头指针指向其首元结点 单链表的实现单链表是否为空123func isEmpty() -&gt; Bool &#123; return head == nil &#125; 获取首元结点123public var first:Node?&#123; return head &#125; 获取尾结点12345678910public var last:Node? &#123; if var node = head &#123; while case let next? = node.next &#123; node = next &#125; return node &#125; else &#123; return nil &#125; &#125; 链表的长度123456789101112public var count:Int &#123; if var node = head &#123; var c = 1 while case let next? = node.next &#123; node = next c += 1 &#125; return c &#125; else &#123; return 0 &#125; &#125; 结点的获取1234567891011121314func getNode(atIndex index:Int) -&gt; Node? &#123; if index &gt;= 0 &#123; var node = head var i = index while node != nil &#123; if i == 0 &#123; return node &#125; i -= 1 node = node?.next &#125; &#125; return nil &#125; 链表的添加 1234567891011121314public func append(_ value: T) &#123; let newNode = SLNode(value: value) if let lastNode = last &#123; lastNode.next = newNode &#125; else &#123; head = newNode &#125; &#125; // 批量添加 public func append(_ values:Array&lt;T&gt;) &#123; for value in values &#123; append(value) &#125; &#125; 链表的插入 插入在第 index 结点1234567891011121314public func insertNode(atIndex index:Int,value:T) &#123; let oldNode = getBeforeNode(atIndex: index) var newNode = SLNode(value: value) if index &gt; 0 &#123; if let old = oldNode &#123; newNode.next = old.next old.next = newNode &#125; else &#123; append(value) &#125; &#125; else &#123; append(value) &#125; &#125; 单链表删除 123456789101112 删除在某一个 位置的结点public func removeNode(atIndex index:Int) &#123; let beforeNode = getBeforeNode(atIndex: index) if let before = beforeNode &#123; before.next = before.next?.next &#125; &#125; // 删除所有结点 public func removeAll() &#123; head = nil &#125; 双链表&emsp;有两个指针域的链表。双链表就是在单链表上增加一个指针域,指向当前结点的前驱.用于方便地找到其前驱结点.和单链表类似也分为带头结点的双链表和不带头结点的双链表. 指针域 数据域 指针域 双向链表的实现定义一个双向链表的结点123456789//定义一个 结点 双向链表的结点定义格式public class DLNode&lt;T&gt; &#123; var value: T var next :DLNode?// 下一个结点 weak var previous :DLNode?//前一个结点 public init(value:T) &#123; self.value = value &#125;&#125; 定义一个双向链表1234567public final class DoubleLinkList&lt;T&gt; &#123; //为了操作方便 将DLNode&lt;T&gt; 重新命名为 Node public typealias Node = DLNode&lt;T&gt; //头指针 fileprivate var head:Node? public init() &#123;&#125; &#125; 双向链表是否为空123public var isEmpty:Bool &#123; return head == nil //首元结点是否为空&#125; 双向链表获取首元结点123public var first:Node?&#123; return head&#125; 双向链表获取尾结点&emsp; 尾结点的next 指针指向的结点必定为空。所以从首结点开始遍历，如果 next 为空比为尾结点 12345678910public var last:Node? &#123; if var node = head &#123; while case let next? = node.next &#123; node = next &#125; return node &#125; else &#123; return nil &#125;&#125; 双向链表的长度&emsp;从首元结点开始遍历，一直遍历到尾结点，直到遍历完成，每有一个结点长度加一 123456789101112public var count:Int &#123; if var node = head &#123; var c = 1 while case let next? = node.next &#123; node = next c += 1 &#125; return c &#125; else &#123; return 0 &#125;&#125; 双向链表的查找：&emsp; 从首元结点开始相后查找 复杂度为 O(n) 1234567891011121314public func node(atIndex index: Int) -&gt; Node? &#123; if index &gt;= 0 &#123; var node = head var i = index while node != nil &#123;//从首元结点开始向后查找 if i == 0 &#123; return node &#125; i -= 1 node = node!.next &#125; &#125; return nil &#125; 双向链表的插入&emsp;在某个位置插入一个结点。双向链表的插入步骤； 1234567891011public func insert(_ node: Node, atIndex index: Int) &#123; let oldNode = getNode(atIndex: index) let newNode = DLNode(value: node.value) newNode.previous = oldNode?.previous oldNode?.previous?.next = newNode newNode.next = oldNode oldNode?.previous = newNode if oldNode?.previous == nil &#123; head = newNode &#125;&#125; 双向链表的删除&emsp;删除链表中某一个结点，步骤如下 12345678910111213141516171819202122232425@discardableResult public func remove(atIndex index: Int) -&gt; T &#123; let node = self.getNode(atIndex: index) assert(node != nil) return remove(node: node!) &#125; @discardableResult public func remove(node: Node) -&gt; T &#123; let prev = node.previous let next = node.next if let prev = prev &#123; prev.next = next &#125; else &#123; head = next &#125; next?.previous = prev node.previous = nil node.next = nil return node.value &#125; 双向链表翻转12345678public func reverse() &#123; var node = head while let currentNode = node &#123; node = currentNode.next // 把下一个赋值给node swap(&amp;currentNode.next, &amp;currentNode.previous) // 交换 head = currentNode &#125; &#125; 以上为双向链表的操作，单链表和单循环链表以及双向循环链表的操作实现可以参照双向链表的操作。 链表的运算效率分析 查找: 因线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为 O(n)。 插入和删除: 因线性链表不需要移动元素，只要修改指针，一般情况下时间复杂度为 O(1)。 但是，如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为 O(n) 。 循环单链表&emsp;单链表的最后一个指针域指向链表中的第一个结点即可。循环单链表可以以实现从任何一个结点出发访问链表中的任何结点。 注意: 这里说第一个结点而不是说首元结点是因为,如果循环单链表是带头结点的,则最后一个结点的指针域要指向头结点,如果循环单链表的不带头节点,则最后一个指针域要指向首元结点 循环双链表&emsp;首尾相接的链表，源自于双链表。即将终端结点的后继结点设为第一个结点（首元结点或者头结点）将链表中的第一个结点的前继结点设为终端结点。 链表的优缺点 优点 数据元素的个数可以自由扩充 插入、删除等操作不必移动数据，只需修改链接指针，修改效率较高 缺点： 存储密度小 存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问（顺藤摸瓜） 顺序表和链表的比较：基于空间的比较 存储分配方式：顺序表的存储空间是静态分配的，链表的存储空间是动态分配的 存储密度：（存储密度= 结点值域所占的存储量/结点结构所占的存储总量），顺序表的存储密度 = 1 链表的存储密度 &lt; 1 (因为结点中存储的有指针域) 基于时间的比较： 存取方式：顺序表可以随机存取，也可以顺序存取，链表是顺序存取 插入删除时移动的元素的个数：顺序表平均需要移动近一半的元素，链表不需要移动，只需要修改指针 更多详细代码","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.wuchao.net.cn/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.wuchao.net.cn/tags/数据结构/"}]},{"title":"数据结构笔记—栈和队列","slug":"数据结构笔记—栈和队列","date":"2018-08-13T06:46:36.000Z","updated":"2018-09-29T07:50:37.000Z","comments":true,"path":"2018/08/13/数据结构笔记—栈和队列/","link":"","permalink":"http://www.wuchao.net.cn/2018/08/13/数据结构笔记—栈和队列/","excerpt":"","text":"栈定义 只能在表的一端（栈顶）进行插入和删除运算的线性表 逻辑结构 与线性表相同，仍为一对一关系 存储结构 用顺序栈或链栈存储均可，但以顺序栈更常见 运算规则 只能在栈顶运算，且访问结点时依照后进先出（LIFO）或先进后出（FILO）的原则 栈与一般线性表的区别 比较维度 一般线性表 栈 逻辑结构 一对一 一对一 存储结构 顺序表、链表 顺序表、链表 运算规则 随机、顺序存取 ==后进先出== 实现方式 关键是编写入栈和出栈函数，具体实现依顺序栈或链栈的不同而不同基本操作有入栈、出栈、读栈顶元素值、建栈、判断栈满、栈空等 定义一个栈123public struct Stack&lt;T&gt; &#123; fileprivate var stackData = [T]()&#125; 入栈12345//struct 的实例方法中默认不能修改属性值 如果要修改 需要加上 mutating 关键字 // push public mutating func push(_ element: T) &#123; stackData.append(element) &#125; 出栈123public mutating func pop() -&gt; T? &#123; return stackData.popLast()// popLast() 删除并返回数组中的最后一个值 &#125; 栈顶元素1234//栈顶 public var top: T? &#123; return stackData.last //数组的最后一个值 及栈顶 &#125; 栈判空123public var isEmpty: Bool &#123; return stackData.isEmpty&#125; 栈的应用举例：十进制转八进制 对于任意一个非负整数，打印出与其相等的对应八进制 1234567public mutating func tenTransformEight(value:Int) &#123; var val = value while val &gt; 0 &#123; push(val % 8) val = val / 8 &#125; &#125; 1234567var stack = Stack.init() stack.tenTransformEight(value: 1348) print(stack.popAll() ?? &quot;&quot;) //输出结果：2504 队列定义 队列是一种先进先出(FIFO) 的线性表. 它只允许在表的一端进行插入,而在另一端删除元素 未完待续。。。。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.wuchao.net.cn/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.wuchao.net.cn/tags/数据结构/"}]},{"title":"数据结构笔记—图","slug":"数据结构笔记—图","date":"2018-08-12T06:47:57.000Z","updated":"2018-09-29T07:50:37.000Z","comments":true,"path":"2018/08/12/数据结构笔记—图/","link":"","permalink":"http://www.wuchao.net.cn/2018/08/12/数据结构笔记—图/","excerpt":"","text":"图的定义和基本术语图的知识图谱 图&emsp;Graph=(V,E) V：顶点(数据元素)的有穷非空集合,和 E：边的有穷集合组成 有向图：每条边都是有方向的 无向图： 每条边都是无方向的 完全图：任意两个点都有一条边相连 稀疏图：有很少边或弧的图。 稠密图：有较多边或弧的图。 网：边/弧带权的图。 邻接：有边/弧相连的两个顶点之间的关系。 存在(vi, vj)，则称vi和vj互为邻接点； 存在&lt;vi, vj&gt;，则称vi邻接到vj， vj邻接于vi 关联(依附)：边/弧与顶点之间的关系。 存在(vi, vj)/ &lt;vi, vj&gt;， 则称该边/弧关联于vi和vj 顶点的度：与该顶点相关联的边的数目，记为TD(v)。在有向图中, 顶点的度等于该顶点的入度与出度之和。顶点 v 的入度是以 v 为终点的有向边的条数, 记作 ID(v)顶点 v 的出度是以 v 为始点的有向边的条数, 记作OD(v) 路径：接续的边构成的顶点序列。 路径长度：路径上边或弧的数目/权值之和。 回路(环)：第一个顶点和最后一个顶点相同的路径。1简单路径：顶点不重复出现的路径。 简单回路(简单环)：除路径起点和终点相同外，其余顶点均不相同的路径。 连通图（强连通图） 在无（有）向图G=( V, {E} )中，若对任何两个顶点 v、u 都存在从v 到 u 的路径，则称G是连通图（强连通图）。 权与网 图中边或弧所具有的相关数称为权。表明从一个顶点到另一个顶点的距离或耗费。带权的图称为网。 子图 设有两个图G=（V，{E}）、G1=（V1，{E1}），若V1包含于 V，E1 包含于 E，则称 G1是G的子图。 图的存储结构顺序存储结构：&emsp;数组表示法（邻接矩阵） 邻接矩阵表示法的特点优点：容易实现图的操作，如：求某顶点的度、判断顶点之间是否有边、找顶点的邻接点等等。 缺点：n个顶点需要n*n个单元存储边;空间效率为O(n2)。 对稀疏图而言尤其浪费空间。 链式存储结构：邻接表表示法的特点优点：空间效率高，容易寻找顶点的邻接点； 缺点：判断两顶点间是否有边或弧，需搜索两结点对应的单链表，没有邻接矩阵方便。 多重链表 邻接表: 邻接多重表: 十字链表: 邻接矩阵与邻接表表示法的关系联系：邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数。 区别： ① 对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致），但邻接表不唯一（链接次序与顶点编号无关）。 ② 邻接矩阵的空间复杂度为O(n2),而邻接表的空间复杂度为O(n+e)。 用途：邻接矩阵多用于稠密图；而邻接表多用于稀疏图 图的实现&emsp;链式存储结构 123456789 第一 / /\\ \\ 1 6 / / \\ \\第四 /5 \\3 第二 \\ / \\ | 7\\ / \\ |2 第五 ---4--- 第三 图 定义一个顶点123456789101112131415161718192021public struct Vertex&lt;T:Hashable&gt; &#123; var data :T&#125;extension Vertex:Hashable &#123; public var hashValue: Int &#123; return &quot;\\(data)&quot;.hashValue &#125; static public func == (lhs:Vertex,rhs:Vertex) -&gt; Bool &#123; return lhs.data == rhs.data &#125; &#125;extension Vertex: CustomStringConvertible &#123; public var description: String &#123; return &quot;\\(data)&quot; &#125;&#125; 定义边12345678910111213141516171819202122public enum EdgeType &#123; case directed // 有方向的 case undirected // 无方向的&#125;public struct Edge&lt;T:Hashable&gt; &#123; public var source:Vertex&lt;T&gt; //原点 public var destination:Vertex&lt;T&gt;//目的地 public let weight: Double? //权重&#125;extension Edge :Hashable &#123; public var hashValue: Int &#123; return &quot;\\(source)\\(destination)\\(weight)&quot;.hashValue &#125; static public func == (lhs:Edge&lt;T&gt;,rhs:Edge&lt;T&gt;) -&gt; Bool &#123; return lhs.source == rhs.source &amp;&amp; lhs.destination == rhs.destination &amp;&amp; lhs.weight == rhs.weight &#125; &#125; 定义协议123456789101112131415protocol Graphable &#123; //协议需要一个称为元素的关联类型。这允许协议是通用的，可以容纳任何类型。 associatedtype Element: Hashable // //为了让使用者定义一个输出的格式 var description: CustomStringConvertible &#123; get &#125; // 2 //提供一个通用的方法生成一个顶点 func createVertex(data: Element) -&gt; Vertex&lt;Element&gt; // 3 //提供一个通用的方法 在两个顶点之间添加一条边 func add(_ type: EdgeType, from source: Vertex&lt;Element&gt;, to destination: Vertex&lt;Element&gt;, weight: Double?) //获取两个顶点之间的权重 func weight(from source: Vertex&lt;Element&gt;, to destination: Vertex&lt;Element&gt;) -&gt; Double? // 获取与顶点相连的所有的边 func edges(from source: Vertex&lt;Element&gt;) -&gt; [Edge&lt;Element&gt;]? // 6 &#125; 定义一个表实现协议1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283open class AdjacencyList&lt;T: Hashable&gt; &#123; // adjacencyDict 是一个字典 key 是顶点 value 是于顶点相连的所有边 public var adjacencyDict : [Vertex&lt;T&gt;: [Edge&lt;T&gt;]] = [:] public init() &#123;&#125; /// 添加一个有方向的边 /// /// - Parameters: /// - source: 顶点 /// - destination: 终点 /// - weight: 权重 fileprivate func addDirectedEdge(from source: Vertex&lt;Element&gt;, to destination: Vertex&lt;Element&gt;, weight: Double?) &#123; let edge = Edge(source: source, destination: destination, weight: weight) // 1 adjacencyDict[source]?.append(edge) // 2 &#125; /// 添加一个无方向的边：无论是源点或者是终点，其对应的边点数组都要添加这条边 /// /// - Parameters: /// - vertices: 源点和终点 /// - weight: 权重 fileprivate func addUndirectedEdge(vertices: (Vertex&lt;Element&gt;, Vertex&lt;Element&gt;), weight: Double?) &#123; let (source, destination) = vertices addDirectedEdge(from: source, to: destination, weight: weight) addDirectedEdge(from: destination, to: source, weight: weight) &#125;&#125;extension AdjacencyList:Graphable &#123; public typealias Element = T //为了让使用者定义一个输出的格式 public var description: CustomStringConvertible &#123; var result = &quot;&quot; for (vertex, edges) in adjacencyDict &#123; var edgeString = &quot;&quot; for (index, edge) in edges.enumerated() &#123; if index != edges.count - 1 &#123; edgeString.append(&quot;\\(edge.destination), &quot;) &#125; else &#123; edgeString.append(&quot;\\(edge.destination)&quot;) &#125; &#125; result.append(&quot;\\(vertex) ---&gt; [ \\(edgeString) ] \\n &quot;) &#125; return result &#125; // 2 //提供一个通用的方法生成一个顶点 public func createVertex(data: Element) -&gt; Vertex&lt;Element&gt; &#123; let vertex = Vertex(data: data) //生成一个顶点 if adjacencyDict[vertex] == nil &#123; //如果当前存储边的数组为 nil（即还没有初始化） 则生成一个数组 adjacencyDict[vertex] = [] &#125; return vertex //返回顶点 &#125; //提供一个通用的方法 在两个顶点之间添加一条边 public func add(_ type: EdgeType, from source: Vertex&lt;Element&gt;, to destination: Vertex&lt;Element&gt;, weight: Double?) &#123; switch type &#123; case .directed://有向图 addDirectedEdge(from: source, to: destination, weight: weight) break case .undirected://无向图 addUndirectedEdge(vertices: (source, destination), weight: weight) break &#125; &#125; //获取两个顶点之间的权重 public func weight(from source: Vertex&lt;Element&gt;, to destination: Vertex&lt;Element&gt;) -&gt; Double? &#123; //获取当前源点的所有边 guard let edges = adjacencyDict[source] else &#123; return nil &#125; for edge in edges &#123;// 遍历所有边 if edge.destination == destination &#123;//如果当前边的目的地等于要查询的目的地 return edge.weight //则返回 权重 &#125; &#125; return nil &#125; // 获取与顶点相连的所有的边 public func edges(from source: Vertex&lt;Element&gt;) -&gt; [Edge&lt;Element&gt;]? &#123; return adjacencyDict[source] &#125;&#125; 使用1234567891011121314151617181920212223242526272829303132let list = AdjacencyList&lt;String&gt;.init() let first = list.createVertex(data: &quot;第一&quot;) let second = list.createVertex(data: &quot;第二&quot;) let third = list.createVertex(data: &quot;第三&quot;) let forth = list.createVertex(data: &quot;第四&quot;) let fifth = list.createVertex(data: &quot;第五&quot;)list.add(.undirected, from: first, to: second, weight: 1)list.add(.undirected, from: first, to: third, weight: 3)list.add(.undirected, from: first, to: forth, weight: 6)list.add(.undirected, from: first, to: fifth, weight: 5)list.add(.undirected, from: forth, to: fifth, weight: 7)list.add(.undirected, from: fifth, to: third, weight: 4)list.add(.undirected, from: second, to: third, weight: 2)print(list.description)结果：第四 ---&gt; [ 第一, 第五 ] 第一 ---&gt; [ 第二, 第三, 第四, 第五 ] 第五 ---&gt; [ 第一, 第四, 第三 ] 第三 ---&gt; [ 第一, 第五, 第二 ] 第二 ---&gt; [ 第一, 第三 ] //print(list.edges(from: third))print(list.weight(from: third, to: fifth) ?? 0)结果： 4.0 图的遍历定义&emsp;从已给的连通图中某一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，就叫做图的遍历，它是图的基本运算。 遍历实质&emsp;找每个顶点的邻接点的过程。 图的特点&emsp;图中可能存在回路，且图的任一顶点都可能与其它顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。 图常用的遍历：深度优先搜索&emsp;仿树的先序遍历过程 简单归纳： 访问起始点v; 若v的第1个邻接点没访问过，深度遍历此邻接点； 若当前邻接点已访问过，再找v的第2个邻接点重新遍历。 深度优先搜索算法实现 &emsp;与广度优先搜索算法不同的是广度优先算法需要一个队列作铺助，而广度优先搜索算法需要一个栈，因为栈是先进后出，深度优先搜索算法需要实现回退的逻辑，而栈正好符合。 1234567891011121314151617181920212223242526272829303132public func depthFirstSearch(from source: Vertex&lt;Element&gt;, to destination: Vertex&lt;Element&gt;) -&gt; [Edge&lt;Element&gt;]? &#123; // 之所以用队列的原因就是 深度优先算法需要回退 var stack = Stack&lt;Vertex&lt;Element&gt;&gt;() // 创建一个堆栈来存储从起点到终点的潜在路径。 stack.push(source)//把开始的顶点压入栈 var visits : [Vertex&lt;Element&gt; : Visit&lt;Element&gt;] = [source: .source]//存储已经访问过的顶点 while let vertex = stack.pop() &#123; if vertex == destination &#123; // 如果源点和终点相同 var vertex = destination // var route: [Edge&lt;Element&gt;] = []// 访问的路径 while let visit = visits[vertex], case .edge(let edge) = visit &#123; route = [edge] + route vertex = edge.source &#125; return route &#125; guard let neighbors = self.edges(from: vertex), neighbors.count &gt; 0 else &#123; _ = stack.pop() continue &#125; for edge in neighbors &#123; if visits[edge.destination] == nil &#123; stack.push(edge.destination) visits[edge.destination] = .edge(edge) &#125; &#125; &#125; return nil&#125; 123456789101112131415上文中的图用深度优先算法搜索 原点是“第五” 终点是“第二”if let ed = list.depthFirstSearch(from: fifth, to: second) &#123; print(&quot;深度优先&quot;) for edge in ed &#123; print(&quot;\\(edge.source) -&gt; \\(edge.destination)&quot;) &#125;&#125;结果是：深度优先第五 -&gt; 第三第三 -&gt; 第二 DFS算法效率分析 用邻接矩阵来表示图，遍历图中每一个顶点都要从头扫描该顶点所在行，时间复杂度为O(n2)。 用邻接表来表示图，虽然有 2e 个表结点，但只需扫描 e 个结点即可完成遍历，加上访问 n个头结点的时间，时间复杂度为O(n+e)。 结论：稠密图适于在邻接矩阵上进行深度遍历；稀疏图适于在邻接表上进行深度遍历。 广度优先搜索&emsp;基本思想：——仿树的层次遍历过程 步骤简单归纳： 1.在访问了起始点v之后，依次访问 v的邻接点； 2.然后再依次访问这些顶点中未被访问过的邻接点；直到所有顶点都被访问过为止。 代码实现以及步骤 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 public func breadthFirstSearch(from source: Vertex&lt;Element&gt;, to destination: Vertex&lt;Element&gt;) -&gt; [Edge&lt;Element&gt;]? &#123; var queue = GraphaQueue&lt;Vertex&lt;Element&gt;&gt;() queue.enqueue(source) // 1先把源点加入队列 /* 用字典 记录已经访问过的顶点用于记录访问的路径 键:顶点 值:一个枚举值 enum Visit&lt;Element: Hashable&gt; &#123; case source 原点 case edge(Edge&lt;Element&gt;) 边 &#125; */ var visits : [Vertex&lt;Element&gt; : Visit&lt;Element&gt;] = [source: .source] while let visitedVertex = queue.dequeue() &#123; // 2遍历取出然后取出出队的元素 if visitedVertex == destination &#123; // 3如果源点和终点相同 var vertex = destination // var route: [Edge&lt;Element&gt;] = []// 访问的路径 while let visit = visits[vertex], case .edge(let edge) = visit &#123; route = [edge] + route vertex = edge.source &#125; return route &#125; /* 1 取出跟原点相关的所有边 2 遍历跟原点相关的所有边 --&gt; 找到边的终点 3 判断：如果边的终点没有被访问过：即邻接点还没有被访问过 4 把此邻接点加入队列 5 把邻接点标记为已访问 */ let neighbourEdges = edges(from: visitedVertex) ?? [] // 1 for edge in neighbourEdges &#123;//2 if visits[edge.destination] == nil &#123;//3 queue.enqueue(edge.destination)//4 visits[edge.destination] = .edge(edge)//5 &#125; print(&quot;\\(edge.destination)&quot;) &#125; print(&quot;---end---\\n&quot;) &#125; return nil&#125; 12345678910111213上文中的图用广度优先搜索，原点是“第五” 终点是“第二”if let ed = list.breadthFirstSearch(from: fifth, to: second) &#123; print(&quot;广度优先&quot;) for edge in ed &#123; print(&quot;\\(edge.source) -&gt; \\(edge.destination)&quot;) &#125;&#125;结果：广度优先第五 -&gt; 第一第一 -&gt; 第二 注意：同样是从“第五”到“第二”，广度优先算法和深度优先算法的结果是不同的 总结：广度优先搜索是一种分层的搜索过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有回退的情况。因此，广度优先搜索不是一个递归的过程，其算法也不是递归的。 广度优先算法效率分析 如果使用邻接矩阵，则BFS对于每一个被访问到的顶点，都要循环检测矩阵中的整整一行（ n 个元素），总的时间代价为O(n2)。 用邻接表来表示图，虽然有 2e 个表结点，但只需扫描 e 个结点即可完成遍历，加上访问 n个头结点的时间，时间复杂度为O(n+e)。 广度优先与深度优先算法效率比较 空间复杂度相同，都是O(n)(借用了堆栈或队列）； 时间复杂度只与存储结构（邻接矩阵或邻接表）有关，而与搜索路径无关。 图的应用最小生成树 极小连通子图：该子图是G 的连通子图，在该子图中删除任何一条边，子图不再连通。 生成树：包含图G所有顶点的极小连通子图（n-1条边）。 最小生成树的典型用途&emsp;欲在n个城市间建立通信网，则n个城市应铺n-1条线路；但因为每条线路都会有对应的经济成本，而n个城市可能有n(n-1)/2 条线路，那么，如何选择n–1条线路，使总费用最少？ 首先明确：使用不同的遍历图的方法，可以得到不同的生成树从不同的顶点出发，也可能得到不同的生成树。按照生成树的定义，n 个顶点的连通网络的生成树有 n 个顶点、n-1 条边。 &emsp;目标：在网的多个生成树中，寻找一个各边权值之和最小的生成树 构造最小生成树的准则 必须只使用该网中的边来构造最小生成树； 必须使用且仅使用n-1条边来联结网络中的n个顶点 不能使用产生回路的边 如何求最小生成树Prim算法:&emsp;归并顶点，与边数无关，适于稠密网 代码实现： 要依赖一个优先队列（堆） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Prim&lt;T:Hashable&gt; &#123; typealias Graph = AdjacencyList&lt;T&gt; //定义一个小堆 var heap = Heap&lt;(vertex:Vertex&lt;T&gt;,weight:Double,parent:Vertex&lt;T&gt;?)&gt;.init &#123; (vertex, vertex2) -&gt; Bool in return vertex.weight &lt; vertex2.weight &#125; /// 生成最小生成树 /// /// - Parameter graph: &lt;#graph description#&gt; /// - Returns: &lt;#return value description#&gt; func createMinimumSpanningTree(graph:Graph) -&gt; (cost:Double,mst:Graph) &#123; var cost = 0.0 let mst = Graph() var visited = Set&lt;Vertex&lt;T&gt;&gt;() guard let start = graph.getAllVertices().first else&#123; print(mst.description) return (cost:cost,mst:mst) &#125; //先把开始的顶点加入到堆中 heap.enqueue((vertex: start, weight: 0.0, parent: nil)) while let head = heap.dequeue() &#123; let vertex = head.vertex //取出堆中的第一个顶点 if visited.contains(vertex) &#123;//检查是否已经访问过了 如果已经访问过了 则进行下一次循环 continue &#125; visited.insert(vertex) cost += head.weight if let prev = head.parent &#123; // 5 print(prev.description) let pre = mst.createVertex(data: prev.data) let ver = mst.createVertex(data: vertex.data) mst.add(.undirected, from: pre, to: ver, weight: head.weight) &#125; if let neighbours = graph.edges(from: vertex) &#123; for neighbour in neighbours &#123; if !visited.contains(neighbour.destination) &#123; heap.enqueue((vertex: neighbour.destination, weight: neighbour.weight ?? 0, parent: vertex)) &#125; &#125; &#125; &#125; return (cost:cost,mst:mst) &#125;&#125; 测试：12345678910111213141516171819202122232425262728293031323334let list = AdjacencyList&lt;String&gt;.init()let first = list.createVertex(data: &quot;第一&quot;)let second = list.createVertex(data: &quot;第二&quot;)let third = list.createVertex(data: &quot;第三&quot;)let forth = list.createVertex(data: &quot;第四&quot;)let fifth = list.createVertex(data: &quot;第五&quot;)list.add(.undirected, from: first, to: second, weight: 1)list.add(.undirected, from: first, to: third, weight: 3)list.add(.undirected, from: first, to: forth, weight: 6)list.add(.undirected, from: first, to: fifth, weight: 5)list.add(.undirected, from: forth, to: fifth, weight: 7)list.add(.undirected, from: fifth, to: third, weight: 4)list.add(.undirected, from: second, to: third, weight: 2)let prim = Prim&lt;String&gt;.init()let (cost,mst) = prim.createMinimumSpanningTree(graph: list)print(&quot;权值:\\(cost)&quot;)print(&quot;最小生成树:&quot;)print(mst.description)结果：权值:13.0最小生成树:第四 ---&gt; [ 第一 ] 第一 ---&gt; [ 第四, 第二 ] 第五 ---&gt; [ 第三 ] 第三 ---&gt; [ 第二, 第五 ] 第二 ---&gt; [ 第一, 第三 ] Kruskal算法&emsp;归并边，适于稀疏网 最短路径典型用途： 交通问题。如：城市A到城市B有多条线路，但每条线路的交通费（或所需时间）不同，那么，如何选择一条线路，使总费用（或总时间）最少？ 问题抽象： 在带权有向图中A点（源点）到达B点（终点）的多条路径中，寻找一条各边权值之和最小的路径，即最短路径。 注意：最短路径与最小生成树不同，路径上不一定包含n个顶点 两种常见的最短路径问题：单源最短路径—用Dijkstra（迪杰斯特拉）算法&emsp;一顶点到其余各顶点 所有顶点间的最短路径—用Floyd（弗洛伊德）算法&emsp;任意两顶点之间 拓扑排序解决的问题&emsp;用有向图来描述一个工程或系统的进行过程。一个工程可以分为若干个子工程，只要完成了这些子工程（活动），就可以导致整个工程的完成。 拓扑排序算法的思想－重复选择没有直接前驱的顶点 输入AOV网络。令 n 为顶点个数。 在AOV网络中选一个没有直接前驱的顶点, 并输出之; 从图中删去该顶点, 同时删去所有它发出的有向边; 重复以上 2、3 步, 直到： &emsp;1&gt;全部顶点均已输出，拓扑有序序列形成，拓扑排序完成 &emsp;2&gt;图中还有未输出的顶点，但已跳出处理循环。这说明图中还剩下一些顶点，它们都有直接前驱，再也找不到没有前驱的顶点了。这时AOV网络中必定存在有向环。 关键路径解决的问题&emsp; 假设以有向网表示一个施工流图，弧上的权值表示完成该项子工程所需时间。问：哪些子工程项是“关键工程”？即：哪些子工程项将影响整个工程的完成期限的。 &emsp;整个工程完成的时间为：从有向图的源点到汇点的最长路径。 &emsp;关键活动指的是：该弧上的权值增加 将使有向图上的最长路径的长度增加。 未完待续。。。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.wuchao.net.cn/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.wuchao.net.cn/tags/数据结构/"}]},{"title":"数据结构笔记—树和二叉树","slug":"数据结构笔记—树和二叉树","date":"2018-08-11T06:48:53.000Z","updated":"2018-09-29T07:50:37.000Z","comments":true,"path":"2018/08/11/数据结构笔记—树和二叉树/","link":"","permalink":"http://www.wuchao.net.cn/2018/08/11/数据结构笔记—树和二叉树/","excerpt":"","text":"树和二叉树定义 树是n个结点的有限集 基本术语1234567 A / | \\ B C D / \\ | / | \\ E F G H I J / \\ |K L M 根：即根结点(没有前驱) 叶子：即终端结点(没有后继) 森林：指m棵不相交的树的集合(例如删除A后的子树个数) 有序树：结点各子树从左至右有序，不能互换（左为第一） 无序树：结点各子树可互换位置 双亲：即上层的那个结点(直接前驱) 孩子：即下层结点的子树的根(直接后继) 兄弟：同一双亲下的同层结点（孩子之间互称兄弟） 堂兄弟：即双亲位于同一层的结点（但并非同一双亲） 祖先：即从根到该结点所经分支的所有结点 子孙：即该结点下层子树中的任一结点 结点：即树的数据元素 结点的度：结点拥有的子树数 结点的层次：从根到该结点的层数（根结点算第一层） 终端结点：即度为0的结点，即叶子 分支结点：即度不为0的结点（也称为内部结点） 树的度:所有结点度中的最大值 树的深度(或高度):指所有结点中最大的层数 树的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 构造如下的树 1 / \\ 2 3 /|\\ | \\ 4 5 6 10 11 /|\\ / | \\ 7 8 9 12 13 14 /// 树的结点定义public class TreeNode&lt;T&gt; &#123; public var value:T public weak var parent:TreeNode? // 父节点 只有一个 public var children = [TreeNode&lt;T&gt;]()// 有多个 init(value:T) &#123; self.value = value &#125; public func addChild(_ node:TreeNode&lt;T&gt;) &#123; children.append(node) node.parent = self &#125; &#125;extension TreeNode: CustomStringConvertible &#123; public var description: String &#123; var s = &quot;\\(value)&quot; if !children.isEmpty &#123; s += &quot; &#123;&quot; + children.map &#123; $0.description &#125;.joined(separator: &quot;, &quot;) + &quot;&#125;&quot; &#125; return s &#125;&#125;extension TreeNode where T:Equatable &#123; //搜索 public func search(_ value:T) -&gt;TreeNode? &#123; if value == self.value &#123; return self &#125; for child in children &#123; if let found = child.search(value) &#123; return found &#125; &#125; return nil &#125;&#125; 二叉树 二叉树基本特点：结点的度小于等于2有序树（子树有序，不能颠倒） 二叉树的性质 在二叉树的第i层上至多有2i-1个结点,至少有1个结点 深度为k的二叉树至多有2k-1个结点，至少有 k 个结点 对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2＋1 （即n0=n2+1） 性质4: 具有n个结点的完全二叉树的深度必为log2n＋1 (log2n向下取整) 对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2 (i/2向下取整)。 特殊形态的二叉树 满二叉树：一棵深度为k 且有2k -1个结点的二叉树。（特点：每层都“充满”了结点） 2.完全二叉树：深度为k 的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k 的满二叉树中编号从1至n的结点一一对应 满二叉树和完全二叉树的区别&emsp;满二叉树是叶子一个也不少的树，而完全二叉树虽然前n-1层是满的，但最底层却允许在右边缺少连续若干个结点。满二叉树是完全二叉树的一个特例。 注意：从存储形式来讲适合顺序存储。如果其他形式的二叉树用顺序存储结点间关系蕴含在其存储位置中必将浪费空间 二叉树的实现定义结点123456public indirect enum BinaryTree&lt;T&gt; &#123; //左子树 / 值 / 右子树 case node(BinaryTree&lt;T&gt;,T,BinaryTree&lt;T&gt;) case empty&#125; 求结点数123456789//计算结点数 public var count: Int &#123; switch self &#123; case let .node(left, _, right): return left.count + 1 + right.count //递归 case .empty: return 0 &#125; &#125; 二叉树构造过程&emsp;构造二叉树 123456789101112131415161718192021222324252627 1 / \\ 2 3 / \\ /4 5 6//二叉树的构造过程先从叶子结点开始let node5 = BinaryTree.node(.empty, &quot;5&quot;, .empty)let node6 = BinaryTree.node(.empty, &quot;6&quot;, .empty)let node4 = BinaryTree.node(.empty, &quot;4&quot;, .empty)let node2 = BinaryTree.node(node4, &quot;2&quot;, node5)let node3 = BinaryTree.node(node6, &quot;3&quot;, .empty)let node1 = BinaryTree.node(node2, &quot;1&quot;, node3)print(node1) 结果： value: 1, left = [value: 2, left = [value: 4, left = [], right = []], right = [value: 5, left = [], right = []]], right = [value: 3, left = [value: 6, left = [], right = []], right = []]print(node1.count) 结果： 6 遍历二叉树和线索二叉树遍历二叉树&emsp;遍历定义——指按某条搜索路线遍访每个结点且不重复（又称周游）。 &emsp;遍历用途——它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 遍历规则 DLR—先序遍历，即先根再左再右 LDR—中序遍历，即先左再根再右 LRD—后序遍历，即先左再右再根 如下：1234567891011 A / \\ B C / \\ D E 先序遍历：A B D E C中序遍历：D B E A C后序遍历：D E B C A 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* DLR—先序遍历，即先根再左再右 LDR—中序遍历，即先左再根再右 LRD—后序遍历，即先左再右再根 //先序遍历 func traverseDLR(process:(T)-&gt;Void) &#123; if case let .node(left, value, right) = self&#123; process(value) left.traverseDLR(process: process) right.traverseDLR(process: process) &#125; &#125; //中序遍历 func traverseLDR(process:(T)-&gt;Void) &#123; if case let .node(left, value, right) = self&#123; left.traverseLDR(process: process) process(value) right.traverseLDR(process: process) &#125; &#125; // 后续遍历 func traverseLRD(process:(T)-&gt;Void) &#123; if case let .node(left, value, right) = self&#123; left.traverseLRD(process: process) right.traverseLRD(process: process) process(value) &#125; &#125; 1 / \\ 2 3 / \\ /4 5 6以遍历此树为例：//先序遍历var s1 = &quot;&quot;tree.traverseDLR &#123; (value) in s1 += &quot; -&gt; &quot; + &quot;\\(value)&quot; print(s1)&#125; 遍历过程打印： -&gt; 1 -&gt; 1 -&gt; 2 -&gt; 1 -&gt; 2 -&gt; 4 -&gt; 1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 3 -&gt; 1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 3 -&gt; 6//中序 var s2 = &quot;&quot;node1.traverseLDR &#123; (value) in s2 += &quot; -&gt; &quot; + &quot;\\(value)&quot; print(s2)&#125; 遍历过程打印： -&gt; 4 -&gt; 4 -&gt; 2 -&gt; 4 -&gt; 2 -&gt; 5 -&gt; 4 -&gt; 2 -&gt; 5 -&gt; 1 -&gt; 4 -&gt; 2 -&gt; 5 -&gt; 1 -&gt; 6 -&gt; 4 -&gt; 2 -&gt; 5 -&gt; 1 -&gt; 6 -&gt; 3 //后序遍历var s3 = &quot;&quot;node1.traverseLRD &#123; (value) in s3 += &quot; -&gt; &quot; + &quot;\\(value)&quot; print(s3)&#125; 遍历过程打印： -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 4 -&gt; 5 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 2 -&gt; 6 -&gt; 4 -&gt; 5 -&gt; 2 -&gt; 6 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 2 -&gt; 6 -&gt; 3 -&gt; 1 遍历算法的分析&emsp;从递归的角度看，三种算法是完全相同的，或说这三种算法的访问路径是相同的，只是访问结点的时机不同。 时间效率:O(n) //每个结点只访问一次 空间效率:O(n) //栈占用的最大辅助空间 线索二叉树&emsp;普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得若将遍历后对应的有关前驱和后继预存起来，则从第一个结点(++可能是根、或最左（右）叶子++)开始就能很快“顺藤摸瓜”而遍历整个树 &emsp;例如中序遍历结果：B D C E A F H G，实际上已将二叉树转为线性排列，显然具有唯一前驱和唯一后继！ 术语 线索：指向结点前驱和后继的指针 线索链表：加上线索二叉链表 线索二叉树：加上线索的二叉树（图形式样） 线索化：对二叉树以某种次序遍历使其变为线索二叉树的过程 线索化规则 若结点有左子树，则lchild指向其左孩子；否则， lchild指向其直接前驱(即线索)； 若结点有右子树，则rchild指向其右孩子；否则， rchild指向其直接后继(即线索) 。 代码实现霍夫曼树术语12345 A / \\ B C / \\ / \\ D E F G 路径：由一结点到另一结点间的分支所构成- 路径长度：路径上的分支数目。 如：A→E 的路径长度＝2 带权路径长度：结点到根的路径长度与结点上权的乘积 树的带权路径长度：树中所有叶子结点的带权路径长度之和 ==霍夫曼树==：带权路径长度最小的树 霍夫曼树的构造过程 基本思想：使权大的结点靠近根 操作要点：对权值的合并、删除与替换，总是合并当前值最小的两个 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即霍夫曼树。 算法实现","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.wuchao.net.cn/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.wuchao.net.cn/tags/数据结构/"}]},{"title":"数据结构-排序","slug":"数据结构-排序","date":"2018-08-10T07:56:01.000Z","updated":"2018-09-29T07:50:37.000Z","comments":true,"path":"2018/08/10/数据结构-排序/","link":"","permalink":"http://www.wuchao.net.cn/2018/08/10/数据结构-排序/","excerpt":"","text":"概述 排序的定义： 将一组杂乱无章的数据按一定规律顺次排列起来。 排序的目的： 便于查找！ 内部排序和外部排序 若待排序记录都在内存中，称为内部排序； 若待排序记录一部分在内存，一部分在外存，则称为外部排序。 [ ] 注意:外部排序时，要将数据分批调入内存来排序，中间结果还要及时放入外存，显然外部排序要复杂得多。 衡量标准 时间效率——排序速度（比较次数与移动次数） 空间效率——占内存辅助空间的大小 稳定性——A和B的关键字相等，排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。 分类插入排序直接插入排序算法描述&emsp;一般的排序过程：整个排序过程为n-1趟插入，即先将序列中第1个记录看成是一个有序子序列，然后从第2个记录开始，逐个进行插入，直至整个序列有序。 下文实现一个和一般的不同的算法 算法实现为了便于理解，把比较的过程也打印了出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 /* 插入排序： 此实现的算法与上文中所说有差异，是修改版的 不需要和前面的进行交换 思路： 1 从 数组中的第二个元素开始 2 和第一个元素进行比较 如果满足排序条件sortBy:(T,T) -&gt; Bool) 3 则把第一个元素向后移一位 然后把第二个元素放在第一个位置上 4 如果是第三次插入则要和前面的两个进行比较 是否需要移动 5 依此类推 总结：此算法整个过程就是找一个合适的位置进行插入 *//// 插入排序////// - Parameters:/// - contents: 要排序的内容/// - sortBy: 排序的条件/// - Returns: &lt;#return value description#&gt;func insertSort&lt;T&gt;(_ contents: [T], sortBy:(T,T) -&gt; Bool) -&gt;[T] &#123; guard contents.count &gt; 1 else &#123; return contents &#125; var cntnts = contents for i in 1..&lt;cntnts.count &#123; //从第二个元素开始 因为第一个元素是有序的 print(&quot;--------第\\(i)趟--------&quot;) var j = i let temp = cntnts[j]//保存当前的值 print(&quot;第\\(i - j)次 是否需要移动 ？&quot;) while j &gt; 0 &amp;&amp; sortBy(temp,cntnts[j-1]) &#123;//当前的值与其前一个值做比较 print(&quot;+++第\\(i - j)次 需要移动+++&quot;) print(&quot;+++第\\(i - j)次 \\(cntnts[j-1])向后移动到\\(cntnts[j])的位置+++&quot;) cntnts[j] = cntnts[j-1] // 向后移动一位 j -= 1 &#125; print(&quot;**第\\(i - j)次 不需要移动**&quot;) print(&quot;+++\\(temp)放到\\(cntnts[j])的位置+++&quot;) cntnts[j] = temp print(cntnts) &#125; return cntnts&#125;使用：var nums = [11,3,27,8,9]nums = insertSort(nums, sortBy: &#123; (n1, n2) -&gt; Bool in return n1 &lt; n2&#125;)print(nums)结果：原始数组：[11, 3, 27, 8, 9]--------第1趟--------第0次 是否需要移动 ？+++第0次 需要移动++++++第0次 11向后移动到3的位置+++**第1次 不需要移动**+++3放到11的位置+++[3, 11, 27, 8, 9]--------第2趟--------第0次 是否需要移动 ？**第0次 不需要移动**+++27放到27的位置+++[3, 11, 27, 8, 9]--------第3趟--------第0次 是否需要移动 ？+++第0次 需要移动++++++第0次 27向后移动到8的位置++++++第1次 需要移动++++++第1次 11向后移动到27的位置+++**第2次 不需要移动**+++8放到11的位置+++[3, 8, 11, 27, 9]--------第4趟--------第0次 是否需要移动 ？+++第0次 需要移动++++++第0次 27向后移动到9的位置++++++第1次 需要移动++++++第1次 11向后移动到27的位置+++**第2次 不需要移动**+++9放到11的位置+++[3, 8, 9, 11, 27][3, 8, 9, 11, 27]比较字符串也是可以的：var strs = [&quot;11&quot;,&quot;3&quot;,&quot;27&quot;,&quot;8&quot;,&quot;9&quot;]strs = insertSort(strs, sortBy: &#123; (s1, s2) -&gt; Bool in return s1.compare(s2) == .orderedAscending&#125;)print(strs)结果：[&quot;11&quot;, &quot;27&quot;, &quot;3&quot;, &quot;8&quot;, &quot;9&quot;] 算法分析 设对象个数为n，则执行n-1趟 比较次数和移动次数与初始排列有关 最好情况下： 每趟只需比较 1 次，不移动 总比较次数为 n-1 最坏情况下：第 i 趟比较i次，移动i+1次 若出现各种可能排列的概率相同，则可取最好情况和最坏情况的平均情况平均情况比较次数和移动次数为n^2/4 结果： 时间复杂度为 o(n^2) 空间复杂度为 o(1) 是一种稳定的排序方法 折半插入排序 折半插入排序（Binary Insertion Sort）是一种插入排序算法，通过不断地将数据元素插入到合适的位置进行排序，在寻找插入点时采用了折半查找 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162/* 折半（二分）插入排序： 直接插入排序相当于在已经排好序的数组部分逐个比较 找到合适的插入位置，在查找插入的位置时从第一个到最后一个，因为已经插入的内容是有序的，所有很多冗余的比较。即如果插入的比最后一个还大(还小)，则仍然会从第一个比较到最后一个 折半插入排序是直接插入排序的优化版 优化： 由于直接插入排序是在查找插入位置的时候比较浪费时间，所以折半插入排序就优化查找。 由于在逐渐插入的时候已经插入部分是有序的，查找插入位置其实就是在已经排好序的数组中找到一个位置，这时二分查找算法正好适合。 *//// 寻找要插入的位置////// - Parameters:/// - contents: &lt;#contents description#&gt;/// - value: &lt;#value description#&gt;/// - low: &lt;#low description#&gt;/// - high: &lt;#high description#&gt;/// - Returns: &lt;#return value description#&gt;func binarySearchLocation&lt;T:Comparable&gt;(_ contents: inout [T],_ value:T ,_ low:Int,_ high:Int) -&gt;Int &#123; if high &lt;= low &#123; return (value &gt; contents[low]) ? (low + 1): low &#125; print(&quot;开始查找&quot;) let midIdx = low + (high - low ) / 2 print(&quot;----当前已排好序的数组内容部分的中间位置是：第\\(midIdx)个&quot;) if value == contents[midIdx] &#123; return midIdx + 1 &#125; if value &gt; contents[midIdx]&#123;//binarySearchLocation(&amp;contents, value, midIdx+1, high) print(&quot;-----从右边找&quot;) return binarySearchLocation(&amp;contents, value, midIdx+1, high) &#125; if value &lt; contents[midIdx]&#123;//binarySearchLocation(&amp;contents, value, low, midIdx - 1) print(&quot;-----从左边找&quot;) return binarySearchLocation(&amp;contents, value, low, midIdx - 1) &#125; return 0&#125;func binaryInsertSort&lt;T:Comparable&gt;(_ contents:inout [T]) -&gt; [T] &#123; var j = 0 for i in 1..&lt;contents.count &#123; print(&quot;\\n\\n***********第\\(i)次***********\\n&quot;) j = i - 1 let temp = contents[i] // 开始插入temp print(&quot;要插入的是\\(temp)&quot;)//binarySearchLocation(&amp;contents, temp, 0, j) let location = binarySearchLocation(&amp;contents, temp, 0, j) //找到temp应该插入的位置 print(&quot;-----找到了:第\\(location)个合适&quot;) while j &gt;= location &#123; print(&quot;--------第\\(j)个向后移动到第\\(j+1)个&quot;) contents[j+1] = contents[j] j -= 1 &#125; print(&quot;结果:\\n+++++ 把\\(temp)放到第\\(j+1)个位置 +++++&quot;) contents[j+1] = temp print(&quot;当前的排序结果是: \\(contents[0...i])&quot;) &#125; return contents&#125;var arr = [1,33,0,2,4,44,3]arr = binaryInsertSort(&amp;arr)print(&quot;\\n--------最终结果是---------\\n\\(arr)&quot;)排序过程和结果：***********第1次***********要插入的是33-----找到了:第1个合适结果:+++++ 把33放到第1个位置 +++++当前的排序结果是: [1, 33]***********第2次***********要插入的是0开始查找----当前已排好序的数组内容部分的中间位置是：第0个-----从左边找-----找到了:第0个合适--------第1个向后移动到第2个--------第0个向后移动到第1个结果:+++++ 把0放到第0个位置 +++++当前的排序结果是: [0, 1, 33]***********第3次***********要插入的是2开始查找----当前已排好序的数组内容部分的中间位置是：第1个-----从右边找-----找到了:第2个合适--------第2个向后移动到第3个结果:+++++ 把2放到第2个位置 +++++当前的排序结果是: [0, 1, 2, 33]***********第4次***********要插入的是4开始查找----当前已排好序的数组内容部分的中间位置是：第1个-----从右边找开始查找----当前已排好序的数组内容部分的中间位置是：第2个-----从右边找-----找到了:第3个合适--------第3个向后移动到第4个结果:+++++ 把4放到第3个位置 +++++当前的排序结果是: [0, 1, 2, 4, 33]***********第5次***********要插入的是44开始查找----当前已排好序的数组内容部分的中间位置是：第2个-----从右边找开始查找----当前已排好序的数组内容部分的中间位置是：第3个-----从右边找-----找到了:第5个合适结果:+++++ 把44放到第5个位置 +++++当前的排序结果是: [0, 1, 2, 4, 33, 44]***********第6次***********要插入的是3开始查找----当前已排好序的数组内容部分的中间位置是：第2个-----从右边找开始查找----当前已排好序的数组内容部分的中间位置是：第4个-----从左边找-----找到了:第3个合适--------第5个向后移动到第6个--------第4个向后移动到第5个--------第3个向后移动到第4个结果:+++++ 把3放到第3个位置 +++++当前的排序结果是: [0, 1, 2, 3, 4, 33, 44]--------最终结果是---------[0, 1, 2, 3, 4, 33, 44] 算法分析 折半查找比顺序查找快，所以折半插入排序就平均性能来说比直接插入排序要快 它所需要的关键码比较次数与待排序对象序列的初始排列无关，仅依赖于对象个数。在插入第 i 个对象时，需要经过 log2i +1 次关键码比较，才能确定它应插入的位置 当 n 较大时，总关键码比较次数比直接插入排序的最坏情况要好得多，但比其最好情况要差 在对象的初始排列已经按关键码排好序或接近有序时，直接插入排序比折半插入排序执行的关键码比较次数要少 折半插入排序的对象移动次数与直接插入排序相同，依赖于对象的初始排列 总结： 相比较直接插入排序而言 减少了比较次数，但没有减少移动次数 平均性能优于直接插入排序 时间复杂度为 o(n2) 空间复杂度为 o(1) 是一种稳定的排序方法 希尔排序希尔排序的出发点是： 直接插入排序在基本有序时，效率较高 在待排序的记录个数较少时，效率较高 基本思想&emsp;先将整个待排记录序列分割成若干子序列,分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。 分段方法&emsp;子序列的构成不是简单地“逐段分割”将相隔某个增量dk的记录组成一个子序列让增量dk逐趟缩短（例如依次取5,3,1）直到dk＝1为止。 优点&emsp;小元素跳跃式前移最后一趟增量为1时，序列已基本有序平均性能优于直接插入排序 排序过程例：关键字序列 T=(49，38，65，97, 76, 13, 27, 49*，55, 04） dk 值较大，子序列中对象较少，速度较快； dk 值逐渐变小，子序列中对象变多，但大多数对象已基本有序，所以排序速度仍然很快。 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566func insertionSort&lt;T:Comparable&gt;(_ list: inout [T],sortBy:(T,T) -&gt; Bool, start: Int, dk: Int) &#123; for i in stride(from: (start + dk), to: list.count, by: dk) &#123; let currentValue = list[i] var loc = i while loc &gt;= dk &amp;&amp; sortBy(list[loc - dk] ,currentValue)&#123; print(&quot;\\(list[loc - dk]) 向后移动\\(dk)位&quot;) list[loc] = list[loc - dk] loc -= dk print(&quot;list: \\(list)&quot;) &#125; list[loc] = currentValue &#125;&#125;func shellSort&lt;T:Comparable&gt;(_ contents: inout [T], sortBy:(T,T) -&gt; Bool) &#123; var sublistCount = contents.count / 2 while sublistCount &gt; 0 &#123; print(&quot;---- dk= \\(sublistCount) -----&quot;) for loc in 0..&lt;sublistCount &#123; print(&quot; loc = \\(loc)&quot;) insertionSort(&amp;contents, sortBy: sortBy, start: loc, dk: sublistCount) &#125; print(&quot;移动结果：\\(contents)&quot;) sublistCount = sublistCount / 2 &#125; &#125;var arr = [33,2,12,34,21]print(&quot;原始数组是：\\n\\(arr)\\n&quot;)shellSort(&amp;arr) &#123; (v1, v2) -&gt; Bool in return v1 &gt; v2&#125;print(&quot;最终结果：\\n\\(arr)\\n&quot;)结果：原始数组是：[33, 2, 12, 34, 21]---- dk= 2 ----- loc = 033 向后移动2位list: [33, 2, 33, 34, 21]33 向后移动2位list: [12, 2, 33, 34, 33] loc = 1移动结果：[12, 2, 21, 34, 33]---- dk= 1 ----- loc = 012 向后移动1位list: [12, 12, 21, 34, 33]34 向后移动1位list: [2, 12, 21, 34, 34]移动结果：[2, 12, 21, 33, 34]最终结果：[2, 12, 21, 33, 34] 算法分析 时间复杂度是n和d的函数： O(n^1.25）～ O(1.6n^1.25）—经验公式 空间复杂度为 o(1) 是一种不稳定的排序方法 交换排序冒泡排序基本思想 每趟不断将记录两两比较，并按“前小后大” 规则交换 12345621，25，49， 25*，16， 0821，25，25*，16， 08 ， 4921，25， 16， 08 ，25*，4921，16， 08 ，25， 25*，4916，08 ，21， 25， 25*，4908，16， 21， 25， 25*，49 优点 每趟结束时，不仅能挤出一个最大值到最后面位置，还能同时部分理顺其他元素； 一旦下趟没有交换，还可提前结束排序 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 使用泛型 需要外界传入是升序还是降序也就是 比较的规则 这样写的好处是 这个排序方法任何容器中装的任何类型都可以使用 比如 Int ，String ,甚至是你自定义的 model 根据你model任意一个字段 作比较都是可以的 *//// 冒泡排序////// - Parameters:/// - contents: 要比较的内容/// - sortBy: 排序规则/// - Returns: 返回排好序的内容func bubbleSort&lt;T&gt;(_ contents: inout [T],_ sortBy:(T,T)-&gt;Bool)-&gt;[T] &#123; guard contents.count &gt; 1 else &#123; return contents &#125; let n = contents.count for i in 0..&lt;n &#123; for j in 0..&lt;(n - 1 - i) &#123; if sortBy(contents[j],contents[j+1])&#123; contents.swapAt(j, j + 1) &#125; &#125; &#125; return contents&#125;使用：var nums = [11,3,27,8,9]nums = bubbleSort(&amp;nums, &#123; (n1, n2) -&gt; Bool in return n1 &gt; n2&#125;)print(nums)结果：[3, 8, 9, 11, 27]var strs = [&quot;11&quot;,&quot;3&quot;,&quot;27&quot;,&quot;8&quot;,&quot;9&quot;]strs = bubbleSort(&amp;strs, &#123; (n1, n2) -&gt; Bool in return n1.compare(n2) == .orderedAscending&#125;)print(strs)结果：[&quot;9&quot;, &quot;8&quot;, &quot;3&quot;, &quot;27&quot;, &quot;11&quot;] 算法分析 时间复杂度为 o(n^2) 空间复杂度为 o(1) 是一种稳定的排序方法 快速排序 基本思想： 任取一个元素 (如第一个) 为中心 所有比它小的元素一律前放，比它大的元素一律后放，形成左右两个子表； 对各子表重新选择中心元素并依此规则调整，直到每个子表的元素只剩一个 ①每一趟的子表的形成是采用从两头向中间交替式逼近法； ②由于每趟中对各子表的操作都相似，可采用递归算法。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133 /* 快速排序 */func quicklySort&lt;T: Comparable&gt;(_ contents:inout [T], low: Int, high: Int) &#123; var i = low var j = high guard low &lt; high,low &gt;= 0,high &lt; contents.count else &#123; return &#125; let piv = (low + (high - low) / 2)//标志位 let lowValue = contents[piv] // /* 一个循环的流程 从高位（右边）开始： 1 循环判断 当前高位的值是否大于标志位值 如果大于 则再向前一位比较 一直找到小于标志位的index 2 高位找到比标志位的值小的index 之后 停止开始从低位（左边）开始 低位开始 ： 1 循环判断 当前低位的值是否小于标志位 如果小于标志位则index + 1 进行下一位比较，直到找到比标志位大的值 2 低位找到比标志位大的值之后停止 交换： 从低位和高位找到了 比标志位大的值和比标志位小的值 然后这两个值交换 当i &gt;= j 即低位的index &gt;= 高位的index时 停止这一轮的循环 */ print(&quot;\\n标志位&quot;) print(lowValue) while i &lt; j &#123; while contents[j] &gt; lowValue &#123; j -= 1//高位的 index - 1 &#125; while contents[i] &lt; lowValue &#123; i += 1 &#125; if i &lt;= j &#123; contents.swapAt(i, j) print(&quot;contenti--&gt;\\(contents[i])&quot; + &quot;和&quot; + &quot; contentj--&gt;\\(contents[j])&quot; + &quot;交换&quot;) /* 交换完成后 i 向下一步 j 向前一步 */ i += 1 j -= 1 &#125; &#125; print(&quot;本轮排序结果:\\n\\(contents)&quot;) print(&quot;\\n----------下一轮分割线--------------&quot;) print(&quot;low = \\(low),high = \\(high), i = \\(i),j = \\(j)&quot;) if low &lt; j &#123; print(&quot;\\n----------左边--------------&quot;) quicklySort(&amp;contents, low: low, high: j) &#125; if i &lt; high &#123; print(&quot;\\n----------右边--------------&quot;) quicklySort(&amp;contents, low: i, high: high) &#125;&#125;var arr2 = [7,32,2,1,5]print(&quot;初始化数组&quot;)print(arr2)quicklySort(&amp;arr2, low: 0, high: arr2.count - 1)结果：初始化数组[7, 32, 2, 1, 5]标志位2contenti--&gt;1和 contentj--&gt;7交换contenti--&gt;2和 contentj--&gt;32交换本轮排序结果:[1, 2, 32, 7, 5]----------下一轮分割线--------------low = 0,high = 4, i = 2,j = 1----------左边--------------标志位1contenti--&gt;1和 contentj--&gt;1交换本轮排序结果:[1, 2, 32, 7, 5]----------下一轮分割线--------------low = 0,high = 1, i = 1,j = -1----------右边--------------标志位7contenti--&gt;5和 contentj--&gt;32交换本轮排序结果:[1, 2, 5, 7, 32]----------下一轮分割线--------------low = 2,high = 4, i = 3,j = 3----------左边--------------标志位5contenti--&gt;5和 contentj--&gt;5交换本轮排序结果:[1, 2, 5, 7, 32]----------下一轮分割线--------------low = 2,high = 3, i = 3,j = 1----------右边--------------标志位7contenti--&gt;7和 contentj--&gt;7交换本轮排序结果:[1, 2, 5, 7, 32]----------下一轮分割线--------------low = 3,high = 4, i = 4,j = 2 算法分析 时间效率：O(nlog2n) —每趟确定的元素呈指数增加 空间效率：O（log2n）—递归要用到栈空间 稳 定 性： 不稳定 —可选任一元素为支点。 选择排序简单选择排序基本思想&emsp;每一趟在后面 n-i +1个中选出关键码最小的对象, 作为有序序列的第 i 个记录 实现算法分析 时间复杂度：O(n²) 空间复杂度：O(1) 不稳定 堆排序基本思想 （1）将序列r[1..n] 建初堆，交换r[1]和r[n]，则r[n]为关键字最大的记录。 （2）将r[1..n-1]重新调整为堆，交换r[1]和r[n-1] ，则r[n-1]为关键字次大的记录。 （3）循环n-1次，直到交换了r[1]和r[2]为止，得到了一个非递减的有序序列r[1..n]。 算法分析 时间效率：O(nlog2n) 空间效率：O（1） 稳 定 性：不稳定 ==适用于n 较大的情况==","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.wuchao.net.cn/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.wuchao.net.cn/tags/数据结构/"}]},{"title":"自定义UIActionSheet","slug":"自定义UIActionSheet","date":"2018-06-18T02:37:40.000Z","updated":"2018-09-29T07:50:37.000Z","comments":true,"path":"2018/06/18/自定义UIActionSheet/","link":"","permalink":"http://www.wuchao.net.cn/2018/06/18/自定义UIActionSheet/","excerpt":"","text":"背景&emsp; 在开发中用过很多次 UIActionSheet ,有的设计师有自己的想法,用”iOS系统提供的有自己的样式,要不就用系统的样式吧”这样的理由人家根本不买账,来一句:”不行,还是按照我设计的样式来吧”。没办法，只有自己去自定义了。在维护的 APP 大改版时，有好几种不一样的样式，即使看上去一样的样式，有些细节也不一样，比如字体，有的是17号字有的是15号字。每一个选项的高有的是40p 有的是55p。 为了满足多种样式，只有自己定义了一个组件,自动布局要依赖 SnapKit. 类之间的关系设计&emsp; 如果只是用语言描述,感觉总是苍白无力描述不清,为了让感兴趣的小伙伴迅速了解类与类之间的关系以及整体的架构,所以简单的画了张图,然后在解释下. &emsp; 首先说下JWCBaseContainer,这个类主要是一个 base 类,方便与有类似功能的子类继承使用父类的 API。 功能： 提供列表的隐藏动画和弹出动画 处理点击列表空白处事件(隐藏列表) 提供屏幕旋转事件,供子类处理 如下123456789101112131415161718192021//显示/隐藏动画 func transAni(type:String ,subType:String,function:String) -&gt; CATransition &#123; let animation = CATransition() animation.timingFunction = CAMediaTimingFunction(name: function) animation.duration = 0.3 animation.type = type animation.subtype = subType return animation &#125; // 透明度渐渐变淡动画 func opacityReduce_Animation(time : TimeInterval) -&gt; CABasicAnimation &#123; let animation = CABasicAnimation(keyPath:&quot;opacity&quot;) animation.fromValue = 1 animation.toValue = 0 animation.duration = time animation.autoreverses = true animation.isRemovedOnCompletion = true animation.fillMode = kCAFillModeForwards animation.timingFunction = CAMediaTimingFunction.init(name: kCAMediaTimingFunctionEaseIn) return animation &#125; &emsp; 其次,JWCActionSheetItem类,这个类是比较重要的类,主要供使用这配置ActionSheet 的 每一个 item 的样式,类似于我们常用的 tableView的数据 Model,主要可以配置每一个 item 的一下内容; 1234567891011121314//标题 var title:String = &quot;&quot; //标题颜色: 默认为黑 var titleColor:UIColor = UIColor.black // 标题的字体,默认为14 var titleFont = UIFont.systemFont(ofSize: 14) // item 的高度 默认为30 var height:Float = 30 //两个 item 的之间的分割线颜色 默认为灰色 var bottomLineColor:UIColor = UIColor.init(white: 0, alpha: 0.2) //两个 item 的之间的分割线高度 默认为1 var bottomLineHeight:Float = 1.0 // item 的背景颜色 var backgroundColor:UIColor = UIColor.white 为了方便使用,声明了两个便利构造函数,根据需要选择合适的便利构造函数 1convenience init(title:String,titleColor:UIColor,titleFont:UIFont,height:Float,bottomLineColor:UIColor,bottomLineHeight:Float,backgroundColor:UIColor) 1convenience init(title:String,titleFont:UIFont,titleColor:UIColor,height:Float,bottomLineHeight:Float) &emsp; 再者,JWCActionSheetCell 类,此类功能比较简单,主要是在被赋值一个JWCActionSheetItem类型的数据源时,根据JWCActionSheetItem的内容来渲染自己的 UI &emsp; 最后,JWCActionSheet 类。此类是前面几个类的应用与集成。提供两个类方法，方便使用： JWCActionSheet中比较重要的几个方法： 12345678910/// 类方法1 /// /// - Parameters: /// - titles: 数据源 String 类型 /// - headView:headerView 如果没有则传 nil /// - Returns: class func actionSheet(titles:[String],headView:UIView?) -&gt; JWCActionSheet &#123; let action = JWCActionSheet.init(titles: titles, headView: headView) return action &#125; 其中 headerView 是可选的，根据自己的需要，在外面生成一个继承自 UIView 的类传入即可。这个传入的参数是 String 类型的数组，因为此方法会生成一个默认样式的 ActionSheet ，主要是为了方便 注意： ==headerView 传入时一定要有大小== 第二个类方法： 12345678910/// 类方法2 /// /// - Parameters: /// - items: 数据源 JWCActionSheetItem 类型的数组 /// - headView: headerView 如果没有则传 nil /// class func actionSheet(items:[JWCActionSheetItem],headView:UIView?) -&gt; JWCActionSheet &#123; let action = JWCActionSheet.init(items: items, headView: headView) return action &#125; 这个类方法和第一个类方法的区别之处就在于，传入的参数有区别，此类方法传入的是 JWCActionSheetItem 类型的数组，传入的JWCActionSheetItem 都是使用者根据自己的需要自己定义的。 注意：如果默认的样式无法满足自己的需要则可以调用此方法 JWCActionSheet的 show 方法： 12345678910111213141516171819202122232425/// 弹出 /// /// - Parameter callback: &lt;#callback description#&gt; func show(callback:(ResultCallback?)) &#123; resultCallback = callback var window: UIWindow! = UIApplication.shared.delegate?.window as? UIWindow if window == nil &#123; window = UIApplication.shared.keyWindow &#125; if window.isKind(of: UIWindow.self) &#123; window.addSubview(self) self.snp.makeConstraints &#123; (make) in make.edges.equalTo(window) &#125; self.setNeedsLayout() self.layoutIfNeeded() &#125; if tableView.isHidden &#123; tableView.isHidden = false &#125; let trans = transAni(type: kCATransitionMoveIn, subType: kCATransitionFromTop, function: kCAMediaTimingFunctionEaseOut) tableView.layer.add(trans, forKey: nil) &#125; 当生成JWCActionSheet的对象后，需要这是展示JWCActionSheet的时候调用，当发生选择点击事件时回走ResultCallback 闭包，可以在此闭包内处理选择事件 JWCActionSheet 内部逻辑处理 tableView 的高 tableView 的高根据每一个 Item 的高和底部下划线的高相加而得出 点击事件：点击事件分为两种 (1) 点击ActionSheet空白处: 隐藏ActionSheet,回调出去的值为 index = -1 title = nil (2) 选中某一个item 回调出去的值 index = 当前 item 的 index title 为当前 item 的 title tableView 的 headerView: 在提供的对外初始化的两个方法中有 headerView 参数,如果没有则传入 nil 反之传入自定义的 headerView 附:使用例子 123456// MARK: 默认样式 func style0() &#123; JWCActionSheet.actionSheet(titles: [&quot;拍照&quot;,&quot;相册选取&quot;,&quot;取消&quot;],headView:nil).show &#123; (index, title) in print(&quot;index:\\(index),title:\\(String(describing: title))&quot;) &#125; &#125; 1234567891011121314// MARK: 添加头视图1 func style3() &#123; let headerView = UILabel.init(frame: CGRect.init(x: 0, y: 0, width: UIScreen.main.bounds.width, height: 35)) headerView.text = &quot;请选择获取照片的方式&quot; headerView.textAlignment = .center headerView.font = UIFont.systemFont(ofSize: 15) headerView.textColor = UIColor.red headerView.backgroundColor = UIColor.blue JWCActionSheet.actionSheet(titles: [&quot;拍照&quot;,&quot;相册选取&quot;,&quot;取消&quot;], headView: headerView).show &#123; (index, title) in print(&quot;index:\\(index),title:\\(String(describing: title))&quot;) &#125; &#125; 几张效果图: 写在后面的话&emsp; 感觉这个小组件还是比较简单,也有一些缺点,比如其内部自动布局要依赖于 SnapKit。写出来的主要目的是不能让自己犯懒，如果一直拖着不写博客，时间久了，就很难再写了，会越来越懒。手动[Doge] Demo 在此 要养成随手点赞的好习惯 O(∩_∩)O~~","categories":[{"name":"组件化","slug":"组件化","permalink":"http://www.wuchao.net.cn/categories/组件化/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://www.wuchao.net.cn/tags/UI/"}]},{"title":"TextField 输入身份证号手机号银行卡号格式化解决方案","slug":"TextField输入身份证号手机号银行卡号格式化解决方案 ","date":"2018-01-10T04:56:01.000Z","updated":"2018-09-29T07:50:37.000Z","comments":true,"path":"2018/01/10/TextField输入身份证号手机号银行卡号格式化解决方案 /","link":"","permalink":"http://www.wuchao.net.cn/2018/01/10/TextField输入身份证号手机号银行卡号格式化解决方案 /","excerpt":"","text":"问题描述 TextField中输入身份证号，手机号，银行卡号时每隔几位需要添加空格。当输入错误时需要从末尾或者中间删除，删除之后还要保持当前textfield的中内容保持每隔几位就有一个空格的格式。这篇文章主要是为了解决这个问题 ==解决上面的问题主要要解决两个点:== 光标的位置 空格的位置 上面的两种情况又可以分为: 从最后一位删除 从中间删除 一次删除一个和多个 从最后一位添加 从中间添加 一次添加一位和多位 这几种情况都要考虑光标的位置和空格的位置,每次添加和删除都要重新计算. 实现：首先详细说下👇的这个代理方法： 1- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string rangeshouldChangeCharactersInRange ：有location 和length 两个参数location 是即将被替代的内容的位置length 是即将被替代的内容的长度 string用来替代在range位置内容的字符串 假如：textfield中有内容为1234 三种情况解释下string 和range参数 ： 光标在最后一位时删除一位 ：那么string就是为空 range的location 就是光标前面的内容的下标即为3 length就是1 表示被删除的内容长度为1 ，结果是string占据了range表示的位置 即123，3后面的4被空字符串占据了即被删除了 光标在最后一位删除两位：操作，长按textfield选中23，点击删除。可以发现string依旧为空 ，range变为 location=1, length=2 即位置在下标为1 长度为2的字符串被空字符串替代了，还剩1，所谓的23被删除了 添加一个：光标在最后一位。输入一个2，此时range：location为1，length为0 即被替代的内容位置在下标为1的地方，长度是空。string为2，那么结果就是一个下标为1，长度为0的字符串被string替代了，即textfield内容添加了一个2，复制到textfield中的内容range 和 string 也是同样的适用 说的这么详细主要为下一步做准备。 UITextInput协议 中的几个属性和方法设置光标的位置需要下面的两个方法 12345// 获取以fromPosition为基准偏移offset的光标位置。- (nullable UITextPosition *)positionFromPosition:(UITextPosition *)position offset:(NSInteger)offset;// 创建一个UITextRange- (nullable UITextRange *)textRangeFromPosition:(UITextPosition *)fromPosition toPosition:(UITextPosition *)toPosition; 设置光标位置的方法 根据UITextInput协议的两个方法可以得出设置光标的位置的方法 1234567+ (void)setCursorLocation:(UITextField *)textField withOffset:(NSInteger) offset&#123; // offset 光标要所处的位置 // 生成新的postion UITextPosition *newPostion = [textField positionFromPosition:textField.beginningOfDocument offset:offset] ; //设置光标 从一个点到另外一个点如果两个点一样 那么光标就在这个点 textField.selectedTextRange = [textField textRangeFromPosition:newPostion toPosition:newPostion];&#125; ==注意==：在textField中，有一个属性称之为selectedTextRange，这个属性为UITextRange类型，包含[start,end)两个值，通过实验可以发现，在没有文字被选取时，start 和 end的值一样 代表当前光标的位置；当有区域被选择时，start和end分别是选择的头和尾的光标位置 可以看出 setCursorLocation 方法中很重要的一个参数是偏移量 添加空格的方法 12345678910111213// 在指定的位置添加空格+(NSString*)insertString:(NSString*)string withBlankLocations:(NSArray&lt;NSNumber *&gt;*)locations &#123; if (!string) &#123; return nil; &#125; NSMutableString* mutableString = [NSMutableString stringWithString:[string stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;]]; for (NSNumber *location in locations) &#123; if (mutableString.length &gt; location.integerValue) &#123; [mutableString insertString:@&quot; &quot; atIndex:location.integerValue]; &#125; &#125; return mutableString;&#125; 上面这个方法是根据传入的空格的位置,遍历整个字符串,在指定的位置为字符串添加一个空格. 这个方法调用的时机就是 textField 中的 text 发生改变时调用,比如说删除或者增加字符串 ++那么以下就根据不同的情况来计算偏移量设置光标 和 添加空格++ 删除字符串如何判断是点击了键盘的删除如上面所说 在1- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string 这个代理方法中 当string为空时就是删除。range是一个位置表示string的位置 如果string为空时 range.length 表示删除的长度 删除一位如果 range.length == 1如果string 为空 且 range的location 为当前textField.text的长度减一 即location是textField.text的最后一个字符时 表示在最后一位删除 ① 如果在最后一位删除一位不需要设置光标的位置和添加空格 ② 如果不是最后一位删除一位则要判断删除的是不是空格。如果是空格则会连续删除两次 1234567// 不是最后一位 NSInteger locationOffset = range.location; if (range.location &lt; text.length &amp;&amp; [text characterAtIndex:range.location] == &apos; &apos; &amp;&amp; [textField.selectedTextRange isEmpty]) &#123; [textField deleteBackward]; // 删除空格 locationOffset --; &#125; [textField deleteBackward];// 删除空格前面的字符 上面的代码调用了两次[textField deleteBackward] 删除了两次 此时需要修改空格的位置和光标的位置,偏移量 offset 就是 range.location 的值 ,每删除一位 offset 就要减1 删除多位同删除一位的逻辑一样 string为空切 range.length &gt; 1 就表示一次删除多位 ① 是否是在最后一位开始删除,如果再最后一位开始删除那么仍然不需要设置光标的位置,但是需要设置空格的位置 ② 如果不是最后一位开始删除,则需要计算光标的位置,偏移量仍然是当前 range.location 添加字符串如何判断是添加?如上面所说 在1- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string 这个代理方法中 当string不为空时就是添加。range是一个位置表示string的位置 如果string不为空时 range.length 表示添加的字符串的长度 如果所输入的字符串长度还没有超出限制则直接添加到 textField 中然后在预定的位置添加空格 1234// 添加到textField 中 这个方法是 UIKeyInput 协议中的方法[textField insertText:string];//textField中的字符串发生变化需要重新设置空格textField.text = [self insertString:textField.text withBlankLocations:blankLocation]; 此时要计算偏移量 ,在计算是光标的位置是 range.location + string.length ,但是如果在光标位置出正好有空格则offset需要 +1 如下 12345678NSInteger offset = range.location + string.length; for (NSNumber *location in blankLocation) &#123; if (range.location == location.integerValue) &#123; offset ++; &#125; &#125; [self setCursorLocation:textField withOffset:offset]; 通过以上几种情况就可以解决文章开头描述的问题了. Demo 在这里我是 Demo 如果解决了您的问题,请点赞支持下哈!","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.wuchao.net.cn/categories/Objective-C/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://www.wuchao.net.cn/tags/UI/"}]},{"title":"手把手教你高效快捷的创建Swift Framework","slug":"手把手教你高效快捷的创建SwiftFramework","date":"2018-01-07T02:26:00.000Z","updated":"2018-09-29T07:50:37.000Z","comments":true,"path":"2018/01/07/手把手教你高效快捷的创建SwiftFramework/","link":"","permalink":"http://www.wuchao.net.cn/2018/01/07/手把手教你高效快捷的创建SwiftFramework/","excerpt":"","text":"文章首发在简书 手把手教你高效快捷的创建Swift Framework 前言:&emsp;在我们开发中最离不开的就是 Framework 比如 UIKit.framework,所以对 framework 应该是比较熟悉的,那么在开发中也经常把自己的所做模块的代码做成 framework,场景如下: 方便给别人使用我们自己的模块 提供给第三方使用,且又不愿意别人看到自己的内部实现逻辑 模块化提高代码的复用性 动态库和静态库的区别静态库：&emsp;链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。 动态库：&emsp;链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。 区别: 静态库和动态库是相对编译期和运行期的：静态库在程序编译时会被链接到目标代码中，程序运行时将不再需要改静态库；而动态库在程序编译时并不会被链接到目标代码中，只是在程序运行时才被载入，因为在程序运行期间还需要动态库的存在。 总结： 同一个静态库在不同程序中使用时，每一个程序中都得导入一次，打包时也被打包进去，形成一个程序。而动态库在不同程序中，打包时并没有被打包进去，只在程序运行使用时，才链接载入（如系统的框架如UIKit、Foundation等），所以程序体积会小很多，但是苹果不让使用自己的动态库，否则审核就无法通过。 下面就一步一步的演示如何制作一个 framework, 以及制作自己的 framework 中可能会遇到的坑,以及如何解决。作为演示做个比较简单的数组乱序的 framework 新建一个 framework File -&gt; new -&gt; Progect-&gt; 选中 iOS -&gt; Cocoa Touch Framework 点击 Next -&gt; Protect Name 为 ArrayDisorderSDK launguage 选为 Swift 点击 Next 新建完成 在 Framework 中新建文件:选 source 的时候 可以选择Cocoa Touch Class 或者Swift File 等 都是可以的可以根据自己的需要选择 类名就取为 ArrayDisorder，然后新建完成 在ArrayDisorder 类中写下数组乱序的代码 123456789101112131415open class ArrayDisorder: NSObject &#123; open func disorder (orders:Array&lt;Any&gt;) -&gt; Array&lt;Any&gt; &#123; var temp = orders var count = Int(temp.count) while count &gt; 0 &#123; let index = Int(arc4random_uniform(UInt32(Int32(count)))) let last = Int(count-1) temp.swapAt(index, last) count -= 1 &#125; return temp &#125;&#125; 注意：也许你会发现 在 class 前面或者在disorder方法前有 open 关键字，说到这里先说下和这个地方和oc 制作 Framework 不同的地方 oc 制作 framework 会生成一个和 framework 名字一样的类 只有.h 文件 内容如下 12345678//! Project version number for ArrayDisorderSDK.FOUNDATION_EXPORT double ArrayDisorderSDKVersionNumber;//! Project version string for ArrayDisorderSDK.FOUNDATION_EXPORT const unsigned char ArrayDisorderSDKVersionString[];// In this header, you should import all the public headers of your framework using statements like #import &lt;ArrayDisorderSDK/PublicHeader.h&gt;上面的这句注释说的很清楚 如果你想让别人外面找到你在 framework 中的类你必须像 &lt;ArrayDisorderSDK/PublicHeader.h&gt; 这种格式一样把 你的类导入这文件中 最后一句 1// In this header, you should import all the public headers of your framework using statements like #import &lt;ArrayDisorderSDK/PublicHeader.h&gt; 说的很清楚如果你想让别人外面找到你在 framework 中的类你必须像 &lt;ArrayDisorderSDK/PublicHeader.h&gt; 这种格式一样把 你的类导入这文件中,在编译成 SDK 之后生成的头文件中就可以看到你对外开放的类和方法 创建 Swift framework也会生成一个这样的文件但是 则不需要这样导入头文件。只需要在要暴露给使用者的类名和方法名前面写上 Open 或者 Public 当编译成 Framework 之后会生成 “你的 framework 的名字-Swift.h”的文件 在这个文件中你可以看到类名前面 表有 Public 或者 Open 关键字的类. 什么时候用 Open 什么时候用 Public? Open 在作用域外是可以被访问,继承 ,用 Open 关键字修饰的开放类成员在作用域之外是可访问和可覆盖的。 Pubic 在作用域外是可访问的，但在作用域之外没有子类。公共类成员是可访问的，但在作用域之外是不可覆盖的。 配置你的 Framework 配置动态或者静态库 点击 framework 的 target build settings - linking -&gt; Mach-o Type -&gt; Static Library 或者 Dynamic Library Development Target 在这个 Demo 中 设置为支持 iOS 8 还要配置 运行编译的成的 Build Configuration 为 release 如果不是 release 则在 release 环境下运行会出错 走到这一步,基本 Framework 已经初步完成, Com + B 注意:编译的时候 选择的 Device 如果是模拟器 则生成的是 x86架构,仅支持模拟器,在真机上这个编译的 Framework 则不能用 ,如果 Device 不选或者选择你连接在电脑上的真机,则编译成的是arm64 可以在真机上跑但是不能用在模拟器,如果制作的 framework 需要在模拟器和真机上用,则需要把这两个架构合成一块,这个==待会下面详细讲.== 点击生成的 Framework 然后 Show In Finder 如图中所示,生成了ArrayDisorderSDK.framework 那么这个文件就可以直接给别人使用了. 调试 Framework在我们写代码时一般都习惯于边写边调试,那么在制作 Framework 时有两种方法调试我们的 Framework 第一种(不推荐)新建一个名字是 testArrayDisorderDemo的 Progect 如下 直接把编译好的 Framework 拖入到 testArrayDisorderDemo中 然后 import ArrayDisorderSDK 在 ViewDidLoad 中写入如下代码 1234let disOrder = ArrayDisorder() //Framework 中的封装了乱序功能的类 //disOrder.disorder(orders: [1,2,3,4,5,6,7,8,9]) 调用ArrayDisorder 对外公布的类 print(disOrder.disorder(orders: [1,2,3,4,5,6,7,8,9])) // 输出:[8, 6, 2, 5, 3, 4, 7, 9, 1] 到此,我们简单的 framework 就可以算完成了. 但是这中调试framework 的方法效率比较低,我们每一次调试都需要重新把原来的 framework 从testArrayDisorderDemo中删除然后重新导入.这样比较麻烦.那么下面有一种比较方便高效的方法。 第二种 创建一个依赖工程(推荐)还是testArrayDisorderDemo 这个测试 Framework 的工程 如图所示 两者都在桌面上 然后把ArrayDisorderSDK 拖入到testArrayDisorderDemo 文件中 如图 然后打开testArrayDisorderDemo – &gt; General -&gt;Embedded Binaries-&gt; 点击加号-&gt; add Other -&gt; 选中ArrayDisorderSDK.xcodeproj 如下图 再选择 Target 的地方你会发现 现在已经有连个 Taeget 一个是testArrayDisorderDemo 一个是ArrayDisorderSDK 如果选中 testArrayDisorderDemo就是运行 Demo 如果选中ArrayDisorderSDK 就是编译 SDK 这时你会发现可以直接在testArrayDisorderDemo 的 ViewController 中直接 导入ArrayDisorderSDK就可以了 不需要在删除然后再拖入了. 最重要的是 ,当你选中的testArrayDisorderDemo Tagret 运行的时候 当程序走到 framework 中去的时候 你还可以打断点等方式调试. 效率会很高. 注意: 当你修改 framework 中的代码时要想测试下修改的效果,你必需先编译下你的 framework 的 target 如本文中所示的就要先编译下ArrayDisorderSDK的 target,不编译的话就相当于你的 测试你 framework 的 Demo 用的还是原来的 framework 而不是修改后的 关于 Framework 的CPU架构CPU 的架构在不同的机型上有不同的主要有一下: arm7: 在最老的支持 iOS7的设备上使用arm7s: 在 iPhone 5 和 iPhone 5c 上使用arm64: 在 iPhone 5s 的64位 ARM 处理器上i386: 在32位模拟器上使用x86_64: 在64位模拟器上使用 当然一个 Framework 不需要全部支持,可以根据需要. 如上文所说, 编译的时候 选择的 Device 如果是模拟器 则生成的是 x86架构,仅支持模拟器,在真机上这个编译的 Framework 则不能用 ,如果 Device 不选或者选择你连接在电脑上的真机,则编译成的是arm64 和 arm7 可以在真机上跑但是不能用在模拟器,如果制作的 framework 需要在模拟器和真机上用,则需要把这两个架构合成一块,那么这就需要合成架构了. 首先,我们要了解,如何查看一个 framework 的架构 用命令: lipo -info 注意 -info 中 - 和 info 没有空格,info 后面有一个空格 如图所示 把ArrayDisorderSDK 文件拖入控制台 然后回车控制台就可以输出ArrayDisorderSDK 的 CPU 架构 如 armv7 arm64 这个是支持真机的,如果支持模拟器则不行的,需要重新编译: 在上图中也能看到 当选中ArrayDisorderSDK.framework show in Finder 时你会发现在上一层有四个文件夹(最多为四个如果你只在 relesae 下真机上编译 就只有一个文件夹) ,主要分为 Debug 和 release 两种环境下的 真机和模拟器Debug-iphoneos/ Debug-iphonesimulator Debug 下的模拟器Release-iphoneos/Release-iphonesimulator relesase 下的真机和模拟器 那么我们需要做的就是把Release-iphoneos/Release-iphonesimulator 下的两种架构合成一个 架构合并:第一种方法(不推荐)用命令: lipo -create xx ## -output @@加入你framework 的名字是 ArrayDisorderSDK xx: 表示Release-iphoneos 文件夹下的 ArrayDisorderSDK.framework/ArrayDisorderSDK 的路径 ##: Release-iphonesimulator 文件夹下的 ArrayDisorderSDK.framework/ArrayDisorderSDK ##: 生成的文件名 是和你的 framework 同名的,比如叫ArrayDisorderSDK 生成的output 出来的ArrayDisorderSDK是需要把Release-iphoneos 文件夹下的 ArrayDisorderSDK.framework 的中的ArrayDisorderSDK 替换掉的. 注意:-create 以及-output 在 create 和 output前面以- 是没有空格,但是在create 和 output后面是有一个空格的 上面说的可能不太好懂,那么下面演示一下,化繁为简:如图 总之这种方法还是太麻烦的,容易出错,下面介绍另外一种比较简单的. 第二种:(推荐) 选中ArrayDisorderSDK.xcodeproj 新建一个名字为UniversalArrayDisorder 的 target 选中 UniversalArrayDisorder –&gt; Build Phases –&gt; 选中加号 –&gt; 选中 New Run Script Phase 然后在 脚本地址 下载一个名为universal-framework.sh 文件 把文件内容拷贝到如图所示 注意:universal-framework.sh 中 ${PROJECT_NAME} 要把这个换成你自己的 framework 的名字 设置完成之后 ,编译UniversalArrayDisorder target 编译成功之后,会自动打开一个生成 Framework 的文件夹,然后再查看架构信息你会发现,即支持真机也支持模拟器啦. 你可能会遇到的坑1 找不到 framework 错误提示: 1No such module xxx 解决: 原因就是 Framework Search Path 中的路径错了 可以参考 参考地址 解决方案手动设置 这个路径是你向引用你的 framework 的项目拖自定义的 framework 时自动生成的 所以简单的解决方案就是 删除 framework 重新拖入 注意:拖的时候一定要确保 framework 和目标项目在同一个文件夹下,这样就不会出问题了 2 找不到类 错误提示: 12&apos;xxxx&apos; is unavailable: cannot find Swift declaration for this class xxxx 表示 framework 中的类名 解决: framework 的架构错误: 如果如你的 framework 需要在模拟器上跑 那么你的 framework 必须包含x86 如果还需要在真机上跑 那么必须包含arm64 架构 可以用命令检查架构 lipo -info 参考 3 动态库和静态库的问题 错误提示: 12Reason: image not found Message from debugger: Terminated due to signal 6 解决: 动态库 embedded binaries没有 添加 your framework name.framework -&gt; 添加 如果是静态库 则不需要添加 写在最后:参考文献: 1 :https://medium.com/flawless-app-stories/getting-started-with-reusable-frameworks-for-ios-development-f00d74827d11 2 :https://medium.com/captain-ios-experts/develop-a-swift-framework-1c7fdda27bf1 3 :https://www.raywenderlich.com/65964/create-a-framework-for-ios 本文是在我开发中遇到的问题的一个总结,总体倾向与如何更方便高效的创建自己的 framework,对于 OC 和 Swift 创建 framework 的异同介绍较少,由于本文重点不在于此,有机会下次再总结. 由于工作繁忙,水平有限,难免有不全,或者说的不合适的地方,还请看到此文章的朋友不吝赐教.或者你对本文中有不理解的地方,都希望在评论区交流. 如果此文解决了你的问题,还请点赞支持下。 Demo地址","categories":[{"name":"组件","slug":"组件","permalink":"http://www.wuchao.net.cn/categories/组件/"}],"tags":[{"name":"Framework","slug":"Framework","permalink":"http://www.wuchao.net.cn/tags/Framework/"}]},{"title":"collectionView无限轮播设计思路","slug":"collectionView无限轮播设计思路","date":"2017-08-20T02:29:35.000Z","updated":"2018-09-29T07:50:37.000Z","comments":true,"path":"2017/08/20/collectionView无限轮播设计思路/","link":"","permalink":"http://www.wuchao.net.cn/2017/08/20/collectionView无限轮播设计思路/","excerpt":"","text":"collectionView 无限轮播设计思路原来用scrollview实现过无限轮播，每张轮播图是UIImageView，有页码，有标题，用scrollView实现起来比较简单。但是最近遇到一个需求。每个轮播图上有好几个头像和按钮，用目前项目中用scrollView实现的轮播图实现不了，或者说改动比较大。于是就想着用collectionView实现。当时的初步构想就是每张轮播图就是一个自定义的cell ，这样就比较简单了。在没开始之前先在在网上找了一下，好多demo实现的方式都是一样的，就是把dataSource设为一个很大的数字，创建n多个cell，用来达到无限。。。按道理，先不说性能如何，就是设为比较大的数字，在理论上该数字也是有限的！并不是无限轮播~~~ 我的大致设计思路如下： 12341，定时器。用于在固定的间隔滚动一页2，collectionView，自定义一个cell用于轮播展示3，对collectionView的数据源A进行处理。新建一个数组B，把A数组的最后一个添加到B数组的第一个，把A数组的第一个添加到B数组的最后一个。这样B数组中就比源数组A多了两个数据。在(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section 中返回的是数组B的长度4， 在scrollview的相关代理方法中处理相应人为拖动操作和滚动 下面结合代码来说每步的具体实现。 1&gt; 每隔固定的时间调用此方法实现滚动 123- (void)startScrollAutomtically &#123; // 每次加 self.bounds.size.width 宽度 [self setContentOffset:CGPointMake(self.contentOffset.x + self.bounds.size.width, self.contentOffset.y) animated:YES];&#125; 2&gt; 对数据源进行处理 如果原始数据源的长度大于一个则启动定时器，反之不启动定时器。如果原始数据源的长度大于一个则需要处理数据源，即上面3所说的。另外刷新完数据源则默认滚动到第一页 123456789101112131415161718- (void)configWithData:(NSArray&lt;id&lt;JWCBannerDataProtocol&gt;&gt; *)datas &#123; if (_originalData.count &gt; 1) &#123; NSMutableArray *tempArr = [[NSMutableArray alloc] initWithArray:_originalData]; [tempArr insertObject:[_originalData lastObject] atIndex:0]; [tempArr addObject:[_originalData firstObject]]; self.customData = tempArr.copy; dispatch_async(dispatch_get_main_queue(), ^&#123; [self scrollToPage:1 animated:YES]; &#125;); [self startTimer]; self.isOnlyOne = NO; &#125; else &#123; self.customData = _originalData.copy; [self stopTimer]; self.isOnlyOne = YES; self.currentIndex = 0; &#125;&#125; 3&gt; scrollView的几个代理方法 123456789101112131415161718// 将要开始拖拽 停止定时器- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView &#123; [self stopTimer];&#125;// 将要停止拖拽 开始定时器- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset &#123; if (_originalData.count &gt; 1) &#123; //如果数据源大于1 才启动定时器 [self startTimer]; &#125;&#125;// 停止拖动- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123; [self checkPageIndx];&#125;// 动画停止- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView &#123; [self checkPageIndx];&#125; // 此方法是人为拖动完成需要做的处理 12345678910- (void)checkPageIndx &#123; //当滚动到最后一张图片时，继续滚向后动跳到page 1 if (self.contentOffset.x &gt;= (self.customData.count - 1) * self.bounds.size.width) &#123; [self scrollToPage:1 animated:NO]; &#125; //当滚动到第一张图片时，继续向前滚动跳到倒数第二 if (self.contentOffset.x &lt; 0) &#123; [self scrollToPage:self.customData.count - 2 animated:NO]; &#125;&#125; // 停止滚动 计算当前的index 此方法是无论人为还是自动改变scrollview的 offset 都会调用此方法 所以在此方法中计算当前的index 这个index可用于显示页码 123456789101112- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123; CGFloat width = self.frame.size.width; NSInteger index = (scrollView.contentOffset.x + width * 0.5 ) / width; if (index == 0) &#123; index = _originalData.count - 1; &#125; else if (index &gt;= _customData.count - 1) &#123; index = 0; &#125; else &#123; index = index - 1; &#125; self.currentIndex = index;&#125; &emsp;以上只是写了大致的思路，具体的实现代码在 Demo","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.wuchao.net.cn/categories/Objective-C/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://www.wuchao.net.cn/tags/UI/"}]},{"title":"自定义collocationViewLayout实现瀑布流","slug":"自定义collocationViewLayout实现瀑布流","date":"2017-08-07T01:22:48.000Z","updated":"2018-09-29T07:50:37.000Z","comments":true,"path":"2017/08/07/自定义collocationViewLayout实现瀑布流/","link":"","permalink":"http://www.wuchao.net.cn/2017/08/07/自定义collocationViewLayout实现瀑布流/","excerpt":"","text":"&emsp;实现瀑布流简单，实现分区瀑布流，并且每个区的瀑布流的列数不一样且有区头和区尾，就不是太容易了。我嫌麻烦不愿意自己写（——&gt;我承认懒，不愿意动脑子 V）开始在网上找了好多，都是仅仅一个区的瀑布流，没区头和区尾，完全满足不了我的需求。没办法，产品的需求在那，不能不做吧，于是自己静下心来开始写。 其代理方法和属性模仿UICollectionViewFlowLayout 所写，使用方法和UICollectionViewFlowLayout类似 功能描述： 满足UICollectionViewFlowLayout提供的普通的线性布局和网格布局 满足单区和多区的瀑布流布局。 满足多区瀑布流时每个区的列数可以不同 满足设置header和footer 满足设置header和footer的间距 注意：本文不涉及到装饰视图的相关代理方法以及计算。 首先要明白的事情：collectionView与collocationViewLayout的关系。 collocationView负责展示，collectionviewLayout负责提供如何展示，包括cell的大小位置，header和footer的大小位置等，UICollectionViewFlowLayout 继承自UICollectionViewLayout是苹果公司封装好的layout，可以实现简单的网格和线性布局，当cell的大小和间距一样时可以用UICollectionViewFlowLayout，如果要实现比较复杂的布局，就需要自定义了。 其次，要了解UICollectionViewLayoutAttributes 类的属性，以下是每一个cell的属性，都是通过UICollectionViewLayoutAttributes属性体现出来的。 1234567891011121314151617CGRect frame; // cell的大小已经x，y值CGPoint center;//cell的中心点CGSize size;// cell的sizeCATransform3D transform3D;// cell的3D旋转CGRect bounds NS_AVAILABLE_IOS(7_0);CGAffineTransform transform NS_AVAILABLE_IOS(7_0); // cell 的旋转CGFloat alpha;//alp值NSInteger zIndex; // default is 0 //z轴getter=isHidden) BOOL hidden; // As an optimization, 还有，要理解UICollectionViewLayout的几个方法： prepareLayout ：是专门用来准备布局的，在prepareLayout方法里面我们可以事先就计算后面要用到的布局信息并存储起来，防止后面方法多次计算，提高性能。例如，我们可以在此方法就计算好每个cell的属性、整个CollectionView的内容尺寸等等。此方法在布局之前会调用一次，之后只有在调用invalidateLayout、shouldInvalidateLayoutForBoundsChange:返回YES和UICollectionView刷新的时候才会调用。 1- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath 返回对应的indexPath的cell的attributes 1-(UICollectionViewLayoutAttributes *)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath 返回对应的header和footer的attributes 4. 1- (CGSize)collectionViewContentSize ；collectionView的size 这个size不是可视范围的size是整个collectionView的size 1- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect 返回在rect范围内所有cell footer和head的attribute 了解以上的几点就可以开始计算了。计算的顺序是从上到下，即从区头到每个区的cell再到区尾 设置一些数组用于存储计算好的值：如下 //存放attribute的数组 1234567891011121314151617@property (nonatomic, strong) NSMutableArray *attrsArray;//存放当前区中各个列的当前的高度@property (nonatomic, strong) NSMutableArray *columnHeights;//collectionView的Content的高度@property (nonatomic, assign) CGFloat contentHeight;//记录每个区最高的@property (nonatomic, assign) CGFloat lastContentHeight;//每个区的区头和上个区的区尾的距离@property (nonatomic, assign) CGFloat spacingWithLastSection; 首先是重写 prepareLayout方法，也是最重要的一步。在此方法中完成初始化。所有的计算都置为零。 第一步：通过 1[self.collectionView numberOfSections] 方法获取collectionView中一共有几个区。设置一个for循环。 第二步：通过 1- (UICollectionViewLayoutAttributes *)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath 获取每个header的属性。计算完成之后把attributes添加到attrsArray 数组中 ，同时还有根据sectionInsets 等参数改变contentHeight 的高度 第三步: 设置区头完成之后，在循环中根据1[self.collectionView numberOfItemsInSection:i] 获取相应的区有多少个cell 在这一步中计算是最麻烦的。可以分为如下步骤： 计算每一个cell的frame。 根据此区中一共有几列和屏幕的宽度，以及每个cell的之间的间距，计算出每个cell的宽度，因为高度是外面传过来的，所以高度不需要计算 。那么还需要知道cell的x值和y值。 x值：首先取出当前区的中哪一列最低。 123NSInteger tempMinColumn = 0; //默认第 0 列最小CGFloat minColumnHeight = [self.columnHeights[0] doubleValue]; // 取出最小的那一列的高度 12345678910111213for (NSInteger i = 0; i &lt; self.columnCount; i ++) &#123;CGFloat columnH = [self.columnHeights[i] doubleValue];if (minColumnHeight &gt; columnH) &#123;minColumnHeight = columnH;tempMinColumn = i;&#125; else &#123;&#125;&#125; tempMinColumn 就是最小的那一列 x值就可以根据sectionInsets ， 每个cell的左右间距，和cell的宽度算出 1CGFloat cellX = self.sectionInsets.left + tempMinColumn * (cellWeight + self.interitemSpacing); y值：上面已经求出高度最小的那一列，以及最小的那一列的高度。 y值就 cellY = minColumnHeight 注意：//如果cell的y值不等于上个区的最高的高度 即不是此区的第一列 要加上此区的每个cell的上下间距 12345if (cellY != self.lastContentHeight) &#123;cellY += self.lineSpacing;&#125; else &#123;&#125; 这样就可以知道了 cell的frame了， 即 1attributes.frame = CGRectMake(cellX, cellY, cellWeight, cellHeight); 要更新 contentHeight （当前collectionView的内容的高度） 和columnHeights（当区的每列的高度或者说每列的最后一个cell的y值 + height） 那么这样相应cell的值就计算完毕 ，在此函数返回值处添加到attrsArray 中去。 第四部：同header的计算方式一样 在 1- (UICollectionViewLayoutAttributes *)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath 计算footer的frame 一共多少个区 ，每个区的header的frame是多少，每个区中有多少个cell 每个cell的frame是多少 ，每个区的footer的frame是多少，以此循环计算出所有的attributes，在- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect 返回计算的attributes 注意 ：在计算每个attributes时 collectionView的内容的高度即contentHeight collectionView上个区的最高的那一列的高度即lastContentHeight 都在改变。 在 12345- (CGSize)collectionViewContentSize &#123;return CGSizeMake(self.collectionView.frame.size.width, self.contentHeight);&#125; 中返回collectionView ContentSize 完成布局。 为了支持扩展性和易用性，我完全模仿 UICollectionViewFlowLayout 的用法设置代理方法和属性。至于其使用方法，和UICollectionViewFlowLayout 一样的。代理方法和属性如下。 12345678910111213141516171819202122232425@property (nonatomic, weak) id delegate;// 区的sectionInsets@property (nonatomic,assign) UIEdgeInsets sectionInsets;//每个区的列数@property (nonatomic,assign) NSInteger columnCount;// 每个cell的上下间距@property (nonatomic,assign) CGFloat lineSpacing;//每个cell的左右间距@property (nonatomic,assign) CGFloat interitemSpacing;//header的size@property (nonatomic,assign) CGSize headerReferenceSize;// footer的size@property (nonatomic,assign) CGSize footerReferenceSize; 上述的这些参数 如果每个区都一样，则可以在layout初始化的时候设置，如过每个区的参数设置都不一样，比如第一个区是两列，第二个区是一列，不用担心，用代理。 代理方法支持分区设置这些参数。 @protocol JWCCustomLayoutDelegate @required// cell 高 1- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(JWCCustomLayout *)collectionViewLayout heightForRowAtIndexPath:(NSIndexPath *)indexPath itemWidth:(CGFloat)itemWidth ; @optional// headersize 1- (CGSize)collectionView:(UICollectionView *)collectionView layout:(JWCCustomLayout *)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section; // footer 的 size 1- (CGSize)collectionView:(UICollectionView *)collectionView layout:(JWCCustomLayout *)collectionViewLayout referenceSizeForFooterInSection:(NSInteger)section; // 每个区的边距 1- (UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(JWCCustomLayout*)collectionViewLayout insetForSectionAtIndex:(NSInteger)section; // 每个区多少列 1- (NSInteger)collectionView:(UICollectionView *)collectionView layout:(JWCCustomLayout *)collectionViewLayout columnNumberAtSection:(NSInteger )section; // 每个区多少中行距 1- (NSInteger)collectionView:(UICollectionView *)collectionView layout:(JWCCustomLayout *)collectionViewLayout lineSpacingForSectionAtIndex:(NSInteger)section; // 每个 item 之间的左右间距 1- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(JWCCustomLayout*)collectionViewLayout interitemSpacingForSectionAtIndex:(NSInteger)section; // 本区区头和上个区区尾的间距 1- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(JWCCustomLayout*)collectionViewLayout spacingWithLastSectionForSectionAtIndex:(NSInteger)section; （注意：在collectionViewFolwLayout中是无法设置当前的区头和上个区尾的间距的，为了弥补这一缺憾，特此添加这个方法） 以上只是大致计算步骤，具体实现代码见 Demo 看完如果对你有用 请点赞鼓励下中不中？🤣 🤣 效果图如下","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.wuchao.net.cn/categories/Objective-C/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://www.wuchao.net.cn/tags/UI/"}]}]}